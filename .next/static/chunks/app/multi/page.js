/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["app/multi/page"],{

/***/ "(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Fjonathanvincentius%2FDocuments%2FUofT%2FProjects%2Fcowriting-llm-agent%2Fsrc%2Fapp%2Fmulti%2Fpage.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false!":
/*!*********************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Fjonathanvincentius%2FDocuments%2FUofT%2FProjects%2Fcowriting-llm-agent%2Fsrc%2Fapp%2Fmulti%2Fpage.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false! ***!
  \*********************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("Promise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./src/app/multi/page.tsx */ \"(app-pages-browser)/./src/app/multi/page.tsx\"));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtZmxpZ2h0LWNsaWVudC1lbnRyeS1sb2FkZXIuanM/bW9kdWxlcz0lN0IlMjJyZXF1ZXN0JTIyJTNBJTIyJTJGVXNlcnMlMkZqb25hdGhhbnZpbmNlbnRpdXMlMkZEb2N1bWVudHMlMkZVb2ZUJTJGUHJvamVjdHMlMkZjb3dyaXRpbmctbGxtLWFnZW50JTJGc3JjJTJGYXBwJTJGbXVsdGklMkZwYWdlLnRzeCUyMiUyQyUyMmlkcyUyMiUzQSU1QiU1RCU3RCZzZXJ2ZXI9ZmFsc2UhIiwibWFwcGluZ3MiOiJBQUFBLDBLQUFpSSIsInNvdXJjZXMiOlsiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCgvKiB3ZWJwYWNrTW9kZTogXCJlYWdlclwiICovIFwiL1VzZXJzL2pvbmF0aGFudmluY2VudGl1cy9Eb2N1bWVudHMvVW9mVC9Qcm9qZWN0cy9jb3dyaXRpbmctbGxtLWFnZW50L3NyYy9hcHAvbXVsdGkvcGFnZS50c3hcIik7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Fjonathanvincentius%2FDocuments%2FUofT%2FProjects%2Fcowriting-llm-agent%2Fsrc%2Fapp%2Fmulti%2Fpage.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false!\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/api/image.js":
/*!*********************************************!*\
  !*** ./node_modules/next/dist/api/image.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* reexport default from dynamic */ _shared_lib_image_external__WEBPACK_IMPORTED_MODULE_0___default.a)\n/* harmony export */ });\n/* harmony import */ var _shared_lib_image_external__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shared/lib/image-external */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/image-external.js\");\n/* harmony import */ var _shared_lib_image_external__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_shared_lib_image_external__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _shared_lib_image_external__WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== \"default\") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _shared_lib_image_external__WEBPACK_IMPORTED_MODULE_0__[__WEBPACK_IMPORT_KEY__]\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n\n\n\n//# sourceMappingURL=image.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYXBpL2ltYWdlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUF1RDtBQUNWOztBQUU3QyIsInNvdXJjZXMiOlsiL1VzZXJzL2pvbmF0aGFudmluY2VudGl1cy9Eb2N1bWVudHMvVW9mVC9Qcm9qZWN0cy9jb3dyaXRpbmctbGxtLWFnZW50L25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYXBpL2ltYWdlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB7IGRlZmF1bHQgfSBmcm9tICcuLi9zaGFyZWQvbGliL2ltYWdlLWV4dGVybmFsJztcbmV4cG9ydCAqIGZyb20gJy4uL3NoYXJlZC9saWIvaW1hZ2UtZXh0ZXJuYWwnO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbWFnZS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/api/image.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/api/navigation.js":
/*!**************************************************!*\
  !*** ./node_modules/next/dist/api/navigation.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _client_components_navigation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../client/components/navigation */ \"(app-pages-browser)/./node_modules/next/dist/client/components/navigation.js\");\n/* harmony import */ var _client_components_navigation__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_client_components_navigation__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _client_components_navigation__WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== \"default\") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _client_components_navigation__WEBPACK_IMPORTED_MODULE_0__[__WEBPACK_IMPORT_KEY__]\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n\n\n//# sourceMappingURL=navigation.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYXBpL25hdmlnYXRpb24uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQWdEOztBQUVoRCIsInNvdXJjZXMiOlsiL1VzZXJzL2pvbmF0aGFudmluY2VudGl1cy9Eb2N1bWVudHMvVW9mVC9Qcm9qZWN0cy9jb3dyaXRpbmctbGxtLWFnZW50L25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYXBpL25hdmlnYXRpb24uanMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0ICogZnJvbSAnLi4vY2xpZW50L2NvbXBvbmVudHMvbmF2aWdhdGlvbic7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5hdmlnYXRpb24uanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/api/navigation.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/picomatch/index.js":
/*!************************************************************!*\
  !*** ./node_modules/next/dist/compiled/picomatch/index.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("var __dirname = \"/\";\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n(()=>{\"use strict\";var t={170:(t,e,u)=>{const n=u(510);const isWindows=()=>{if(typeof navigator!==\"undefined\"&&navigator.platform){const t=navigator.platform.toLowerCase();return t===\"win32\"||t===\"windows\"}if(typeof process!==\"undefined\"&&process.platform){return process.platform===\"win32\"}return false};function picomatch(t,e,u=false){if(e&&(e.windows===null||e.windows===undefined)){e={...e,windows:isWindows()}}return n(t,e,u)}Object.assign(picomatch,n);t.exports=picomatch},154:t=>{const e=\"\\\\\\\\/\";const u=`[^${e}]`;const n=\"\\\\.\";const o=\"\\\\+\";const s=\"\\\\?\";const r=\"\\\\/\";const a=\"(?=.)\";const i=\"[^/]\";const c=`(?:${r}|$)`;const p=`(?:^|${r})`;const l=`${n}{1,2}${c}`;const f=`(?!${n})`;const A=`(?!${p}${l})`;const _=`(?!${n}{0,1}${c})`;const R=`(?!${l})`;const E=`[^.${r}]`;const h=`${i}*?`;const g=\"/\";const b={DOT_LITERAL:n,PLUS_LITERAL:o,QMARK_LITERAL:s,SLASH_LITERAL:r,ONE_CHAR:a,QMARK:i,END_ANCHOR:c,DOTS_SLASH:l,NO_DOT:f,NO_DOTS:A,NO_DOT_SLASH:_,NO_DOTS_SLASH:R,QMARK_NO_DOT:E,STAR:h,START_ANCHOR:p,SEP:g};const C={...b,SLASH_LITERAL:`[${e}]`,QMARK:u,STAR:`${u}*?`,DOTS_SLASH:`${n}{1,2}(?:[${e}]|$)`,NO_DOT:`(?!${n})`,NO_DOTS:`(?!(?:^|[${e}])${n}{1,2}(?:[${e}]|$))`,NO_DOT_SLASH:`(?!${n}{0,1}(?:[${e}]|$))`,NO_DOTS_SLASH:`(?!${n}{1,2}(?:[${e}]|$))`,QMARK_NO_DOT:`[^.${e}]`,START_ANCHOR:`(?:^|[${e}])`,END_ANCHOR:`(?:[${e}]|$)`,SEP:\"\\\\\"};const y={alnum:\"a-zA-Z0-9\",alpha:\"a-zA-Z\",ascii:\"\\\\x00-\\\\x7F\",blank:\" \\\\t\",cntrl:\"\\\\x00-\\\\x1F\\\\x7F\",digit:\"0-9\",graph:\"\\\\x21-\\\\x7E\",lower:\"a-z\",print:\"\\\\x20-\\\\x7E \",punct:\"\\\\-!\\\"#$%&'()\\\\*+,./:;<=>?@[\\\\]^_`{|}~\",space:\" \\\\t\\\\r\\\\n\\\\v\\\\f\",upper:\"A-Z\",word:\"A-Za-z0-9_\",xdigit:\"A-Fa-f0-9\"};t.exports={MAX_LENGTH:1024*64,POSIX_REGEX_SOURCE:y,REGEX_BACKSLASH:/\\\\(?![*+?^${}(|)[\\]])/g,REGEX_NON_SPECIAL_CHARS:/^[^@![\\].,$*+?^{}()|\\\\/]+/,REGEX_SPECIAL_CHARS:/[-*+?.^${}(|)[\\]]/,REGEX_SPECIAL_CHARS_BACKREF:/(\\\\?)((\\W)(\\3*))/g,REGEX_SPECIAL_CHARS_GLOBAL:/([-*+?.^${}(|)[\\]])/g,REGEX_REMOVE_BACKSLASH:/(?:\\[.*?[^\\\\]\\]|\\\\(?=.))/g,REPLACEMENTS:{\"***\":\"*\",\"**/**\":\"**\",\"**/**/**\":\"**\"},CHAR_0:48,CHAR_9:57,CHAR_UPPERCASE_A:65,CHAR_LOWERCASE_A:97,CHAR_UPPERCASE_Z:90,CHAR_LOWERCASE_Z:122,CHAR_LEFT_PARENTHESES:40,CHAR_RIGHT_PARENTHESES:41,CHAR_ASTERISK:42,CHAR_AMPERSAND:38,CHAR_AT:64,CHAR_BACKWARD_SLASH:92,CHAR_CARRIAGE_RETURN:13,CHAR_CIRCUMFLEX_ACCENT:94,CHAR_COLON:58,CHAR_COMMA:44,CHAR_DOT:46,CHAR_DOUBLE_QUOTE:34,CHAR_EQUAL:61,CHAR_EXCLAMATION_MARK:33,CHAR_FORM_FEED:12,CHAR_FORWARD_SLASH:47,CHAR_GRAVE_ACCENT:96,CHAR_HASH:35,CHAR_HYPHEN_MINUS:45,CHAR_LEFT_ANGLE_BRACKET:60,CHAR_LEFT_CURLY_BRACE:123,CHAR_LEFT_SQUARE_BRACKET:91,CHAR_LINE_FEED:10,CHAR_NO_BREAK_SPACE:160,CHAR_PERCENT:37,CHAR_PLUS:43,CHAR_QUESTION_MARK:63,CHAR_RIGHT_ANGLE_BRACKET:62,CHAR_RIGHT_CURLY_BRACE:125,CHAR_RIGHT_SQUARE_BRACKET:93,CHAR_SEMICOLON:59,CHAR_SINGLE_QUOTE:39,CHAR_SPACE:32,CHAR_TAB:9,CHAR_UNDERSCORE:95,CHAR_VERTICAL_LINE:124,CHAR_ZERO_WIDTH_NOBREAK_SPACE:65279,extglobChars(t){return{\"!\":{type:\"negate\",open:\"(?:(?!(?:\",close:`))${t.STAR})`},\"?\":{type:\"qmark\",open:\"(?:\",close:\")?\"},\"+\":{type:\"plus\",open:\"(?:\",close:\")+\"},\"*\":{type:\"star\",open:\"(?:\",close:\")*\"},\"@\":{type:\"at\",open:\"(?:\",close:\")\"}}},globChars(t){return t===true?C:b}}},697:(t,e,u)=>{const n=u(154);const o=u(96);const{MAX_LENGTH:s,POSIX_REGEX_SOURCE:r,REGEX_NON_SPECIAL_CHARS:a,REGEX_SPECIAL_CHARS_BACKREF:i,REPLACEMENTS:c}=n;const expandRange=(t,e)=>{if(typeof e.expandRange===\"function\"){return e.expandRange(...t,e)}t.sort();const u=`[${t.join(\"-\")}]`;try{new RegExp(u)}catch(e){return t.map((t=>o.escapeRegex(t))).join(\"..\")}return u};const syntaxError=(t,e)=>`Missing ${t}: \"${e}\" - use \"\\\\\\\\${e}\" to match literal characters`;const parse=(t,e)=>{if(typeof t!==\"string\"){throw new TypeError(\"Expected a string\")}t=c[t]||t;const u={...e};const p=typeof u.maxLength===\"number\"?Math.min(s,u.maxLength):s;let l=t.length;if(l>p){throw new SyntaxError(`Input length: ${l}, exceeds maximum allowed length: ${p}`)}const f={type:\"bos\",value:\"\",output:u.prepend||\"\"};const A=[f];const _=u.capture?\"\":\"?:\";const R=n.globChars(u.windows);const E=n.extglobChars(R);const{DOT_LITERAL:h,PLUS_LITERAL:g,SLASH_LITERAL:b,ONE_CHAR:C,DOTS_SLASH:y,NO_DOT:$,NO_DOT_SLASH:x,NO_DOTS_SLASH:S,QMARK:H,QMARK_NO_DOT:v,STAR:d,START_ANCHOR:L}=R;const globstar=t=>`(${_}(?:(?!${L}${t.dot?y:h}).)*?)`;const T=u.dot?\"\":$;const O=u.dot?H:v;let k=u.bash===true?globstar(u):d;if(u.capture){k=`(${k})`}if(typeof u.noext===\"boolean\"){u.noextglob=u.noext}const m={input:t,index:-1,start:0,dot:u.dot===true,consumed:\"\",output:\"\",prefix:\"\",backtrack:false,negated:false,brackets:0,braces:0,parens:0,quotes:0,globstar:false,tokens:A};t=o.removePrefix(t,m);l=t.length;const w=[];const N=[];const I=[];let B=f;let G;const eos=()=>m.index===l-1;const D=m.peek=(e=1)=>t[m.index+e];const M=m.advance=()=>t[++m.index]||\"\";const remaining=()=>t.slice(m.index+1);const consume=(t=\"\",e=0)=>{m.consumed+=t;m.index+=e};const append=t=>{m.output+=t.output!=null?t.output:t.value;consume(t.value)};const negate=()=>{let t=1;while(D()===\"!\"&&(D(2)!==\"(\"||D(3)===\"?\")){M();m.start++;t++}if(t%2===0){return false}m.negated=true;m.start++;return true};const increment=t=>{m[t]++;I.push(t)};const decrement=t=>{m[t]--;I.pop()};const push=t=>{if(B.type===\"globstar\"){const e=m.braces>0&&(t.type===\"comma\"||t.type===\"brace\");const u=t.extglob===true||w.length&&(t.type===\"pipe\"||t.type===\"paren\");if(t.type!==\"slash\"&&t.type!==\"paren\"&&!e&&!u){m.output=m.output.slice(0,-B.output.length);B.type=\"star\";B.value=\"*\";B.output=k;m.output+=B.output}}if(w.length&&t.type!==\"paren\"){w[w.length-1].inner+=t.value}if(t.value||t.output)append(t);if(B&&B.type===\"text\"&&t.type===\"text\"){B.output=(B.output||B.value)+t.value;B.value+=t.value;return}t.prev=B;A.push(t);B=t};const extglobOpen=(t,e)=>{const n={...E[e],conditions:1,inner:\"\"};n.prev=B;n.parens=m.parens;n.output=m.output;const o=(u.capture?\"(\":\"\")+n.open;increment(\"parens\");push({type:t,value:e,output:m.output?\"\":C});push({type:\"paren\",extglob:true,value:M(),output:o});w.push(n)};const extglobClose=t=>{let n=t.close+(u.capture?\")\":\"\");let o;if(t.type===\"negate\"){let s=k;if(t.inner&&t.inner.length>1&&t.inner.includes(\"/\")){s=globstar(u)}if(s!==k||eos()||/^\\)+$/.test(remaining())){n=t.close=`)$))${s}`}if(t.inner.includes(\"*\")&&(o=remaining())&&/^\\.[^\\\\/.]+$/.test(o)){const u=parse(o,{...e,fastpaths:false}).output;n=t.close=`)${u})${s})`}if(t.prev.type===\"bos\"){m.negatedExtglob=true}}push({type:\"paren\",extglob:true,value:G,output:n});decrement(\"parens\")};if(u.fastpaths!==false&&!/(^[*!]|[/()[\\]{}\"])/.test(t)){let n=false;let s=t.replace(i,((t,e,u,o,s,r)=>{if(o===\"\\\\\"){n=true;return t}if(o===\"?\"){if(e){return e+o+(s?H.repeat(s.length):\"\")}if(r===0){return O+(s?H.repeat(s.length):\"\")}return H.repeat(u.length)}if(o===\".\"){return h.repeat(u.length)}if(o===\"*\"){if(e){return e+o+(s?k:\"\")}return k}return e?t:`\\\\${t}`}));if(n===true){if(u.unescape===true){s=s.replace(/\\\\/g,\"\")}else{s=s.replace(/\\\\+/g,(t=>t.length%2===0?\"\\\\\\\\\":t?\"\\\\\":\"\"))}}if(s===t&&u.contains===true){m.output=t;return m}m.output=o.wrapOutput(s,m,e);return m}while(!eos()){G=M();if(G===\"\\0\"){continue}if(G===\"\\\\\"){const t=D();if(t===\"/\"&&u.bash!==true){continue}if(t===\".\"||t===\";\"){continue}if(!t){G+=\"\\\\\";push({type:\"text\",value:G});continue}const e=/^\\\\+/.exec(remaining());let n=0;if(e&&e[0].length>2){n=e[0].length;m.index+=n;if(n%2!==0){G+=\"\\\\\"}}if(u.unescape===true){G=M()}else{G+=M()}if(m.brackets===0){push({type:\"text\",value:G});continue}}if(m.brackets>0&&(G!==\"]\"||B.value===\"[\"||B.value===\"[^\")){if(u.posix!==false&&G===\":\"){const t=B.value.slice(1);if(t.includes(\"[\")){B.posix=true;if(t.includes(\":\")){const t=B.value.lastIndexOf(\"[\");const e=B.value.slice(0,t);const u=B.value.slice(t+2);const n=r[u];if(n){B.value=e+n;m.backtrack=true;M();if(!f.output&&A.indexOf(B)===1){f.output=C}continue}}}}if(G===\"[\"&&D()!==\":\"||G===\"-\"&&D()===\"]\"){G=`\\\\${G}`}if(G===\"]\"&&(B.value===\"[\"||B.value===\"[^\")){G=`\\\\${G}`}if(u.posix===true&&G===\"!\"&&B.value===\"[\"){G=\"^\"}B.value+=G;append({value:G});continue}if(m.quotes===1&&G!=='\"'){G=o.escapeRegex(G);B.value+=G;append({value:G});continue}if(G==='\"'){m.quotes=m.quotes===1?0:1;if(u.keepQuotes===true){push({type:\"text\",value:G})}continue}if(G===\"(\"){increment(\"parens\");push({type:\"paren\",value:G});continue}if(G===\")\"){if(m.parens===0&&u.strictBrackets===true){throw new SyntaxError(syntaxError(\"opening\",\"(\"))}const t=w[w.length-1];if(t&&m.parens===t.parens+1){extglobClose(w.pop());continue}push({type:\"paren\",value:G,output:m.parens?\")\":\"\\\\)\"});decrement(\"parens\");continue}if(G===\"[\"){if(u.nobracket===true||!remaining().includes(\"]\")){if(u.nobracket!==true&&u.strictBrackets===true){throw new SyntaxError(syntaxError(\"closing\",\"]\"))}G=`\\\\${G}`}else{increment(\"brackets\")}push({type:\"bracket\",value:G});continue}if(G===\"]\"){if(u.nobracket===true||B&&B.type===\"bracket\"&&B.value.length===1){push({type:\"text\",value:G,output:`\\\\${G}`});continue}if(m.brackets===0){if(u.strictBrackets===true){throw new SyntaxError(syntaxError(\"opening\",\"[\"))}push({type:\"text\",value:G,output:`\\\\${G}`});continue}decrement(\"brackets\");const t=B.value.slice(1);if(B.posix!==true&&t[0]===\"^\"&&!t.includes(\"/\")){G=`/${G}`}B.value+=G;append({value:G});if(u.literalBrackets===false||o.hasRegexChars(t)){continue}const e=o.escapeRegex(B.value);m.output=m.output.slice(0,-B.value.length);if(u.literalBrackets===true){m.output+=e;B.value=e;continue}B.value=`(${_}${e}|${B.value})`;m.output+=B.value;continue}if(G===\"{\"&&u.nobrace!==true){increment(\"braces\");const t={type:\"brace\",value:G,output:\"(\",outputIndex:m.output.length,tokensIndex:m.tokens.length};N.push(t);push(t);continue}if(G===\"}\"){const t=N[N.length-1];if(u.nobrace===true||!t){push({type:\"text\",value:G,output:G});continue}let e=\")\";if(t.dots===true){const t=A.slice();const n=[];for(let e=t.length-1;e>=0;e--){A.pop();if(t[e].type===\"brace\"){break}if(t[e].type!==\"dots\"){n.unshift(t[e].value)}}e=expandRange(n,u);m.backtrack=true}if(t.comma!==true&&t.dots!==true){const u=m.output.slice(0,t.outputIndex);const n=m.tokens.slice(t.tokensIndex);t.value=t.output=\"\\\\{\";G=e=\"\\\\}\";m.output=u;for(const t of n){m.output+=t.output||t.value}}push({type:\"brace\",value:G,output:e});decrement(\"braces\");N.pop();continue}if(G===\"|\"){if(w.length>0){w[w.length-1].conditions++}push({type:\"text\",value:G});continue}if(G===\",\"){let t=G;const e=N[N.length-1];if(e&&I[I.length-1]===\"braces\"){e.comma=true;t=\"|\"}push({type:\"comma\",value:G,output:t});continue}if(G===\"/\"){if(B.type===\"dot\"&&m.index===m.start+1){m.start=m.index+1;m.consumed=\"\";m.output=\"\";A.pop();B=f;continue}push({type:\"slash\",value:G,output:b});continue}if(G===\".\"){if(m.braces>0&&B.type===\"dot\"){if(B.value===\".\")B.output=h;const t=N[N.length-1];B.type=\"dots\";B.output+=G;B.value+=G;t.dots=true;continue}if(m.braces+m.parens===0&&B.type!==\"bos\"&&B.type!==\"slash\"){push({type:\"text\",value:G,output:h});continue}push({type:\"dot\",value:G,output:h});continue}if(G===\"?\"){const t=B&&B.value===\"(\";if(!t&&u.noextglob!==true&&D()===\"(\"&&D(2)!==\"?\"){extglobOpen(\"qmark\",G);continue}if(B&&B.type===\"paren\"){const t=D();let e=G;if(B.value===\"(\"&&!/[!=<:]/.test(t)||t===\"<\"&&!/<([!=]|\\w+>)/.test(remaining())){e=`\\\\${G}`}push({type:\"text\",value:G,output:e});continue}if(u.dot!==true&&(B.type===\"slash\"||B.type===\"bos\")){push({type:\"qmark\",value:G,output:v});continue}push({type:\"qmark\",value:G,output:H});continue}if(G===\"!\"){if(u.noextglob!==true&&D()===\"(\"){if(D(2)!==\"?\"||!/[!=<:]/.test(D(3))){extglobOpen(\"negate\",G);continue}}if(u.nonegate!==true&&m.index===0){negate();continue}}if(G===\"+\"){if(u.noextglob!==true&&D()===\"(\"&&D(2)!==\"?\"){extglobOpen(\"plus\",G);continue}if(B&&B.value===\"(\"||u.regex===false){push({type:\"plus\",value:G,output:g});continue}if(B&&(B.type===\"bracket\"||B.type===\"paren\"||B.type===\"brace\")||m.parens>0){push({type:\"plus\",value:G});continue}push({type:\"plus\",value:g});continue}if(G===\"@\"){if(u.noextglob!==true&&D()===\"(\"&&D(2)!==\"?\"){push({type:\"at\",extglob:true,value:G,output:\"\"});continue}push({type:\"text\",value:G});continue}if(G!==\"*\"){if(G===\"$\"||G===\"^\"){G=`\\\\${G}`}const t=a.exec(remaining());if(t){G+=t[0];m.index+=t[0].length}push({type:\"text\",value:G});continue}if(B&&(B.type===\"globstar\"||B.star===true)){B.type=\"star\";B.star=true;B.value+=G;B.output=k;m.backtrack=true;m.globstar=true;consume(G);continue}let e=remaining();if(u.noextglob!==true&&/^\\([^?]/.test(e)){extglobOpen(\"star\",G);continue}if(B.type===\"star\"){if(u.noglobstar===true){consume(G);continue}const n=B.prev;const o=n.prev;const s=n.type===\"slash\"||n.type===\"bos\";const r=o&&(o.type===\"star\"||o.type===\"globstar\");if(u.bash===true&&(!s||e[0]&&e[0]!==\"/\")){push({type:\"star\",value:G,output:\"\"});continue}const a=m.braces>0&&(n.type===\"comma\"||n.type===\"brace\");const i=w.length&&(n.type===\"pipe\"||n.type===\"paren\");if(!s&&n.type!==\"paren\"&&!a&&!i){push({type:\"star\",value:G,output:\"\"});continue}while(e.slice(0,3)===\"/**\"){const u=t[m.index+4];if(u&&u!==\"/\"){break}e=e.slice(3);consume(\"/**\",3)}if(n.type===\"bos\"&&eos()){B.type=\"globstar\";B.value+=G;B.output=globstar(u);m.output=B.output;m.globstar=true;consume(G);continue}if(n.type===\"slash\"&&n.prev.type!==\"bos\"&&!r&&eos()){m.output=m.output.slice(0,-(n.output+B.output).length);n.output=`(?:${n.output}`;B.type=\"globstar\";B.output=globstar(u)+(u.strictSlashes?\")\":\"|$)\");B.value+=G;m.globstar=true;m.output+=n.output+B.output;consume(G);continue}if(n.type===\"slash\"&&n.prev.type!==\"bos\"&&e[0]===\"/\"){const t=e[1]!==void 0?\"|$\":\"\";m.output=m.output.slice(0,-(n.output+B.output).length);n.output=`(?:${n.output}`;B.type=\"globstar\";B.output=`${globstar(u)}${b}|${b}${t})`;B.value+=G;m.output+=n.output+B.output;m.globstar=true;consume(G+M());push({type:\"slash\",value:\"/\",output:\"\"});continue}if(n.type===\"bos\"&&e[0]===\"/\"){B.type=\"globstar\";B.value+=G;B.output=`(?:^|${b}|${globstar(u)}${b})`;m.output=B.output;m.globstar=true;consume(G+M());push({type:\"slash\",value:\"/\",output:\"\"});continue}m.output=m.output.slice(0,-B.output.length);B.type=\"globstar\";B.output=globstar(u);B.value+=G;m.output+=B.output;m.globstar=true;consume(G);continue}const n={type:\"star\",value:G,output:k};if(u.bash===true){n.output=\".*?\";if(B.type===\"bos\"||B.type===\"slash\"){n.output=T+n.output}push(n);continue}if(B&&(B.type===\"bracket\"||B.type===\"paren\")&&u.regex===true){n.output=G;push(n);continue}if(m.index===m.start||B.type===\"slash\"||B.type===\"dot\"){if(B.type===\"dot\"){m.output+=x;B.output+=x}else if(u.dot===true){m.output+=S;B.output+=S}else{m.output+=T;B.output+=T}if(D()!==\"*\"){m.output+=C;B.output+=C}}push(n)}while(m.brackets>0){if(u.strictBrackets===true)throw new SyntaxError(syntaxError(\"closing\",\"]\"));m.output=o.escapeLast(m.output,\"[\");decrement(\"brackets\")}while(m.parens>0){if(u.strictBrackets===true)throw new SyntaxError(syntaxError(\"closing\",\")\"));m.output=o.escapeLast(m.output,\"(\");decrement(\"parens\")}while(m.braces>0){if(u.strictBrackets===true)throw new SyntaxError(syntaxError(\"closing\",\"}\"));m.output=o.escapeLast(m.output,\"{\");decrement(\"braces\")}if(u.strictSlashes!==true&&(B.type===\"star\"||B.type===\"bracket\")){push({type:\"maybe_slash\",value:\"\",output:`${b}?`})}if(m.backtrack===true){m.output=\"\";for(const t of m.tokens){m.output+=t.output!=null?t.output:t.value;if(t.suffix){m.output+=t.suffix}}}return m};parse.fastpaths=(t,e)=>{const u={...e};const r=typeof u.maxLength===\"number\"?Math.min(s,u.maxLength):s;const a=t.length;if(a>r){throw new SyntaxError(`Input length: ${a}, exceeds maximum allowed length: ${r}`)}t=c[t]||t;const{DOT_LITERAL:i,SLASH_LITERAL:p,ONE_CHAR:l,DOTS_SLASH:f,NO_DOT:A,NO_DOTS:_,NO_DOTS_SLASH:R,STAR:E,START_ANCHOR:h}=n.globChars(u.windows);const g=u.dot?_:A;const b=u.dot?R:A;const C=u.capture?\"\":\"?:\";const y={negated:false,prefix:\"\"};let $=u.bash===true?\".*?\":E;if(u.capture){$=`(${$})`}const globstar=t=>{if(t.noglobstar===true)return $;return`(${C}(?:(?!${h}${t.dot?f:i}).)*?)`};const create=t=>{switch(t){case\"*\":return`${g}${l}${$}`;case\".*\":return`${i}${l}${$}`;case\"*.*\":return`${g}${$}${i}${l}${$}`;case\"*/*\":return`${g}${$}${p}${l}${b}${$}`;case\"**\":return g+globstar(u);case\"**/*\":return`(?:${g}${globstar(u)}${p})?${b}${l}${$}`;case\"**/*.*\":return`(?:${g}${globstar(u)}${p})?${b}${$}${i}${l}${$}`;case\"**/.*\":return`(?:${g}${globstar(u)}${p})?${i}${l}${$}`;default:{const e=/^(.*?)\\.(\\w+)$/.exec(t);if(!e)return;const u=create(e[1]);if(!u)return;return u+i+e[2]}}};const x=o.removePrefix(t,y);let S=create(x);if(S&&u.strictSlashes!==true){S+=`${p}?`}return S};t.exports=parse},510:(t,e,u)=>{const n=u(716);const o=u(697);const s=u(96);const r=u(154);const isObject=t=>t&&typeof t===\"object\"&&!Array.isArray(t);const picomatch=(t,e,u=false)=>{if(Array.isArray(t)){const n=t.map((t=>picomatch(t,e,u)));const arrayMatcher=t=>{for(const e of n){const u=e(t);if(u)return u}return false};return arrayMatcher}const n=isObject(t)&&t.tokens&&t.input;if(t===\"\"||typeof t!==\"string\"&&!n){throw new TypeError(\"Expected pattern to be a non-empty string\")}const o=e||{};const s=o.windows;const r=n?picomatch.compileRe(t,e):picomatch.makeRe(t,e,false,true);const a=r.state;delete r.state;let isIgnored=()=>false;if(o.ignore){const t={...e,ignore:null,onMatch:null,onResult:null};isIgnored=picomatch(o.ignore,t,u)}const matcher=(u,n=false)=>{const{isMatch:i,match:c,output:p}=picomatch.test(u,r,e,{glob:t,posix:s});const l={glob:t,state:a,regex:r,posix:s,input:u,output:p,match:c,isMatch:i};if(typeof o.onResult===\"function\"){o.onResult(l)}if(i===false){l.isMatch=false;return n?l:false}if(isIgnored(u)){if(typeof o.onIgnore===\"function\"){o.onIgnore(l)}l.isMatch=false;return n?l:false}if(typeof o.onMatch===\"function\"){o.onMatch(l)}return n?l:true};if(u){matcher.state=a}return matcher};picomatch.test=(t,e,u,{glob:n,posix:o}={})=>{if(typeof t!==\"string\"){throw new TypeError(\"Expected input to be a string\")}if(t===\"\"){return{isMatch:false,output:\"\"}}const r=u||{};const a=r.format||(o?s.toPosixSlashes:null);let i=t===n;let c=i&&a?a(t):t;if(i===false){c=a?a(t):t;i=c===n}if(i===false||r.capture===true){if(r.matchBase===true||r.basename===true){i=picomatch.matchBase(t,e,u,o)}else{i=e.exec(c)}}return{isMatch:Boolean(i),match:i,output:c}};picomatch.matchBase=(t,e,u)=>{const n=e instanceof RegExp?e:picomatch.makeRe(e,u);return n.test(s.basename(t))};picomatch.isMatch=(t,e,u)=>picomatch(e,u)(t);picomatch.parse=(t,e)=>{if(Array.isArray(t))return t.map((t=>picomatch.parse(t,e)));return o(t,{...e,fastpaths:false})};picomatch.scan=(t,e)=>n(t,e);picomatch.compileRe=(t,e,u=false,n=false)=>{if(u===true){return t.output}const o=e||{};const s=o.contains?\"\":\"^\";const r=o.contains?\"\":\"$\";let a=`${s}(?:${t.output})${r}`;if(t&&t.negated===true){a=`^(?!${a}).*$`}const i=picomatch.toRegex(a,e);if(n===true){i.state=t}return i};picomatch.makeRe=(t,e={},u=false,n=false)=>{if(!t||typeof t!==\"string\"){throw new TypeError(\"Expected a non-empty string\")}let s={negated:false,fastpaths:true};if(e.fastpaths!==false&&(t[0]===\".\"||t[0]===\"*\")){s.output=o.fastpaths(t,e)}if(!s.output){s=o(t,e)}return picomatch.compileRe(s,e,u,n)};picomatch.toRegex=(t,e)=>{try{const u=e||{};return new RegExp(t,u.flags||(u.nocase?\"i\":\"\"))}catch(t){if(e&&e.debug===true)throw t;return/$^/}};picomatch.constants=r;t.exports=picomatch},716:(t,e,u)=>{const n=u(96);const{CHAR_ASTERISK:o,CHAR_AT:s,CHAR_BACKWARD_SLASH:r,CHAR_COMMA:a,CHAR_DOT:i,CHAR_EXCLAMATION_MARK:c,CHAR_FORWARD_SLASH:p,CHAR_LEFT_CURLY_BRACE:l,CHAR_LEFT_PARENTHESES:f,CHAR_LEFT_SQUARE_BRACKET:A,CHAR_PLUS:_,CHAR_QUESTION_MARK:R,CHAR_RIGHT_CURLY_BRACE:E,CHAR_RIGHT_PARENTHESES:h,CHAR_RIGHT_SQUARE_BRACKET:g}=u(154);const isPathSeparator=t=>t===p||t===r;const depth=t=>{if(t.isPrefix!==true){t.depth=t.isGlobstar?Infinity:1}};const scan=(t,e)=>{const u=e||{};const b=t.length-1;const C=u.parts===true||u.scanToEnd===true;const y=[];const $=[];const x=[];let S=t;let H=-1;let v=0;let d=0;let L=false;let T=false;let O=false;let k=false;let m=false;let w=false;let N=false;let I=false;let B=false;let G=false;let D=0;let M;let P;let K={value:\"\",depth:0,isGlob:false};const eos=()=>H>=b;const peek=()=>S.charCodeAt(H+1);const advance=()=>{M=P;return S.charCodeAt(++H)};while(H<b){P=advance();let t;if(P===r){N=K.backslashes=true;P=advance();if(P===l){w=true}continue}if(w===true||P===l){D++;while(eos()!==true&&(P=advance())){if(P===r){N=K.backslashes=true;advance();continue}if(P===l){D++;continue}if(w!==true&&P===i&&(P=advance())===i){L=K.isBrace=true;O=K.isGlob=true;G=true;if(C===true){continue}break}if(w!==true&&P===a){L=K.isBrace=true;O=K.isGlob=true;G=true;if(C===true){continue}break}if(P===E){D--;if(D===0){w=false;L=K.isBrace=true;G=true;break}}}if(C===true){continue}break}if(P===p){y.push(H);$.push(K);K={value:\"\",depth:0,isGlob:false};if(G===true)continue;if(M===i&&H===v+1){v+=2;continue}d=H+1;continue}if(u.noext!==true){const t=P===_||P===s||P===o||P===R||P===c;if(t===true&&peek()===f){O=K.isGlob=true;k=K.isExtglob=true;G=true;if(P===c&&H===v){B=true}if(C===true){while(eos()!==true&&(P=advance())){if(P===r){N=K.backslashes=true;P=advance();continue}if(P===h){O=K.isGlob=true;G=true;break}}continue}break}}if(P===o){if(M===o)m=K.isGlobstar=true;O=K.isGlob=true;G=true;if(C===true){continue}break}if(P===R){O=K.isGlob=true;G=true;if(C===true){continue}break}if(P===A){while(eos()!==true&&(t=advance())){if(t===r){N=K.backslashes=true;advance();continue}if(t===g){T=K.isBracket=true;O=K.isGlob=true;G=true;break}}if(C===true){continue}break}if(u.nonegate!==true&&P===c&&H===v){I=K.negated=true;v++;continue}if(u.noparen!==true&&P===f){O=K.isGlob=true;if(C===true){while(eos()!==true&&(P=advance())){if(P===f){N=K.backslashes=true;P=advance();continue}if(P===h){G=true;break}}continue}break}if(O===true){G=true;if(C===true){continue}break}}if(u.noext===true){k=false;O=false}let U=S;let X=\"\";let F=\"\";if(v>0){X=S.slice(0,v);S=S.slice(v);d-=v}if(U&&O===true&&d>0){U=S.slice(0,d);F=S.slice(d)}else if(O===true){U=\"\";F=S}else{U=S}if(U&&U!==\"\"&&U!==\"/\"&&U!==S){if(isPathSeparator(U.charCodeAt(U.length-1))){U=U.slice(0,-1)}}if(u.unescape===true){if(F)F=n.removeBackslashes(F);if(U&&N===true){U=n.removeBackslashes(U)}}const Q={prefix:X,input:t,start:v,base:U,glob:F,isBrace:L,isBracket:T,isGlob:O,isExtglob:k,isGlobstar:m,negated:I,negatedExtglob:B};if(u.tokens===true){Q.maxDepth=0;if(!isPathSeparator(P)){$.push(K)}Q.tokens=$}if(u.parts===true||u.tokens===true){let e;for(let n=0;n<y.length;n++){const o=e?e+1:v;const s=y[n];const r=t.slice(o,s);if(u.tokens){if(n===0&&v!==0){$[n].isPrefix=true;$[n].value=X}else{$[n].value=r}depth($[n]);Q.maxDepth+=$[n].depth}if(n!==0||r!==\"\"){x.push(r)}e=s}if(e&&e+1<t.length){const n=t.slice(e+1);x.push(n);if(u.tokens){$[$.length-1].value=n;depth($[$.length-1]);Q.maxDepth+=$[$.length-1].depth}}Q.slashes=y;Q.parts=x}return Q};t.exports=scan},96:(t,e,u)=>{const{REGEX_BACKSLASH:n,REGEX_REMOVE_BACKSLASH:o,REGEX_SPECIAL_CHARS:s,REGEX_SPECIAL_CHARS_GLOBAL:r}=u(154);e.isObject=t=>t!==null&&typeof t===\"object\"&&!Array.isArray(t);e.hasRegexChars=t=>s.test(t);e.isRegexChar=t=>t.length===1&&e.hasRegexChars(t);e.escapeRegex=t=>t.replace(r,\"\\\\$1\");e.toPosixSlashes=t=>t.replace(n,\"/\");e.removeBackslashes=t=>t.replace(o,(t=>t===\"\\\\\"?\"\":t));e.escapeLast=(t,u,n)=>{const o=t.lastIndexOf(u,n);if(o===-1)return t;if(t[o-1]===\"\\\\\")return e.escapeLast(t,u,o-1);return`${t.slice(0,o)}\\\\${t.slice(o)}`};e.removePrefix=(t,e={})=>{let u=t;if(u.startsWith(\"./\")){u=u.slice(2);e.prefix=\"./\"}return u};e.wrapOutput=(t,e={},u={})=>{const n=u.contains?\"\":\"^\";const o=u.contains?\"\":\"$\";let s=`${n}(?:${t})${o}`;if(e.negated===true){s=`(?:^(?!${s}).*$)`}return s};e.basename=(t,{windows:e}={})=>{const u=t.split(e?/[\\\\/]/:\"/\");const n=u[u.length-1];if(n===\"\"){return u[u.length-2]}return n}}};var e={};function __nccwpck_require__(u){var n=e[u];if(n!==undefined){return n.exports}var o=e[u]={exports:{}};var s=true;try{t[u](o,o.exports,__nccwpck_require__);s=false}finally{if(s)delete e[u]}return o.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var u=__nccwpck_require__(170);module.exports=u})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcGljb21hdGNoL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7O0FBQUEsTUFBTSxhQUFhLE9BQU8sY0FBYyxlQUFlLHFCQUFxQix1REFBdUQseUNBQXlDLGtDQUFrQyxVQUFVLE9BQU8sZ0JBQWdCLE9BQU8sV0FBVyxPQUFPLE9BQU8sb0JBQW9CLGNBQWMsZ0NBQWdDLGlEQUFpRCxHQUFHLDBCQUEwQixnQkFBZ0IsMkJBQTJCLG9CQUFvQixTQUFTLGdCQUFnQixhQUFhLEVBQUUsR0FBRyxjQUFjLGNBQWMsY0FBYyxjQUFjLGdCQUFnQixlQUFlLGNBQWMsRUFBRSxLQUFLLGdCQUFnQixFQUFFLEdBQUcsV0FBVyxHQUFHLElBQUksRUFBRSxFQUFFLEVBQUUsY0FBYyxFQUFFLEdBQUcsY0FBYyxFQUFFLEVBQUUsRUFBRSxHQUFHLGNBQWMsR0FBRyxJQUFJLEVBQUUsRUFBRSxHQUFHLGNBQWMsRUFBRSxHQUFHLGNBQWMsRUFBRSxHQUFHLFdBQVcsRUFBRSxJQUFJLFlBQVksU0FBUyx3TUFBd00sU0FBUyx1QkFBdUIsRUFBRSxtQkFBbUIsRUFBRSxrQkFBa0IsR0FBRyxJQUFJLE1BQU0sRUFBRSxtQkFBbUIsRUFBRSx1QkFBdUIsRUFBRSxJQUFJLEdBQUcsSUFBSSxNQUFNLEVBQUUsMEJBQTBCLEdBQUcsSUFBSSxNQUFNLEVBQUUsMkJBQTJCLEdBQUcsSUFBSSxNQUFNLEVBQUUsMEJBQTBCLEVBQUUseUJBQXlCLEVBQUUsc0JBQXNCLEVBQUUsZ0JBQWdCLFNBQVMseUxBQXlMLGFBQWEsRUFBRSw4RUFBOEUsV0FBVyxzRUFBc0UscURBQXFELHlDQUF5QyxnR0FBZ0csNEVBQTRFLHVDQUF1QyxtM0JBQW0zQixPQUFPLEtBQUssMENBQTBDLE9BQU8sR0FBRyxNQUFNLG1DQUFtQyxNQUFNLGtDQUFrQyxNQUFNLGtDQUFrQyxNQUFNLGlDQUFpQyxjQUFjLHNCQUFzQixlQUFlLGVBQWUs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QUFPLGFBQWEsU0FBUyxPQUFPLG1CQUFtQixRQUFRLFFBQVEsUUFBUSxTQUFTLFNBQVMsUUFBUSxlQUFlLGFBQWEsS0FBSyxxQkFBcUIsZUFBZSxhQUFhLGtCQUFrQixLQUFLLElBQUksS0FBSyxJQUFJLDhCQUE4Qiw4Q0FBOEMsaUJBQWlCLHNCQUFzQiw4QkFBOEIsZ0JBQWdCLDBCQUEwQixTQUFTLDJIQUEySCxvQkFBb0IsYUFBYSx3QkFBd0IsVUFBVSxXQUFXLG9DQUFvQyxNQUFNLFlBQVksV0FBVyxLQUFLLGdCQUFnQixhQUFhLHFCQUFxQixhQUFhLGlCQUFpQixtQkFBbUIsYUFBYSxLQUFLLGFBQWEsWUFBWSx1QkFBdUIsa0JBQWtCLFVBQVUsSUFBSSxvQkFBb0IscUJBQXFCLFVBQVUsYUFBYSxzQkFBc0IscUJBQXFCLGlDQUFpQyxZQUFZLFVBQVUsVUFBVSxlQUFlLGNBQWMsTUFBTSw4RkFBOEYsUUFBUSwrREFBK0QsNkJBQTZCLGtEQUFrRCxxQ0FBcUMscUNBQXFDLHVEQUF1RCx1QkFBdUIsMkJBQTJCLG1CQUFtQiw4Q0FBOEMsU0FBUyxhQUFhLElBQUksV0FBVyxHQUFHLHNCQUFzQixJQUFJLFFBQVEsdUJBQXVCLGFBQWEsY0FBYyxVQUFVLG9CQUFvQixLQUFLLElBQUksMEJBQTBCLDBCQUEwQixTQUFTLEVBQUUsS0FBSyxFQUFFLEdBQUcsRUFBRSxFQUFFLHFCQUFxQixZQUFZLEVBQUUsT0FBTyxVQUFVLGVBQWUsVUFBVSxHQUFHLElBQUksK0JBQStCLHNCQUFzQixXQUFXLHFCQUFxQixZQUFZLFNBQVMsZ0NBQWdDLFdBQVcsa0JBQWtCLGlCQUFpQixZQUFZLFlBQVksV0FBVyxJQUFJLHNDQUFzQyxRQUFRLFFBQVEsaUJBQWlCLGlCQUFpQixtRUFBbUUsU0FBUyxLQUFLLCtCQUErQixpQkFBaUIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9qb25hdGhhbnZpbmNlbnRpdXMvRG9jdW1lbnRzL1VvZlQvUHJvamVjdHMvY293cml0aW5nLWxsbS1hZ2VudC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3BpY29tYXRjaC9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIoKCk9PntcInVzZSBzdHJpY3RcIjt2YXIgdD17MTcwOih0LGUsdSk9Pntjb25zdCBuPXUoNTEwKTtjb25zdCBpc1dpbmRvd3M9KCk9PntpZih0eXBlb2YgbmF2aWdhdG9yIT09XCJ1bmRlZmluZWRcIiYmbmF2aWdhdG9yLnBsYXRmb3JtKXtjb25zdCB0PW5hdmlnYXRvci5wbGF0Zm9ybS50b0xvd2VyQ2FzZSgpO3JldHVybiB0PT09XCJ3aW4zMlwifHx0PT09XCJ3aW5kb3dzXCJ9aWYodHlwZW9mIHByb2Nlc3MhPT1cInVuZGVmaW5lZFwiJiZwcm9jZXNzLnBsYXRmb3JtKXtyZXR1cm4gcHJvY2Vzcy5wbGF0Zm9ybT09PVwid2luMzJcIn1yZXR1cm4gZmFsc2V9O2Z1bmN0aW9uIHBpY29tYXRjaCh0LGUsdT1mYWxzZSl7aWYoZSYmKGUud2luZG93cz09PW51bGx8fGUud2luZG93cz09PXVuZGVmaW5lZCkpe2U9ey4uLmUsd2luZG93czppc1dpbmRvd3MoKX19cmV0dXJuIG4odCxlLHUpfU9iamVjdC5hc3NpZ24ocGljb21hdGNoLG4pO3QuZXhwb3J0cz1waWNvbWF0Y2h9LDE1NDp0PT57Y29uc3QgZT1cIlxcXFxcXFxcL1wiO2NvbnN0IHU9YFteJHtlfV1gO2NvbnN0IG49XCJcXFxcLlwiO2NvbnN0IG89XCJcXFxcK1wiO2NvbnN0IHM9XCJcXFxcP1wiO2NvbnN0IHI9XCJcXFxcL1wiO2NvbnN0IGE9XCIoPz0uKVwiO2NvbnN0IGk9XCJbXi9dXCI7Y29uc3QgYz1gKD86JHtyfXwkKWA7Y29uc3QgcD1gKD86Xnwke3J9KWA7Y29uc3QgbD1gJHtufXsxLDJ9JHtjfWA7Y29uc3QgZj1gKD8hJHtufSlgO2NvbnN0IEE9YCg/ISR7cH0ke2x9KWA7Y29uc3QgXz1gKD8hJHtufXswLDF9JHtjfSlgO2NvbnN0IFI9YCg/ISR7bH0pYDtjb25zdCBFPWBbXi4ke3J9XWA7Y29uc3QgaD1gJHtpfSo/YDtjb25zdCBnPVwiL1wiO2NvbnN0IGI9e0RPVF9MSVRFUkFMOm4sUExVU19MSVRFUkFMOm8sUU1BUktfTElURVJBTDpzLFNMQVNIX0xJVEVSQUw6cixPTkVfQ0hBUjphLFFNQVJLOmksRU5EX0FOQ0hPUjpjLERPVFNfU0xBU0g6bCxOT19ET1Q6ZixOT19ET1RTOkEsTk9fRE9UX1NMQVNIOl8sTk9fRE9UU19TTEFTSDpSLFFNQVJLX05PX0RPVDpFLFNUQVI6aCxTVEFSVF9BTkNIT1I6cCxTRVA6Z307Y29uc3QgQz17Li4uYixTTEFTSF9MSVRFUkFMOmBbJHtlfV1gLFFNQVJLOnUsU1RBUjpgJHt1fSo/YCxET1RTX1NMQVNIOmAke259ezEsMn0oPzpbJHtlfV18JClgLE5PX0RPVDpgKD8hJHtufSlgLE5PX0RPVFM6YCg/ISg/Ol58WyR7ZX1dKSR7bn17MSwyfSg/Olske2V9XXwkKSlgLE5PX0RPVF9TTEFTSDpgKD8hJHtufXswLDF9KD86WyR7ZX1dfCQpKWAsTk9fRE9UU19TTEFTSDpgKD8hJHtufXsxLDJ9KD86WyR7ZX1dfCQpKWAsUU1BUktfTk9fRE9UOmBbXi4ke2V9XWAsU1RBUlRfQU5DSE9SOmAoPzpefFske2V9XSlgLEVORF9BTkNIT1I6YCg/Olske2V9XXwkKWAsU0VQOlwiXFxcXFwifTtjb25zdCB5PXthbG51bTpcImEtekEtWjAtOVwiLGFscGhhOlwiYS16QS1aXCIsYXNjaWk6XCJcXFxceDAwLVxcXFx4N0ZcIixibGFuazpcIiBcXFxcdFwiLGNudHJsOlwiXFxcXHgwMC1cXFxceDFGXFxcXHg3RlwiLGRpZ2l0OlwiMC05XCIsZ3JhcGg6XCJcXFxceDIxLVxcXFx4N0VcIixsb3dlcjpcImEtelwiLHByaW50OlwiXFxcXHgyMC1cXFxceDdFIFwiLHB1bmN0OlwiXFxcXC0hXFxcIiMkJSYnKClcXFxcKissLi86Ozw9Pj9AW1xcXFxdXl9ge3x9flwiLHNwYWNlOlwiIFxcXFx0XFxcXHJcXFxcblxcXFx2XFxcXGZcIix1cHBlcjpcIkEtWlwiLHdvcmQ6XCJBLVphLXowLTlfXCIseGRpZ2l0OlwiQS1GYS1mMC05XCJ9O3QuZXhwb3J0cz17TUFYX0xFTkdUSDoxMDI0KjY0LFBPU0lYX1JFR0VYX1NPVVJDRTp5LFJFR0VYX0JBQ0tTTEFTSDovXFxcXCg/IVsqKz9eJHt9KHwpW1xcXV0pL2csUkVHRVhfTk9OX1NQRUNJQUxfQ0hBUlM6L15bXkAhW1xcXS4sJCorP157fSgpfFxcXFwvXSsvLFJFR0VYX1NQRUNJQUxfQ0hBUlM6L1stKis/Ll4ke30ofClbXFxdXS8sUkVHRVhfU1BFQ0lBTF9DSEFSU19CQUNLUkVGOi8oXFxcXD8pKChcXFcpKFxcMyopKS9nLFJFR0VYX1NQRUNJQUxfQ0hBUlNfR0xPQkFMOi8oWy0qKz8uXiR7fSh8KVtcXF1dKS9nLFJFR0VYX1JFTU9WRV9CQUNLU0xBU0g6Lyg/OlxcWy4qP1teXFxcXF1cXF18XFxcXCg/PS4pKS9nLFJFUExBQ0VNRU5UUzp7XCIqKipcIjpcIipcIixcIioqLyoqXCI6XCIqKlwiLFwiKiovKiovKipcIjpcIioqXCJ9LENIQVJfMDo0OCxDSEFSXzk6NTcsQ0hBUl9VUFBFUkNBU0VfQTo2NSxDSEFSX0xPV0VSQ0FTRV9BOjk3LENIQVJfVVBQRVJDQVNFX1o6OTAsQ0hBUl9MT1dFUkNBU0VfWjoxMjIsQ0hBUl9MRUZUX1BBUkVOVEhFU0VTOjQwLENIQVJfUklHSFRfUEFSRU5USEVTRVM6NDEsQ0hBUl9BU1RFUklTSzo0MixDSEFSX0FNUEVSU0FORDozOCxDSEFSX0FUOjY0LENIQVJfQkFDS1dBUkRfU0xBU0g6OTIsQ0hBUl9DQVJSSUFHRV9SRVRVUk46MTMsQ0hBUl9DSVJDVU1GTEVYX0FDQ0VOVDo5NCxDSEFSX0NPTE9OOjU4LENIQVJfQ09NTUE6NDQsQ0hBUl9ET1Q6NDYsQ0hBUl9ET1VCTEVfUVVPVEU6MzQsQ0hBUl9FUVVBTDo2MSxDSEFSX0VYQ0xBTUFUSU9OX01BUks6MzMsQ0hBUl9GT1JNX0ZFRUQ6MTIsQ0hBUl9GT1JXQVJEX1NMQVNIOjQ3LENIQVJfR1JBVkVfQUNDRU5UOjk2LENIQVJfSEFTSDozNSxDSEFSX0hZUEhFTl9NSU5VUzo0NSxDSEFSX0xFRlRfQU5HTEVfQlJBQ0tFVDo2MCxDSEFSX0xFRlRfQ1VSTFlfQlJBQ0U6MTIzLENIQVJfTEVGVF9TUVVBUkVfQlJBQ0tFVDo5MSxDSEFSX0xJTkVfRkVFRDoxMCxDSEFSX05PX0JSRUFLX1NQQUNFOjE2MCxDSEFSX1BFUkNFTlQ6MzcsQ0hBUl9QTFVTOjQzLENIQVJfUVVFU1RJT05fTUFSSzo2MyxDSEFSX1JJR0hUX0FOR0xFX0JSQUNLRVQ6NjIsQ0hBUl9SSUdIVF9DVVJMWV9CUkFDRToxMjUsQ0hBUl9SSUdIVF9TUVVBUkVfQlJBQ0tFVDo5MyxDSEFSX1NFTUlDT0xPTjo1OSxDSEFSX1NJTkdMRV9RVU9URTozOSxDSEFSX1NQQUNFOjMyLENIQVJfVEFCOjksQ0hBUl9VTkRFUlNDT1JFOjk1LENIQVJfVkVSVElDQUxfTElORToxMjQsQ0hBUl9aRVJPX1dJRFRIX05PQlJFQUtfU1BBQ0U6NjUyNzksZXh0Z2xvYkNoYXJzKHQpe3JldHVybntcIiFcIjp7dHlwZTpcIm5lZ2F0ZVwiLG9wZW46XCIoPzooPyEoPzpcIixjbG9zZTpgKSkke3QuU1RBUn0pYH0sXCI/XCI6e3R5cGU6XCJxbWFya1wiLG9wZW46XCIoPzpcIixjbG9zZTpcIik/XCJ9LFwiK1wiOnt0eXBlOlwicGx1c1wiLG9wZW46XCIoPzpcIixjbG9zZTpcIikrXCJ9LFwiKlwiOnt0eXBlOlwic3RhclwiLG9wZW46XCIoPzpcIixjbG9zZTpcIikqXCJ9LFwiQFwiOnt0eXBlOlwiYXRcIixvcGVuOlwiKD86XCIsY2xvc2U6XCIpXCJ9fX0sZ2xvYkNoYXJzKHQpe3JldHVybiB0PT09dHJ1ZT9DOmJ9fX0sNjk3Oih0LGUsdSk9Pntjb25zdCBuPXUoMTU0KTtjb25zdCBvPXUoOTYpO2NvbnN0e01BWF9MRU5HVEg6cyxQT1NJWF9SRUdFWF9TT1VSQ0U6cixSRUdFWF9OT05fU1BFQ0lBTF9DSEFSUzphLFJFR0VYX1NQRUNJQUxfQ0hBUlNfQkFDS1JFRjppLFJFUExBQ0VNRU5UUzpjfT1uO2NvbnN0IGV4cGFuZFJhbmdlPSh0LGUpPT57aWYodHlwZW9mIGUuZXhwYW5kUmFuZ2U9PT1cImZ1bmN0aW9uXCIpe3JldHVybiBlLmV4cGFuZFJhbmdlKC4uLnQsZSl9dC5zb3J0KCk7Y29uc3QgdT1gWyR7dC5qb2luKFwiLVwiKX1dYDt0cnl7bmV3IFJlZ0V4cCh1KX1jYXRjaChlKXtyZXR1cm4gdC5tYXAoKHQ9Pm8uZXNjYXBlUmVnZXgodCkpKS5qb2luKFwiLi5cIil9cmV0dXJuIHV9O2NvbnN0IHN5bnRheEVycm9yPSh0LGUpPT5gTWlzc2luZyAke3R9OiBcIiR7ZX1cIiAtIHVzZSBcIlxcXFxcXFxcJHtlfVwiIHRvIG1hdGNoIGxpdGVyYWwgY2hhcmFjdGVyc2A7Y29uc3QgcGFyc2U9KHQsZSk9PntpZih0eXBlb2YgdCE9PVwic3RyaW5nXCIpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBhIHN0cmluZ1wiKX10PWNbdF18fHQ7Y29uc3QgdT17Li4uZX07Y29uc3QgcD10eXBlb2YgdS5tYXhMZW5ndGg9PT1cIm51bWJlclwiP01hdGgubWluKHMsdS5tYXhMZW5ndGgpOnM7bGV0IGw9dC5sZW5ndGg7aWYobD5wKXt0aHJvdyBuZXcgU3ludGF4RXJyb3IoYElucHV0IGxlbmd0aDogJHtsfSwgZXhjZWVkcyBtYXhpbXVtIGFsbG93ZWQgbGVuZ3RoOiAke3B9YCl9Y29uc3QgZj17dHlwZTpcImJvc1wiLHZhbHVlOlwiXCIsb3V0cHV0OnUucHJlcGVuZHx8XCJcIn07Y29uc3QgQT1bZl07Y29uc3QgXz11LmNhcHR1cmU/XCJcIjpcIj86XCI7Y29uc3QgUj1uLmdsb2JDaGFycyh1LndpbmRvd3MpO2NvbnN0IEU9bi5leHRnbG9iQ2hhcnMoUik7Y29uc3R7RE9UX0xJVEVSQUw6aCxQTFVTX0xJVEVSQUw6ZyxTTEFTSF9MSVRFUkFMOmIsT05FX0NIQVI6QyxET1RTX1NMQVNIOnksTk9fRE9UOiQsTk9fRE9UX1NMQVNIOngsTk9fRE9UU19TTEFTSDpTLFFNQVJLOkgsUU1BUktfTk9fRE9UOnYsU1RBUjpkLFNUQVJUX0FOQ0hPUjpMfT1SO2NvbnN0IGdsb2JzdGFyPXQ9PmAoJHtffSg/Oig/ISR7TH0ke3QuZG90P3k6aH0pLikqPylgO2NvbnN0IFQ9dS5kb3Q/XCJcIjokO2NvbnN0IE89dS5kb3Q/SDp2O2xldCBrPXUuYmFzaD09PXRydWU/Z2xvYnN0YXIodSk6ZDtpZih1LmNhcHR1cmUpe2s9YCgke2t9KWB9aWYodHlwZW9mIHUubm9leHQ9PT1cImJvb2xlYW5cIil7dS5ub2V4dGdsb2I9dS5ub2V4dH1jb25zdCBtPXtpbnB1dDp0LGluZGV4Oi0xLHN0YXJ0OjAsZG90OnUuZG90PT09dHJ1ZSxjb25zdW1lZDpcIlwiLG91dHB1dDpcIlwiLHByZWZpeDpcIlwiLGJhY2t0cmFjazpmYWxzZSxuZWdhdGVkOmZhbHNlLGJyYWNrZXRzOjAsYnJhY2VzOjAscGFyZW5zOjAscXVvdGVzOjAsZ2xvYnN0YXI6ZmFsc2UsdG9rZW5zOkF9O3Q9by5yZW1vdmVQcmVmaXgodCxtKTtsPXQubGVuZ3RoO2NvbnN0IHc9W107Y29uc3QgTj1bXTtjb25zdCBJPVtdO2xldCBCPWY7bGV0IEc7Y29uc3QgZW9zPSgpPT5tLmluZGV4PT09bC0xO2NvbnN0IEQ9bS5wZWVrPShlPTEpPT50W20uaW5kZXgrZV07Y29uc3QgTT1tLmFkdmFuY2U9KCk9PnRbKyttLmluZGV4XXx8XCJcIjtjb25zdCByZW1haW5pbmc9KCk9PnQuc2xpY2UobS5pbmRleCsxKTtjb25zdCBjb25zdW1lPSh0PVwiXCIsZT0wKT0+e20uY29uc3VtZWQrPXQ7bS5pbmRleCs9ZX07Y29uc3QgYXBwZW5kPXQ9PnttLm91dHB1dCs9dC5vdXRwdXQhPW51bGw/dC5vdXRwdXQ6dC52YWx1ZTtjb25zdW1lKHQudmFsdWUpfTtjb25zdCBuZWdhdGU9KCk9PntsZXQgdD0xO3doaWxlKEQoKT09PVwiIVwiJiYoRCgyKSE9PVwiKFwifHxEKDMpPT09XCI/XCIpKXtNKCk7bS5zdGFydCsrO3QrK31pZih0JTI9PT0wKXtyZXR1cm4gZmFsc2V9bS5uZWdhdGVkPXRydWU7bS5zdGFydCsrO3JldHVybiB0cnVlfTtjb25zdCBpbmNyZW1lbnQ9dD0+e21bdF0rKztJLnB1c2godCl9O2NvbnN0IGRlY3JlbWVudD10PT57bVt0XS0tO0kucG9wKCl9O2NvbnN0IHB1c2g9dD0+e2lmKEIudHlwZT09PVwiZ2xvYnN0YXJcIil7Y29uc3QgZT1tLmJyYWNlcz4wJiYodC50eXBlPT09XCJjb21tYVwifHx0LnR5cGU9PT1cImJyYWNlXCIpO2NvbnN0IHU9dC5leHRnbG9iPT09dHJ1ZXx8dy5sZW5ndGgmJih0LnR5cGU9PT1cInBpcGVcInx8dC50eXBlPT09XCJwYXJlblwiKTtpZih0LnR5cGUhPT1cInNsYXNoXCImJnQudHlwZSE9PVwicGFyZW5cIiYmIWUmJiF1KXttLm91dHB1dD1tLm91dHB1dC5zbGljZSgwLC1CLm91dHB1dC5sZW5ndGgpO0IudHlwZT1cInN0YXJcIjtCLnZhbHVlPVwiKlwiO0Iub3V0cHV0PWs7bS5vdXRwdXQrPUIub3V0cHV0fX1pZih3Lmxlbmd0aCYmdC50eXBlIT09XCJwYXJlblwiKXt3W3cubGVuZ3RoLTFdLmlubmVyKz10LnZhbHVlfWlmKHQudmFsdWV8fHQub3V0cHV0KWFwcGVuZCh0KTtpZihCJiZCLnR5cGU9PT1cInRleHRcIiYmdC50eXBlPT09XCJ0ZXh0XCIpe0Iub3V0cHV0PShCLm91dHB1dHx8Qi52YWx1ZSkrdC52YWx1ZTtCLnZhbHVlKz10LnZhbHVlO3JldHVybn10LnByZXY9QjtBLnB1c2godCk7Qj10fTtjb25zdCBleHRnbG9iT3Blbj0odCxlKT0+e2NvbnN0IG49ey4uLkVbZV0sY29uZGl0aW9uczoxLGlubmVyOlwiXCJ9O24ucHJldj1CO24ucGFyZW5zPW0ucGFyZW5zO24ub3V0cHV0PW0ub3V0cHV0O2NvbnN0IG89KHUuY2FwdHVyZT9cIihcIjpcIlwiKStuLm9wZW47aW5jcmVtZW50KFwicGFyZW5zXCIpO3B1c2goe3R5cGU6dCx2YWx1ZTplLG91dHB1dDptLm91dHB1dD9cIlwiOkN9KTtwdXNoKHt0eXBlOlwicGFyZW5cIixleHRnbG9iOnRydWUsdmFsdWU6TSgpLG91dHB1dDpvfSk7dy5wdXNoKG4pfTtjb25zdCBleHRnbG9iQ2xvc2U9dD0+e2xldCBuPXQuY2xvc2UrKHUuY2FwdHVyZT9cIilcIjpcIlwiKTtsZXQgbztpZih0LnR5cGU9PT1cIm5lZ2F0ZVwiKXtsZXQgcz1rO2lmKHQuaW5uZXImJnQuaW5uZXIubGVuZ3RoPjEmJnQuaW5uZXIuaW5jbHVkZXMoXCIvXCIpKXtzPWdsb2JzdGFyKHUpfWlmKHMhPT1rfHxlb3MoKXx8L15cXCkrJC8udGVzdChyZW1haW5pbmcoKSkpe249dC5jbG9zZT1gKSQpKSR7c31gfWlmKHQuaW5uZXIuaW5jbHVkZXMoXCIqXCIpJiYobz1yZW1haW5pbmcoKSkmJi9eXFwuW15cXFxcLy5dKyQvLnRlc3Qobykpe2NvbnN0IHU9cGFyc2Uobyx7Li4uZSxmYXN0cGF0aHM6ZmFsc2V9KS5vdXRwdXQ7bj10LmNsb3NlPWApJHt1fSkke3N9KWB9aWYodC5wcmV2LnR5cGU9PT1cImJvc1wiKXttLm5lZ2F0ZWRFeHRnbG9iPXRydWV9fXB1c2goe3R5cGU6XCJwYXJlblwiLGV4dGdsb2I6dHJ1ZSx2YWx1ZTpHLG91dHB1dDpufSk7ZGVjcmVtZW50KFwicGFyZW5zXCIpfTtpZih1LmZhc3RwYXRocyE9PWZhbHNlJiYhLyheWyohXXxbLygpW1xcXXt9XCJdKS8udGVzdCh0KSl7bGV0IG49ZmFsc2U7bGV0IHM9dC5yZXBsYWNlKGksKCh0LGUsdSxvLHMscik9PntpZihvPT09XCJcXFxcXCIpe249dHJ1ZTtyZXR1cm4gdH1pZihvPT09XCI/XCIpe2lmKGUpe3JldHVybiBlK28rKHM/SC5yZXBlYXQocy5sZW5ndGgpOlwiXCIpfWlmKHI9PT0wKXtyZXR1cm4gTysocz9ILnJlcGVhdChzLmxlbmd0aCk6XCJcIil9cmV0dXJuIEgucmVwZWF0KHUubGVuZ3RoKX1pZihvPT09XCIuXCIpe3JldHVybiBoLnJlcGVhdCh1Lmxlbmd0aCl9aWYobz09PVwiKlwiKXtpZihlKXtyZXR1cm4gZStvKyhzP2s6XCJcIil9cmV0dXJuIGt9cmV0dXJuIGU/dDpgXFxcXCR7dH1gfSkpO2lmKG49PT10cnVlKXtpZih1LnVuZXNjYXBlPT09dHJ1ZSl7cz1zLnJlcGxhY2UoL1xcXFwvZyxcIlwiKX1lbHNle3M9cy5yZXBsYWNlKC9cXFxcKy9nLCh0PT50Lmxlbmd0aCUyPT09MD9cIlxcXFxcXFxcXCI6dD9cIlxcXFxcIjpcIlwiKSl9fWlmKHM9PT10JiZ1LmNvbnRhaW5zPT09dHJ1ZSl7bS5vdXRwdXQ9dDtyZXR1cm4gbX1tLm91dHB1dD1vLndyYXBPdXRwdXQocyxtLGUpO3JldHVybiBtfXdoaWxlKCFlb3MoKSl7Rz1NKCk7aWYoRz09PVwiXFwwXCIpe2NvbnRpbnVlfWlmKEc9PT1cIlxcXFxcIil7Y29uc3QgdD1EKCk7aWYodD09PVwiL1wiJiZ1LmJhc2ghPT10cnVlKXtjb250aW51ZX1pZih0PT09XCIuXCJ8fHQ9PT1cIjtcIil7Y29udGludWV9aWYoIXQpe0crPVwiXFxcXFwiO3B1c2goe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6R30pO2NvbnRpbnVlfWNvbnN0IGU9L15cXFxcKy8uZXhlYyhyZW1haW5pbmcoKSk7bGV0IG49MDtpZihlJiZlWzBdLmxlbmd0aD4yKXtuPWVbMF0ubGVuZ3RoO20uaW5kZXgrPW47aWYobiUyIT09MCl7Rys9XCJcXFxcXCJ9fWlmKHUudW5lc2NhcGU9PT10cnVlKXtHPU0oKX1lbHNle0crPU0oKX1pZihtLmJyYWNrZXRzPT09MCl7cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTpHfSk7Y29udGludWV9fWlmKG0uYnJhY2tldHM+MCYmKEchPT1cIl1cInx8Qi52YWx1ZT09PVwiW1wifHxCLnZhbHVlPT09XCJbXlwiKSl7aWYodS5wb3NpeCE9PWZhbHNlJiZHPT09XCI6XCIpe2NvbnN0IHQ9Qi52YWx1ZS5zbGljZSgxKTtpZih0LmluY2x1ZGVzKFwiW1wiKSl7Qi5wb3NpeD10cnVlO2lmKHQuaW5jbHVkZXMoXCI6XCIpKXtjb25zdCB0PUIudmFsdWUubGFzdEluZGV4T2YoXCJbXCIpO2NvbnN0IGU9Qi52YWx1ZS5zbGljZSgwLHQpO2NvbnN0IHU9Qi52YWx1ZS5zbGljZSh0KzIpO2NvbnN0IG49clt1XTtpZihuKXtCLnZhbHVlPWUrbjttLmJhY2t0cmFjaz10cnVlO00oKTtpZighZi5vdXRwdXQmJkEuaW5kZXhPZihCKT09PTEpe2Yub3V0cHV0PUN9Y29udGludWV9fX19aWYoRz09PVwiW1wiJiZEKCkhPT1cIjpcInx8Rz09PVwiLVwiJiZEKCk9PT1cIl1cIil7Rz1gXFxcXCR7R31gfWlmKEc9PT1cIl1cIiYmKEIudmFsdWU9PT1cIltcInx8Qi52YWx1ZT09PVwiW15cIikpe0c9YFxcXFwke0d9YH1pZih1LnBvc2l4PT09dHJ1ZSYmRz09PVwiIVwiJiZCLnZhbHVlPT09XCJbXCIpe0c9XCJeXCJ9Qi52YWx1ZSs9RzthcHBlbmQoe3ZhbHVlOkd9KTtjb250aW51ZX1pZihtLnF1b3Rlcz09PTEmJkchPT0nXCInKXtHPW8uZXNjYXBlUmVnZXgoRyk7Qi52YWx1ZSs9RzthcHBlbmQoe3ZhbHVlOkd9KTtjb250aW51ZX1pZihHPT09J1wiJyl7bS5xdW90ZXM9bS5xdW90ZXM9PT0xPzA6MTtpZih1LmtlZXBRdW90ZXM9PT10cnVlKXtwdXNoKHt0eXBlOlwidGV4dFwiLHZhbHVlOkd9KX1jb250aW51ZX1pZihHPT09XCIoXCIpe2luY3JlbWVudChcInBhcmVuc1wiKTtwdXNoKHt0eXBlOlwicGFyZW5cIix2YWx1ZTpHfSk7Y29udGludWV9aWYoRz09PVwiKVwiKXtpZihtLnBhcmVucz09PTAmJnUuc3RyaWN0QnJhY2tldHM9PT10cnVlKXt0aHJvdyBuZXcgU3ludGF4RXJyb3Ioc3ludGF4RXJyb3IoXCJvcGVuaW5nXCIsXCIoXCIpKX1jb25zdCB0PXdbdy5sZW5ndGgtMV07aWYodCYmbS5wYXJlbnM9PT10LnBhcmVucysxKXtleHRnbG9iQ2xvc2Uody5wb3AoKSk7Y29udGludWV9cHVzaCh7dHlwZTpcInBhcmVuXCIsdmFsdWU6RyxvdXRwdXQ6bS5wYXJlbnM/XCIpXCI6XCJcXFxcKVwifSk7ZGVjcmVtZW50KFwicGFyZW5zXCIpO2NvbnRpbnVlfWlmKEc9PT1cIltcIil7aWYodS5ub2JyYWNrZXQ9PT10cnVlfHwhcmVtYWluaW5nKCkuaW5jbHVkZXMoXCJdXCIpKXtpZih1Lm5vYnJhY2tldCE9PXRydWUmJnUuc3RyaWN0QnJhY2tldHM9PT10cnVlKXt0aHJvdyBuZXcgU3ludGF4RXJyb3Ioc3ludGF4RXJyb3IoXCJjbG9zaW5nXCIsXCJdXCIpKX1HPWBcXFxcJHtHfWB9ZWxzZXtpbmNyZW1lbnQoXCJicmFja2V0c1wiKX1wdXNoKHt0eXBlOlwiYnJhY2tldFwiLHZhbHVlOkd9KTtjb250aW51ZX1pZihHPT09XCJdXCIpe2lmKHUubm9icmFja2V0PT09dHJ1ZXx8QiYmQi50eXBlPT09XCJicmFja2V0XCImJkIudmFsdWUubGVuZ3RoPT09MSl7cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTpHLG91dHB1dDpgXFxcXCR7R31gfSk7Y29udGludWV9aWYobS5icmFja2V0cz09PTApe2lmKHUuc3RyaWN0QnJhY2tldHM9PT10cnVlKXt0aHJvdyBuZXcgU3ludGF4RXJyb3Ioc3ludGF4RXJyb3IoXCJvcGVuaW5nXCIsXCJbXCIpKX1wdXNoKHt0eXBlOlwidGV4dFwiLHZhbHVlOkcsb3V0cHV0OmBcXFxcJHtHfWB9KTtjb250aW51ZX1kZWNyZW1lbnQoXCJicmFja2V0c1wiKTtjb25zdCB0PUIudmFsdWUuc2xpY2UoMSk7aWYoQi5wb3NpeCE9PXRydWUmJnRbMF09PT1cIl5cIiYmIXQuaW5jbHVkZXMoXCIvXCIpKXtHPWAvJHtHfWB9Qi52YWx1ZSs9RzthcHBlbmQoe3ZhbHVlOkd9KTtpZih1LmxpdGVyYWxCcmFja2V0cz09PWZhbHNlfHxvLmhhc1JlZ2V4Q2hhcnModCkpe2NvbnRpbnVlfWNvbnN0IGU9by5lc2NhcGVSZWdleChCLnZhbHVlKTttLm91dHB1dD1tLm91dHB1dC5zbGljZSgwLC1CLnZhbHVlLmxlbmd0aCk7aWYodS5saXRlcmFsQnJhY2tldHM9PT10cnVlKXttLm91dHB1dCs9ZTtCLnZhbHVlPWU7Y29udGludWV9Qi52YWx1ZT1gKCR7X30ke2V9fCR7Qi52YWx1ZX0pYDttLm91dHB1dCs9Qi52YWx1ZTtjb250aW51ZX1pZihHPT09XCJ7XCImJnUubm9icmFjZSE9PXRydWUpe2luY3JlbWVudChcImJyYWNlc1wiKTtjb25zdCB0PXt0eXBlOlwiYnJhY2VcIix2YWx1ZTpHLG91dHB1dDpcIihcIixvdXRwdXRJbmRleDptLm91dHB1dC5sZW5ndGgsdG9rZW5zSW5kZXg6bS50b2tlbnMubGVuZ3RofTtOLnB1c2godCk7cHVzaCh0KTtjb250aW51ZX1pZihHPT09XCJ9XCIpe2NvbnN0IHQ9TltOLmxlbmd0aC0xXTtpZih1Lm5vYnJhY2U9PT10cnVlfHwhdCl7cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTpHLG91dHB1dDpHfSk7Y29udGludWV9bGV0IGU9XCIpXCI7aWYodC5kb3RzPT09dHJ1ZSl7Y29uc3QgdD1BLnNsaWNlKCk7Y29uc3Qgbj1bXTtmb3IobGV0IGU9dC5sZW5ndGgtMTtlPj0wO2UtLSl7QS5wb3AoKTtpZih0W2VdLnR5cGU9PT1cImJyYWNlXCIpe2JyZWFrfWlmKHRbZV0udHlwZSE9PVwiZG90c1wiKXtuLnVuc2hpZnQodFtlXS52YWx1ZSl9fWU9ZXhwYW5kUmFuZ2Uobix1KTttLmJhY2t0cmFjaz10cnVlfWlmKHQuY29tbWEhPT10cnVlJiZ0LmRvdHMhPT10cnVlKXtjb25zdCB1PW0ub3V0cHV0LnNsaWNlKDAsdC5vdXRwdXRJbmRleCk7Y29uc3Qgbj1tLnRva2Vucy5zbGljZSh0LnRva2Vuc0luZGV4KTt0LnZhbHVlPXQub3V0cHV0PVwiXFxcXHtcIjtHPWU9XCJcXFxcfVwiO20ub3V0cHV0PXU7Zm9yKGNvbnN0IHQgb2Ygbil7bS5vdXRwdXQrPXQub3V0cHV0fHx0LnZhbHVlfX1wdXNoKHt0eXBlOlwiYnJhY2VcIix2YWx1ZTpHLG91dHB1dDplfSk7ZGVjcmVtZW50KFwiYnJhY2VzXCIpO04ucG9wKCk7Y29udGludWV9aWYoRz09PVwifFwiKXtpZih3Lmxlbmd0aD4wKXt3W3cubGVuZ3RoLTFdLmNvbmRpdGlvbnMrK31wdXNoKHt0eXBlOlwidGV4dFwiLHZhbHVlOkd9KTtjb250aW51ZX1pZihHPT09XCIsXCIpe2xldCB0PUc7Y29uc3QgZT1OW04ubGVuZ3RoLTFdO2lmKGUmJklbSS5sZW5ndGgtMV09PT1cImJyYWNlc1wiKXtlLmNvbW1hPXRydWU7dD1cInxcIn1wdXNoKHt0eXBlOlwiY29tbWFcIix2YWx1ZTpHLG91dHB1dDp0fSk7Y29udGludWV9aWYoRz09PVwiL1wiKXtpZihCLnR5cGU9PT1cImRvdFwiJiZtLmluZGV4PT09bS5zdGFydCsxKXttLnN0YXJ0PW0uaW5kZXgrMTttLmNvbnN1bWVkPVwiXCI7bS5vdXRwdXQ9XCJcIjtBLnBvcCgpO0I9Zjtjb250aW51ZX1wdXNoKHt0eXBlOlwic2xhc2hcIix2YWx1ZTpHLG91dHB1dDpifSk7Y29udGludWV9aWYoRz09PVwiLlwiKXtpZihtLmJyYWNlcz4wJiZCLnR5cGU9PT1cImRvdFwiKXtpZihCLnZhbHVlPT09XCIuXCIpQi5vdXRwdXQ9aDtjb25zdCB0PU5bTi5sZW5ndGgtMV07Qi50eXBlPVwiZG90c1wiO0Iub3V0cHV0Kz1HO0IudmFsdWUrPUc7dC5kb3RzPXRydWU7Y29udGludWV9aWYobS5icmFjZXMrbS5wYXJlbnM9PT0wJiZCLnR5cGUhPT1cImJvc1wiJiZCLnR5cGUhPT1cInNsYXNoXCIpe3B1c2goe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6RyxvdXRwdXQ6aH0pO2NvbnRpbnVlfXB1c2goe3R5cGU6XCJkb3RcIix2YWx1ZTpHLG91dHB1dDpofSk7Y29udGludWV9aWYoRz09PVwiP1wiKXtjb25zdCB0PUImJkIudmFsdWU9PT1cIihcIjtpZighdCYmdS5ub2V4dGdsb2IhPT10cnVlJiZEKCk9PT1cIihcIiYmRCgyKSE9PVwiP1wiKXtleHRnbG9iT3BlbihcInFtYXJrXCIsRyk7Y29udGludWV9aWYoQiYmQi50eXBlPT09XCJwYXJlblwiKXtjb25zdCB0PUQoKTtsZXQgZT1HO2lmKEIudmFsdWU9PT1cIihcIiYmIS9bIT08Ol0vLnRlc3QodCl8fHQ9PT1cIjxcIiYmIS88KFshPV18XFx3Kz4pLy50ZXN0KHJlbWFpbmluZygpKSl7ZT1gXFxcXCR7R31gfXB1c2goe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6RyxvdXRwdXQ6ZX0pO2NvbnRpbnVlfWlmKHUuZG90IT09dHJ1ZSYmKEIudHlwZT09PVwic2xhc2hcInx8Qi50eXBlPT09XCJib3NcIikpe3B1c2goe3R5cGU6XCJxbWFya1wiLHZhbHVlOkcsb3V0cHV0OnZ9KTtjb250aW51ZX1wdXNoKHt0eXBlOlwicW1hcmtcIix2YWx1ZTpHLG91dHB1dDpIfSk7Y29udGludWV9aWYoRz09PVwiIVwiKXtpZih1Lm5vZXh0Z2xvYiE9PXRydWUmJkQoKT09PVwiKFwiKXtpZihEKDIpIT09XCI/XCJ8fCEvWyE9PDpdLy50ZXN0KEQoMykpKXtleHRnbG9iT3BlbihcIm5lZ2F0ZVwiLEcpO2NvbnRpbnVlfX1pZih1Lm5vbmVnYXRlIT09dHJ1ZSYmbS5pbmRleD09PTApe25lZ2F0ZSgpO2NvbnRpbnVlfX1pZihHPT09XCIrXCIpe2lmKHUubm9leHRnbG9iIT09dHJ1ZSYmRCgpPT09XCIoXCImJkQoMikhPT1cIj9cIil7ZXh0Z2xvYk9wZW4oXCJwbHVzXCIsRyk7Y29udGludWV9aWYoQiYmQi52YWx1ZT09PVwiKFwifHx1LnJlZ2V4PT09ZmFsc2Upe3B1c2goe3R5cGU6XCJwbHVzXCIsdmFsdWU6RyxvdXRwdXQ6Z30pO2NvbnRpbnVlfWlmKEImJihCLnR5cGU9PT1cImJyYWNrZXRcInx8Qi50eXBlPT09XCJwYXJlblwifHxCLnR5cGU9PT1cImJyYWNlXCIpfHxtLnBhcmVucz4wKXtwdXNoKHt0eXBlOlwicGx1c1wiLHZhbHVlOkd9KTtjb250aW51ZX1wdXNoKHt0eXBlOlwicGx1c1wiLHZhbHVlOmd9KTtjb250aW51ZX1pZihHPT09XCJAXCIpe2lmKHUubm9leHRnbG9iIT09dHJ1ZSYmRCgpPT09XCIoXCImJkQoMikhPT1cIj9cIil7cHVzaCh7dHlwZTpcImF0XCIsZXh0Z2xvYjp0cnVlLHZhbHVlOkcsb3V0cHV0OlwiXCJ9KTtjb250aW51ZX1wdXNoKHt0eXBlOlwidGV4dFwiLHZhbHVlOkd9KTtjb250aW51ZX1pZihHIT09XCIqXCIpe2lmKEc9PT1cIiRcInx8Rz09PVwiXlwiKXtHPWBcXFxcJHtHfWB9Y29uc3QgdD1hLmV4ZWMocmVtYWluaW5nKCkpO2lmKHQpe0crPXRbMF07bS5pbmRleCs9dFswXS5sZW5ndGh9cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTpHfSk7Y29udGludWV9aWYoQiYmKEIudHlwZT09PVwiZ2xvYnN0YXJcInx8Qi5zdGFyPT09dHJ1ZSkpe0IudHlwZT1cInN0YXJcIjtCLnN0YXI9dHJ1ZTtCLnZhbHVlKz1HO0Iub3V0cHV0PWs7bS5iYWNrdHJhY2s9dHJ1ZTttLmdsb2JzdGFyPXRydWU7Y29uc3VtZShHKTtjb250aW51ZX1sZXQgZT1yZW1haW5pbmcoKTtpZih1Lm5vZXh0Z2xvYiE9PXRydWUmJi9eXFwoW14/XS8udGVzdChlKSl7ZXh0Z2xvYk9wZW4oXCJzdGFyXCIsRyk7Y29udGludWV9aWYoQi50eXBlPT09XCJzdGFyXCIpe2lmKHUubm9nbG9ic3Rhcj09PXRydWUpe2NvbnN1bWUoRyk7Y29udGludWV9Y29uc3Qgbj1CLnByZXY7Y29uc3Qgbz1uLnByZXY7Y29uc3Qgcz1uLnR5cGU9PT1cInNsYXNoXCJ8fG4udHlwZT09PVwiYm9zXCI7Y29uc3Qgcj1vJiYoby50eXBlPT09XCJzdGFyXCJ8fG8udHlwZT09PVwiZ2xvYnN0YXJcIik7aWYodS5iYXNoPT09dHJ1ZSYmKCFzfHxlWzBdJiZlWzBdIT09XCIvXCIpKXtwdXNoKHt0eXBlOlwic3RhclwiLHZhbHVlOkcsb3V0cHV0OlwiXCJ9KTtjb250aW51ZX1jb25zdCBhPW0uYnJhY2VzPjAmJihuLnR5cGU9PT1cImNvbW1hXCJ8fG4udHlwZT09PVwiYnJhY2VcIik7Y29uc3QgaT13Lmxlbmd0aCYmKG4udHlwZT09PVwicGlwZVwifHxuLnR5cGU9PT1cInBhcmVuXCIpO2lmKCFzJiZuLnR5cGUhPT1cInBhcmVuXCImJiFhJiYhaSl7cHVzaCh7dHlwZTpcInN0YXJcIix2YWx1ZTpHLG91dHB1dDpcIlwifSk7Y29udGludWV9d2hpbGUoZS5zbGljZSgwLDMpPT09XCIvKipcIil7Y29uc3QgdT10W20uaW5kZXgrNF07aWYodSYmdSE9PVwiL1wiKXticmVha31lPWUuc2xpY2UoMyk7Y29uc3VtZShcIi8qKlwiLDMpfWlmKG4udHlwZT09PVwiYm9zXCImJmVvcygpKXtCLnR5cGU9XCJnbG9ic3RhclwiO0IudmFsdWUrPUc7Qi5vdXRwdXQ9Z2xvYnN0YXIodSk7bS5vdXRwdXQ9Qi5vdXRwdXQ7bS5nbG9ic3Rhcj10cnVlO2NvbnN1bWUoRyk7Y29udGludWV9aWYobi50eXBlPT09XCJzbGFzaFwiJiZuLnByZXYudHlwZSE9PVwiYm9zXCImJiFyJiZlb3MoKSl7bS5vdXRwdXQ9bS5vdXRwdXQuc2xpY2UoMCwtKG4ub3V0cHV0K0Iub3V0cHV0KS5sZW5ndGgpO24ub3V0cHV0PWAoPzoke24ub3V0cHV0fWA7Qi50eXBlPVwiZ2xvYnN0YXJcIjtCLm91dHB1dD1nbG9ic3Rhcih1KSsodS5zdHJpY3RTbGFzaGVzP1wiKVwiOlwifCQpXCIpO0IudmFsdWUrPUc7bS5nbG9ic3Rhcj10cnVlO20ub3V0cHV0Kz1uLm91dHB1dCtCLm91dHB1dDtjb25zdW1lKEcpO2NvbnRpbnVlfWlmKG4udHlwZT09PVwic2xhc2hcIiYmbi5wcmV2LnR5cGUhPT1cImJvc1wiJiZlWzBdPT09XCIvXCIpe2NvbnN0IHQ9ZVsxXSE9PXZvaWQgMD9cInwkXCI6XCJcIjttLm91dHB1dD1tLm91dHB1dC5zbGljZSgwLC0obi5vdXRwdXQrQi5vdXRwdXQpLmxlbmd0aCk7bi5vdXRwdXQ9YCg/OiR7bi5vdXRwdXR9YDtCLnR5cGU9XCJnbG9ic3RhclwiO0Iub3V0cHV0PWAke2dsb2JzdGFyKHUpfSR7Yn18JHtifSR7dH0pYDtCLnZhbHVlKz1HO20ub3V0cHV0Kz1uLm91dHB1dCtCLm91dHB1dDttLmdsb2JzdGFyPXRydWU7Y29uc3VtZShHK00oKSk7cHVzaCh7dHlwZTpcInNsYXNoXCIsdmFsdWU6XCIvXCIsb3V0cHV0OlwiXCJ9KTtjb250aW51ZX1pZihuLnR5cGU9PT1cImJvc1wiJiZlWzBdPT09XCIvXCIpe0IudHlwZT1cImdsb2JzdGFyXCI7Qi52YWx1ZSs9RztCLm91dHB1dD1gKD86Xnwke2J9fCR7Z2xvYnN0YXIodSl9JHtifSlgO20ub3V0cHV0PUIub3V0cHV0O20uZ2xvYnN0YXI9dHJ1ZTtjb25zdW1lKEcrTSgpKTtwdXNoKHt0eXBlOlwic2xhc2hcIix2YWx1ZTpcIi9cIixvdXRwdXQ6XCJcIn0pO2NvbnRpbnVlfW0ub3V0cHV0PW0ub3V0cHV0LnNsaWNlKDAsLUIub3V0cHV0Lmxlbmd0aCk7Qi50eXBlPVwiZ2xvYnN0YXJcIjtCLm91dHB1dD1nbG9ic3Rhcih1KTtCLnZhbHVlKz1HO20ub3V0cHV0Kz1CLm91dHB1dDttLmdsb2JzdGFyPXRydWU7Y29uc3VtZShHKTtjb250aW51ZX1jb25zdCBuPXt0eXBlOlwic3RhclwiLHZhbHVlOkcsb3V0cHV0Omt9O2lmKHUuYmFzaD09PXRydWUpe24ub3V0cHV0PVwiLio/XCI7aWYoQi50eXBlPT09XCJib3NcInx8Qi50eXBlPT09XCJzbGFzaFwiKXtuLm91dHB1dD1UK24ub3V0cHV0fXB1c2gobik7Y29udGludWV9aWYoQiYmKEIudHlwZT09PVwiYnJhY2tldFwifHxCLnR5cGU9PT1cInBhcmVuXCIpJiZ1LnJlZ2V4PT09dHJ1ZSl7bi5vdXRwdXQ9RztwdXNoKG4pO2NvbnRpbnVlfWlmKG0uaW5kZXg9PT1tLnN0YXJ0fHxCLnR5cGU9PT1cInNsYXNoXCJ8fEIudHlwZT09PVwiZG90XCIpe2lmKEIudHlwZT09PVwiZG90XCIpe20ub3V0cHV0Kz14O0Iub3V0cHV0Kz14fWVsc2UgaWYodS5kb3Q9PT10cnVlKXttLm91dHB1dCs9UztCLm91dHB1dCs9U31lbHNle20ub3V0cHV0Kz1UO0Iub3V0cHV0Kz1UfWlmKEQoKSE9PVwiKlwiKXttLm91dHB1dCs9QztCLm91dHB1dCs9Q319cHVzaChuKX13aGlsZShtLmJyYWNrZXRzPjApe2lmKHUuc3RyaWN0QnJhY2tldHM9PT10cnVlKXRocm93IG5ldyBTeW50YXhFcnJvcihzeW50YXhFcnJvcihcImNsb3NpbmdcIixcIl1cIikpO20ub3V0cHV0PW8uZXNjYXBlTGFzdChtLm91dHB1dCxcIltcIik7ZGVjcmVtZW50KFwiYnJhY2tldHNcIil9d2hpbGUobS5wYXJlbnM+MCl7aWYodS5zdHJpY3RCcmFja2V0cz09PXRydWUpdGhyb3cgbmV3IFN5bnRheEVycm9yKHN5bnRheEVycm9yKFwiY2xvc2luZ1wiLFwiKVwiKSk7bS5vdXRwdXQ9by5lc2NhcGVMYXN0KG0ub3V0cHV0LFwiKFwiKTtkZWNyZW1lbnQoXCJwYXJlbnNcIil9d2hpbGUobS5icmFjZXM+MCl7aWYodS5zdHJpY3RCcmFja2V0cz09PXRydWUpdGhyb3cgbmV3IFN5bnRheEVycm9yKHN5bnRheEVycm9yKFwiY2xvc2luZ1wiLFwifVwiKSk7bS5vdXRwdXQ9by5lc2NhcGVMYXN0KG0ub3V0cHV0LFwie1wiKTtkZWNyZW1lbnQoXCJicmFjZXNcIil9aWYodS5zdHJpY3RTbGFzaGVzIT09dHJ1ZSYmKEIudHlwZT09PVwic3RhclwifHxCLnR5cGU9PT1cImJyYWNrZXRcIikpe3B1c2goe3R5cGU6XCJtYXliZV9zbGFzaFwiLHZhbHVlOlwiXCIsb3V0cHV0OmAke2J9P2B9KX1pZihtLmJhY2t0cmFjaz09PXRydWUpe20ub3V0cHV0PVwiXCI7Zm9yKGNvbnN0IHQgb2YgbS50b2tlbnMpe20ub3V0cHV0Kz10Lm91dHB1dCE9bnVsbD90Lm91dHB1dDp0LnZhbHVlO2lmKHQuc3VmZml4KXttLm91dHB1dCs9dC5zdWZmaXh9fX1yZXR1cm4gbX07cGFyc2UuZmFzdHBhdGhzPSh0LGUpPT57Y29uc3QgdT17Li4uZX07Y29uc3Qgcj10eXBlb2YgdS5tYXhMZW5ndGg9PT1cIm51bWJlclwiP01hdGgubWluKHMsdS5tYXhMZW5ndGgpOnM7Y29uc3QgYT10Lmxlbmd0aDtpZihhPnIpe3Rocm93IG5ldyBTeW50YXhFcnJvcihgSW5wdXQgbGVuZ3RoOiAke2F9LCBleGNlZWRzIG1heGltdW0gYWxsb3dlZCBsZW5ndGg6ICR7cn1gKX10PWNbdF18fHQ7Y29uc3R7RE9UX0xJVEVSQUw6aSxTTEFTSF9MSVRFUkFMOnAsT05FX0NIQVI6bCxET1RTX1NMQVNIOmYsTk9fRE9UOkEsTk9fRE9UUzpfLE5PX0RPVFNfU0xBU0g6UixTVEFSOkUsU1RBUlRfQU5DSE9SOmh9PW4uZ2xvYkNoYXJzKHUud2luZG93cyk7Y29uc3QgZz11LmRvdD9fOkE7Y29uc3QgYj11LmRvdD9SOkE7Y29uc3QgQz11LmNhcHR1cmU/XCJcIjpcIj86XCI7Y29uc3QgeT17bmVnYXRlZDpmYWxzZSxwcmVmaXg6XCJcIn07bGV0ICQ9dS5iYXNoPT09dHJ1ZT9cIi4qP1wiOkU7aWYodS5jYXB0dXJlKXskPWAoJHskfSlgfWNvbnN0IGdsb2JzdGFyPXQ9PntpZih0Lm5vZ2xvYnN0YXI9PT10cnVlKXJldHVybiAkO3JldHVybmAoJHtDfSg/Oig/ISR7aH0ke3QuZG90P2Y6aX0pLikqPylgfTtjb25zdCBjcmVhdGU9dD0+e3N3aXRjaCh0KXtjYXNlXCIqXCI6cmV0dXJuYCR7Z30ke2x9JHskfWA7Y2FzZVwiLipcIjpyZXR1cm5gJHtpfSR7bH0keyR9YDtjYXNlXCIqLipcIjpyZXR1cm5gJHtnfSR7JH0ke2l9JHtsfSR7JH1gO2Nhc2VcIiovKlwiOnJldHVybmAke2d9JHskfSR7cH0ke2x9JHtifSR7JH1gO2Nhc2VcIioqXCI6cmV0dXJuIGcrZ2xvYnN0YXIodSk7Y2FzZVwiKiovKlwiOnJldHVybmAoPzoke2d9JHtnbG9ic3Rhcih1KX0ke3B9KT8ke2J9JHtsfSR7JH1gO2Nhc2VcIioqLyouKlwiOnJldHVybmAoPzoke2d9JHtnbG9ic3Rhcih1KX0ke3B9KT8ke2J9JHskfSR7aX0ke2x9JHskfWA7Y2FzZVwiKiovLipcIjpyZXR1cm5gKD86JHtnfSR7Z2xvYnN0YXIodSl9JHtwfSk/JHtpfSR7bH0keyR9YDtkZWZhdWx0Ontjb25zdCBlPS9eKC4qPylcXC4oXFx3KykkLy5leGVjKHQpO2lmKCFlKXJldHVybjtjb25zdCB1PWNyZWF0ZShlWzFdKTtpZighdSlyZXR1cm47cmV0dXJuIHUraStlWzJdfX19O2NvbnN0IHg9by5yZW1vdmVQcmVmaXgodCx5KTtsZXQgUz1jcmVhdGUoeCk7aWYoUyYmdS5zdHJpY3RTbGFzaGVzIT09dHJ1ZSl7Uys9YCR7cH0/YH1yZXR1cm4gU307dC5leHBvcnRzPXBhcnNlfSw1MTA6KHQsZSx1KT0+e2NvbnN0IG49dSg3MTYpO2NvbnN0IG89dSg2OTcpO2NvbnN0IHM9dSg5Nik7Y29uc3Qgcj11KDE1NCk7Y29uc3QgaXNPYmplY3Q9dD0+dCYmdHlwZW9mIHQ9PT1cIm9iamVjdFwiJiYhQXJyYXkuaXNBcnJheSh0KTtjb25zdCBwaWNvbWF0Y2g9KHQsZSx1PWZhbHNlKT0+e2lmKEFycmF5LmlzQXJyYXkodCkpe2NvbnN0IG49dC5tYXAoKHQ9PnBpY29tYXRjaCh0LGUsdSkpKTtjb25zdCBhcnJheU1hdGNoZXI9dD0+e2Zvcihjb25zdCBlIG9mIG4pe2NvbnN0IHU9ZSh0KTtpZih1KXJldHVybiB1fXJldHVybiBmYWxzZX07cmV0dXJuIGFycmF5TWF0Y2hlcn1jb25zdCBuPWlzT2JqZWN0KHQpJiZ0LnRva2VucyYmdC5pbnB1dDtpZih0PT09XCJcInx8dHlwZW9mIHQhPT1cInN0cmluZ1wiJiYhbil7dGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIHBhdHRlcm4gdG8gYmUgYSBub24tZW1wdHkgc3RyaW5nXCIpfWNvbnN0IG89ZXx8e307Y29uc3Qgcz1vLndpbmRvd3M7Y29uc3Qgcj1uP3BpY29tYXRjaC5jb21waWxlUmUodCxlKTpwaWNvbWF0Y2gubWFrZVJlKHQsZSxmYWxzZSx0cnVlKTtjb25zdCBhPXIuc3RhdGU7ZGVsZXRlIHIuc3RhdGU7bGV0IGlzSWdub3JlZD0oKT0+ZmFsc2U7aWYoby5pZ25vcmUpe2NvbnN0IHQ9ey4uLmUsaWdub3JlOm51bGwsb25NYXRjaDpudWxsLG9uUmVzdWx0Om51bGx9O2lzSWdub3JlZD1waWNvbWF0Y2goby5pZ25vcmUsdCx1KX1jb25zdCBtYXRjaGVyPSh1LG49ZmFsc2UpPT57Y29uc3R7aXNNYXRjaDppLG1hdGNoOmMsb3V0cHV0OnB9PXBpY29tYXRjaC50ZXN0KHUscixlLHtnbG9iOnQscG9zaXg6c30pO2NvbnN0IGw9e2dsb2I6dCxzdGF0ZTphLHJlZ2V4OnIscG9zaXg6cyxpbnB1dDp1LG91dHB1dDpwLG1hdGNoOmMsaXNNYXRjaDppfTtpZih0eXBlb2Ygby5vblJlc3VsdD09PVwiZnVuY3Rpb25cIil7by5vblJlc3VsdChsKX1pZihpPT09ZmFsc2Upe2wuaXNNYXRjaD1mYWxzZTtyZXR1cm4gbj9sOmZhbHNlfWlmKGlzSWdub3JlZCh1KSl7aWYodHlwZW9mIG8ub25JZ25vcmU9PT1cImZ1bmN0aW9uXCIpe28ub25JZ25vcmUobCl9bC5pc01hdGNoPWZhbHNlO3JldHVybiBuP2w6ZmFsc2V9aWYodHlwZW9mIG8ub25NYXRjaD09PVwiZnVuY3Rpb25cIil7by5vbk1hdGNoKGwpfXJldHVybiBuP2w6dHJ1ZX07aWYodSl7bWF0Y2hlci5zdGF0ZT1hfXJldHVybiBtYXRjaGVyfTtwaWNvbWF0Y2gudGVzdD0odCxlLHUse2dsb2I6bixwb3NpeDpvfT17fSk9PntpZih0eXBlb2YgdCE9PVwic3RyaW5nXCIpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBpbnB1dCB0byBiZSBhIHN0cmluZ1wiKX1pZih0PT09XCJcIil7cmV0dXJue2lzTWF0Y2g6ZmFsc2Usb3V0cHV0OlwiXCJ9fWNvbnN0IHI9dXx8e307Y29uc3QgYT1yLmZvcm1hdHx8KG8/cy50b1Bvc2l4U2xhc2hlczpudWxsKTtsZXQgaT10PT09bjtsZXQgYz1pJiZhP2EodCk6dDtpZihpPT09ZmFsc2Upe2M9YT9hKHQpOnQ7aT1jPT09bn1pZihpPT09ZmFsc2V8fHIuY2FwdHVyZT09PXRydWUpe2lmKHIubWF0Y2hCYXNlPT09dHJ1ZXx8ci5iYXNlbmFtZT09PXRydWUpe2k9cGljb21hdGNoLm1hdGNoQmFzZSh0LGUsdSxvKX1lbHNle2k9ZS5leGVjKGMpfX1yZXR1cm57aXNNYXRjaDpCb29sZWFuKGkpLG1hdGNoOmksb3V0cHV0OmN9fTtwaWNvbWF0Y2gubWF0Y2hCYXNlPSh0LGUsdSk9Pntjb25zdCBuPWUgaW5zdGFuY2VvZiBSZWdFeHA/ZTpwaWNvbWF0Y2gubWFrZVJlKGUsdSk7cmV0dXJuIG4udGVzdChzLmJhc2VuYW1lKHQpKX07cGljb21hdGNoLmlzTWF0Y2g9KHQsZSx1KT0+cGljb21hdGNoKGUsdSkodCk7cGljb21hdGNoLnBhcnNlPSh0LGUpPT57aWYoQXJyYXkuaXNBcnJheSh0KSlyZXR1cm4gdC5tYXAoKHQ9PnBpY29tYXRjaC5wYXJzZSh0LGUpKSk7cmV0dXJuIG8odCx7Li4uZSxmYXN0cGF0aHM6ZmFsc2V9KX07cGljb21hdGNoLnNjYW49KHQsZSk9Pm4odCxlKTtwaWNvbWF0Y2guY29tcGlsZVJlPSh0LGUsdT1mYWxzZSxuPWZhbHNlKT0+e2lmKHU9PT10cnVlKXtyZXR1cm4gdC5vdXRwdXR9Y29uc3Qgbz1lfHx7fTtjb25zdCBzPW8uY29udGFpbnM/XCJcIjpcIl5cIjtjb25zdCByPW8uY29udGFpbnM/XCJcIjpcIiRcIjtsZXQgYT1gJHtzfSg/OiR7dC5vdXRwdXR9KSR7cn1gO2lmKHQmJnQubmVnYXRlZD09PXRydWUpe2E9YF4oPyEke2F9KS4qJGB9Y29uc3QgaT1waWNvbWF0Y2gudG9SZWdleChhLGUpO2lmKG49PT10cnVlKXtpLnN0YXRlPXR9cmV0dXJuIGl9O3BpY29tYXRjaC5tYWtlUmU9KHQsZT17fSx1PWZhbHNlLG49ZmFsc2UpPT57aWYoIXR8fHR5cGVvZiB0IT09XCJzdHJpbmdcIil7dGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIGEgbm9uLWVtcHR5IHN0cmluZ1wiKX1sZXQgcz17bmVnYXRlZDpmYWxzZSxmYXN0cGF0aHM6dHJ1ZX07aWYoZS5mYXN0cGF0aHMhPT1mYWxzZSYmKHRbMF09PT1cIi5cInx8dFswXT09PVwiKlwiKSl7cy5vdXRwdXQ9by5mYXN0cGF0aHModCxlKX1pZighcy5vdXRwdXQpe3M9byh0LGUpfXJldHVybiBwaWNvbWF0Y2guY29tcGlsZVJlKHMsZSx1LG4pfTtwaWNvbWF0Y2gudG9SZWdleD0odCxlKT0+e3RyeXtjb25zdCB1PWV8fHt9O3JldHVybiBuZXcgUmVnRXhwKHQsdS5mbGFnc3x8KHUubm9jYXNlP1wiaVwiOlwiXCIpKX1jYXRjaCh0KXtpZihlJiZlLmRlYnVnPT09dHJ1ZSl0aHJvdyB0O3JldHVybi8kXi99fTtwaWNvbWF0Y2guY29uc3RhbnRzPXI7dC5leHBvcnRzPXBpY29tYXRjaH0sNzE2Oih0LGUsdSk9Pntjb25zdCBuPXUoOTYpO2NvbnN0e0NIQVJfQVNURVJJU0s6byxDSEFSX0FUOnMsQ0hBUl9CQUNLV0FSRF9TTEFTSDpyLENIQVJfQ09NTUE6YSxDSEFSX0RPVDppLENIQVJfRVhDTEFNQVRJT05fTUFSSzpjLENIQVJfRk9SV0FSRF9TTEFTSDpwLENIQVJfTEVGVF9DVVJMWV9CUkFDRTpsLENIQVJfTEVGVF9QQVJFTlRIRVNFUzpmLENIQVJfTEVGVF9TUVVBUkVfQlJBQ0tFVDpBLENIQVJfUExVUzpfLENIQVJfUVVFU1RJT05fTUFSSzpSLENIQVJfUklHSFRfQ1VSTFlfQlJBQ0U6RSxDSEFSX1JJR0hUX1BBUkVOVEhFU0VTOmgsQ0hBUl9SSUdIVF9TUVVBUkVfQlJBQ0tFVDpnfT11KDE1NCk7Y29uc3QgaXNQYXRoU2VwYXJhdG9yPXQ9PnQ9PT1wfHx0PT09cjtjb25zdCBkZXB0aD10PT57aWYodC5pc1ByZWZpeCE9PXRydWUpe3QuZGVwdGg9dC5pc0dsb2JzdGFyP0luZmluaXR5OjF9fTtjb25zdCBzY2FuPSh0LGUpPT57Y29uc3QgdT1lfHx7fTtjb25zdCBiPXQubGVuZ3RoLTE7Y29uc3QgQz11LnBhcnRzPT09dHJ1ZXx8dS5zY2FuVG9FbmQ9PT10cnVlO2NvbnN0IHk9W107Y29uc3QgJD1bXTtjb25zdCB4PVtdO2xldCBTPXQ7bGV0IEg9LTE7bGV0IHY9MDtsZXQgZD0wO2xldCBMPWZhbHNlO2xldCBUPWZhbHNlO2xldCBPPWZhbHNlO2xldCBrPWZhbHNlO2xldCBtPWZhbHNlO2xldCB3PWZhbHNlO2xldCBOPWZhbHNlO2xldCBJPWZhbHNlO2xldCBCPWZhbHNlO2xldCBHPWZhbHNlO2xldCBEPTA7bGV0IE07bGV0IFA7bGV0IEs9e3ZhbHVlOlwiXCIsZGVwdGg6MCxpc0dsb2I6ZmFsc2V9O2NvbnN0IGVvcz0oKT0+SD49Yjtjb25zdCBwZWVrPSgpPT5TLmNoYXJDb2RlQXQoSCsxKTtjb25zdCBhZHZhbmNlPSgpPT57TT1QO3JldHVybiBTLmNoYXJDb2RlQXQoKytIKX07d2hpbGUoSDxiKXtQPWFkdmFuY2UoKTtsZXQgdDtpZihQPT09cil7Tj1LLmJhY2tzbGFzaGVzPXRydWU7UD1hZHZhbmNlKCk7aWYoUD09PWwpe3c9dHJ1ZX1jb250aW51ZX1pZih3PT09dHJ1ZXx8UD09PWwpe0QrKzt3aGlsZShlb3MoKSE9PXRydWUmJihQPWFkdmFuY2UoKSkpe2lmKFA9PT1yKXtOPUsuYmFja3NsYXNoZXM9dHJ1ZTthZHZhbmNlKCk7Y29udGludWV9aWYoUD09PWwpe0QrKztjb250aW51ZX1pZih3IT09dHJ1ZSYmUD09PWkmJihQPWFkdmFuY2UoKSk9PT1pKXtMPUsuaXNCcmFjZT10cnVlO089Sy5pc0dsb2I9dHJ1ZTtHPXRydWU7aWYoQz09PXRydWUpe2NvbnRpbnVlfWJyZWFrfWlmKHchPT10cnVlJiZQPT09YSl7TD1LLmlzQnJhY2U9dHJ1ZTtPPUsuaXNHbG9iPXRydWU7Rz10cnVlO2lmKEM9PT10cnVlKXtjb250aW51ZX1icmVha31pZihQPT09RSl7RC0tO2lmKEQ9PT0wKXt3PWZhbHNlO0w9Sy5pc0JyYWNlPXRydWU7Rz10cnVlO2JyZWFrfX19aWYoQz09PXRydWUpe2NvbnRpbnVlfWJyZWFrfWlmKFA9PT1wKXt5LnB1c2goSCk7JC5wdXNoKEspO0s9e3ZhbHVlOlwiXCIsZGVwdGg6MCxpc0dsb2I6ZmFsc2V9O2lmKEc9PT10cnVlKWNvbnRpbnVlO2lmKE09PT1pJiZIPT09disxKXt2Kz0yO2NvbnRpbnVlfWQ9SCsxO2NvbnRpbnVlfWlmKHUubm9leHQhPT10cnVlKXtjb25zdCB0PVA9PT1ffHxQPT09c3x8UD09PW98fFA9PT1SfHxQPT09YztpZih0PT09dHJ1ZSYmcGVlaygpPT09Zil7Tz1LLmlzR2xvYj10cnVlO2s9Sy5pc0V4dGdsb2I9dHJ1ZTtHPXRydWU7aWYoUD09PWMmJkg9PT12KXtCPXRydWV9aWYoQz09PXRydWUpe3doaWxlKGVvcygpIT09dHJ1ZSYmKFA9YWR2YW5jZSgpKSl7aWYoUD09PXIpe049Sy5iYWNrc2xhc2hlcz10cnVlO1A9YWR2YW5jZSgpO2NvbnRpbnVlfWlmKFA9PT1oKXtPPUsuaXNHbG9iPXRydWU7Rz10cnVlO2JyZWFrfX1jb250aW51ZX1icmVha319aWYoUD09PW8pe2lmKE09PT1vKW09Sy5pc0dsb2JzdGFyPXRydWU7Tz1LLmlzR2xvYj10cnVlO0c9dHJ1ZTtpZihDPT09dHJ1ZSl7Y29udGludWV9YnJlYWt9aWYoUD09PVIpe089Sy5pc0dsb2I9dHJ1ZTtHPXRydWU7aWYoQz09PXRydWUpe2NvbnRpbnVlfWJyZWFrfWlmKFA9PT1BKXt3aGlsZShlb3MoKSE9PXRydWUmJih0PWFkdmFuY2UoKSkpe2lmKHQ9PT1yKXtOPUsuYmFja3NsYXNoZXM9dHJ1ZTthZHZhbmNlKCk7Y29udGludWV9aWYodD09PWcpe1Q9Sy5pc0JyYWNrZXQ9dHJ1ZTtPPUsuaXNHbG9iPXRydWU7Rz10cnVlO2JyZWFrfX1pZihDPT09dHJ1ZSl7Y29udGludWV9YnJlYWt9aWYodS5ub25lZ2F0ZSE9PXRydWUmJlA9PT1jJiZIPT09dil7ST1LLm5lZ2F0ZWQ9dHJ1ZTt2Kys7Y29udGludWV9aWYodS5ub3BhcmVuIT09dHJ1ZSYmUD09PWYpe089Sy5pc0dsb2I9dHJ1ZTtpZihDPT09dHJ1ZSl7d2hpbGUoZW9zKCkhPT10cnVlJiYoUD1hZHZhbmNlKCkpKXtpZihQPT09Zil7Tj1LLmJhY2tzbGFzaGVzPXRydWU7UD1hZHZhbmNlKCk7Y29udGludWV9aWYoUD09PWgpe0c9dHJ1ZTticmVha319Y29udGludWV9YnJlYWt9aWYoTz09PXRydWUpe0c9dHJ1ZTtpZihDPT09dHJ1ZSl7Y29udGludWV9YnJlYWt9fWlmKHUubm9leHQ9PT10cnVlKXtrPWZhbHNlO089ZmFsc2V9bGV0IFU9UztsZXQgWD1cIlwiO2xldCBGPVwiXCI7aWYodj4wKXtYPVMuc2xpY2UoMCx2KTtTPVMuc2xpY2Uodik7ZC09dn1pZihVJiZPPT09dHJ1ZSYmZD4wKXtVPVMuc2xpY2UoMCxkKTtGPVMuc2xpY2UoZCl9ZWxzZSBpZihPPT09dHJ1ZSl7VT1cIlwiO0Y9U31lbHNle1U9U31pZihVJiZVIT09XCJcIiYmVSE9PVwiL1wiJiZVIT09Uyl7aWYoaXNQYXRoU2VwYXJhdG9yKFUuY2hhckNvZGVBdChVLmxlbmd0aC0xKSkpe1U9VS5zbGljZSgwLC0xKX19aWYodS51bmVzY2FwZT09PXRydWUpe2lmKEYpRj1uLnJlbW92ZUJhY2tzbGFzaGVzKEYpO2lmKFUmJk49PT10cnVlKXtVPW4ucmVtb3ZlQmFja3NsYXNoZXMoVSl9fWNvbnN0IFE9e3ByZWZpeDpYLGlucHV0OnQsc3RhcnQ6dixiYXNlOlUsZ2xvYjpGLGlzQnJhY2U6TCxpc0JyYWNrZXQ6VCxpc0dsb2I6Tyxpc0V4dGdsb2I6ayxpc0dsb2JzdGFyOm0sbmVnYXRlZDpJLG5lZ2F0ZWRFeHRnbG9iOkJ9O2lmKHUudG9rZW5zPT09dHJ1ZSl7US5tYXhEZXB0aD0wO2lmKCFpc1BhdGhTZXBhcmF0b3IoUCkpeyQucHVzaChLKX1RLnRva2Vucz0kfWlmKHUucGFydHM9PT10cnVlfHx1LnRva2Vucz09PXRydWUpe2xldCBlO2ZvcihsZXQgbj0wO248eS5sZW5ndGg7bisrKXtjb25zdCBvPWU/ZSsxOnY7Y29uc3Qgcz15W25dO2NvbnN0IHI9dC5zbGljZShvLHMpO2lmKHUudG9rZW5zKXtpZihuPT09MCYmdiE9PTApeyRbbl0uaXNQcmVmaXg9dHJ1ZTskW25dLnZhbHVlPVh9ZWxzZXskW25dLnZhbHVlPXJ9ZGVwdGgoJFtuXSk7US5tYXhEZXB0aCs9JFtuXS5kZXB0aH1pZihuIT09MHx8ciE9PVwiXCIpe3gucHVzaChyKX1lPXN9aWYoZSYmZSsxPHQubGVuZ3RoKXtjb25zdCBuPXQuc2xpY2UoZSsxKTt4LnB1c2gobik7aWYodS50b2tlbnMpeyRbJC5sZW5ndGgtMV0udmFsdWU9bjtkZXB0aCgkWyQubGVuZ3RoLTFdKTtRLm1heERlcHRoKz0kWyQubGVuZ3RoLTFdLmRlcHRofX1RLnNsYXNoZXM9eTtRLnBhcnRzPXh9cmV0dXJuIFF9O3QuZXhwb3J0cz1zY2FufSw5NjoodCxlLHUpPT57Y29uc3R7UkVHRVhfQkFDS1NMQVNIOm4sUkVHRVhfUkVNT1ZFX0JBQ0tTTEFTSDpvLFJFR0VYX1NQRUNJQUxfQ0hBUlM6cyxSRUdFWF9TUEVDSUFMX0NIQVJTX0dMT0JBTDpyfT11KDE1NCk7ZS5pc09iamVjdD10PT50IT09bnVsbCYmdHlwZW9mIHQ9PT1cIm9iamVjdFwiJiYhQXJyYXkuaXNBcnJheSh0KTtlLmhhc1JlZ2V4Q2hhcnM9dD0+cy50ZXN0KHQpO2UuaXNSZWdleENoYXI9dD0+dC5sZW5ndGg9PT0xJiZlLmhhc1JlZ2V4Q2hhcnModCk7ZS5lc2NhcGVSZWdleD10PT50LnJlcGxhY2UocixcIlxcXFwkMVwiKTtlLnRvUG9zaXhTbGFzaGVzPXQ9PnQucmVwbGFjZShuLFwiL1wiKTtlLnJlbW92ZUJhY2tzbGFzaGVzPXQ9PnQucmVwbGFjZShvLCh0PT50PT09XCJcXFxcXCI/XCJcIjp0KSk7ZS5lc2NhcGVMYXN0PSh0LHUsbik9Pntjb25zdCBvPXQubGFzdEluZGV4T2YodSxuKTtpZihvPT09LTEpcmV0dXJuIHQ7aWYodFtvLTFdPT09XCJcXFxcXCIpcmV0dXJuIGUuZXNjYXBlTGFzdCh0LHUsby0xKTtyZXR1cm5gJHt0LnNsaWNlKDAsbyl9XFxcXCR7dC5zbGljZShvKX1gfTtlLnJlbW92ZVByZWZpeD0odCxlPXt9KT0+e2xldCB1PXQ7aWYodS5zdGFydHNXaXRoKFwiLi9cIikpe3U9dS5zbGljZSgyKTtlLnByZWZpeD1cIi4vXCJ9cmV0dXJuIHV9O2Uud3JhcE91dHB1dD0odCxlPXt9LHU9e30pPT57Y29uc3Qgbj11LmNvbnRhaW5zP1wiXCI6XCJeXCI7Y29uc3Qgbz11LmNvbnRhaW5zP1wiXCI6XCIkXCI7bGV0IHM9YCR7bn0oPzoke3R9KSR7b31gO2lmKGUubmVnYXRlZD09PXRydWUpe3M9YCg/Ol4oPyEke3N9KS4qJClgfXJldHVybiBzfTtlLmJhc2VuYW1lPSh0LHt3aW5kb3dzOmV9PXt9KT0+e2NvbnN0IHU9dC5zcGxpdChlPy9bXFxcXC9dLzpcIi9cIik7Y29uc3Qgbj11W3UubGVuZ3RoLTFdO2lmKG49PT1cIlwiKXtyZXR1cm4gdVt1Lmxlbmd0aC0yXX1yZXR1cm4gbn19fTt2YXIgZT17fTtmdW5jdGlvbiBfX25jY3dwY2tfcmVxdWlyZV9fKHUpe3ZhciBuPWVbdV07aWYobiE9PXVuZGVmaW5lZCl7cmV0dXJuIG4uZXhwb3J0c312YXIgbz1lW3VdPXtleHBvcnRzOnt9fTt2YXIgcz10cnVlO3RyeXt0W3VdKG8sby5leHBvcnRzLF9fbmNjd3Bja19yZXF1aXJlX18pO3M9ZmFsc2V9ZmluYWxseXtpZihzKWRlbGV0ZSBlW3VdfXJldHVybiBvLmV4cG9ydHN9aWYodHlwZW9mIF9fbmNjd3Bja19yZXF1aXJlX18hPT1cInVuZGVmaW5lZFwiKV9fbmNjd3Bja19yZXF1aXJlX18uYWI9X19kaXJuYW1lK1wiL1wiO3ZhciB1PV9fbmNjd3Bja19yZXF1aXJlX18oMTcwKTttb2R1bGUuZXhwb3J0cz11fSkoKTsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/picomatch/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/image-component.js":
/*!**********************************************************!*\
  !*** ./node_modules/next/dist/client/image-component.js ***!
  \**********************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"Image\", ({\n    enumerable: true,\n    get: function() {\n        return Image;\n    }\n}));\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nconst _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js\");\nconst _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nconst _reactdom = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react-dom */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react-dom/index.js\"));\nconst _head = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ../shared/lib/head */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/head.js\"));\nconst _getimgprops = __webpack_require__(/*! ../shared/lib/get-img-props */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/get-img-props.js\");\nconst _imageconfig = __webpack_require__(/*! ../shared/lib/image-config */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/image-config.js\");\nconst _imageconfigcontextsharedruntime = __webpack_require__(/*! ../shared/lib/image-config-context.shared-runtime */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/image-config-context.shared-runtime.js\");\nconst _warnonce = __webpack_require__(/*! ../shared/lib/utils/warn-once */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/utils/warn-once.js\");\nconst _routercontextsharedruntime = __webpack_require__(/*! ../shared/lib/router-context.shared-runtime */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router-context.shared-runtime.js\");\nconst _imageloader = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! next/dist/shared/lib/image-loader */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/image-loader.js\"));\nconst _usemergedref = __webpack_require__(/*! ./use-merged-ref */ \"(app-pages-browser)/./node_modules/next/dist/client/use-merged-ref.js\");\n// This is replaced by webpack define plugin\nconst configEnv = {\"deviceSizes\":[640,750,828,1080,1200,1920,2048,3840],\"imageSizes\":[16,32,48,64,96,128,256,384],\"path\":\"/_next/image\",\"loader\":\"default\",\"dangerouslyAllowSVG\":false,\"unoptimized\":true,\"domains\":[],\"remotePatterns\":[]};\nif (typeof window === 'undefined') {\n    ;\n    globalThis.__NEXT_IMAGE_IMPORTED = true;\n}\n// See https://stackoverflow.com/q/39777833/266535 for why we use this ref\n// handler instead of the img's onLoad attribute.\nfunction handleLoading(img, placeholder, onLoadRef, onLoadingCompleteRef, setBlurComplete, unoptimized, sizesInput) {\n    const src = img == null ? void 0 : img.src;\n    if (!img || img['data-loaded-src'] === src) {\n        return;\n    }\n    img['data-loaded-src'] = src;\n    const p = 'decode' in img ? img.decode() : Promise.resolve();\n    p.catch(()=>{}).then(()=>{\n        if (!img.parentElement || !img.isConnected) {\n            // Exit early in case of race condition:\n            // - onload() is called\n            // - decode() is called but incomplete\n            // - unmount is called\n            // - decode() completes\n            return;\n        }\n        if (placeholder !== 'empty') {\n            setBlurComplete(true);\n        }\n        if (onLoadRef == null ? void 0 : onLoadRef.current) {\n            // Since we don't have the SyntheticEvent here,\n            // we must create one with the same shape.\n            // See https://reactjs.org/docs/events.html\n            const event = new Event('load');\n            Object.defineProperty(event, 'target', {\n                writable: false,\n                value: img\n            });\n            let prevented = false;\n            let stopped = false;\n            onLoadRef.current({\n                ...event,\n                nativeEvent: event,\n                currentTarget: img,\n                target: img,\n                isDefaultPrevented: ()=>prevented,\n                isPropagationStopped: ()=>stopped,\n                persist: ()=>{},\n                preventDefault: ()=>{\n                    prevented = true;\n                    event.preventDefault();\n                },\n                stopPropagation: ()=>{\n                    stopped = true;\n                    event.stopPropagation();\n                }\n            });\n        }\n        if (onLoadingCompleteRef == null ? void 0 : onLoadingCompleteRef.current) {\n            onLoadingCompleteRef.current(img);\n        }\n        if (true) {\n            const origSrc = new URL(src, 'http://n').searchParams.get('url') || src;\n            if (img.getAttribute('data-nimg') === 'fill') {\n                if (!unoptimized && (!sizesInput || sizesInput === '100vw')) {\n                    let widthViewportRatio = img.getBoundingClientRect().width / window.innerWidth;\n                    if (widthViewportRatio < 0.6) {\n                        if (sizesInput === '100vw') {\n                            (0, _warnonce.warnOnce)('Image with src \"' + origSrc + '\" has \"fill\" prop and \"sizes\" prop of \"100vw\", but image is not rendered at full viewport width. Please adjust \"sizes\" to improve page performance. Read more: https://nextjs.org/docs/api-reference/next/image#sizes');\n                        } else {\n                            (0, _warnonce.warnOnce)('Image with src \"' + origSrc + '\" has \"fill\" but is missing \"sizes\" prop. Please add it to improve page performance. Read more: https://nextjs.org/docs/api-reference/next/image#sizes');\n                        }\n                    }\n                }\n                if (img.parentElement) {\n                    const { position } = window.getComputedStyle(img.parentElement);\n                    const valid = [\n                        'absolute',\n                        'fixed',\n                        'relative'\n                    ];\n                    if (!valid.includes(position)) {\n                        (0, _warnonce.warnOnce)('Image with src \"' + origSrc + '\" has \"fill\" and parent element with invalid \"position\". Provided \"' + position + '\" should be one of ' + valid.map(String).join(',') + \".\");\n                    }\n                }\n                if (img.height === 0) {\n                    (0, _warnonce.warnOnce)('Image with src \"' + origSrc + '\" has \"fill\" and a height value of 0. This is likely because the parent element of the image has not been styled to have a set height.');\n                }\n            }\n            const heightModified = img.height.toString() !== img.getAttribute('height');\n            const widthModified = img.width.toString() !== img.getAttribute('width');\n            if (heightModified && !widthModified || !heightModified && widthModified) {\n                (0, _warnonce.warnOnce)('Image with src \"' + origSrc + '\" has either width or height modified, but not the other. If you use CSS to change the size of your image, also include the styles \\'width: \"auto\"\\' or \\'height: \"auto\"\\' to maintain the aspect ratio.');\n            }\n        }\n    });\n}\nfunction getDynamicProps(fetchPriority) {\n    if (Boolean(_react.use)) {\n        // In React 19.0.0 or newer, we must use camelCase\n        // prop to avoid \"Warning: Invalid DOM property\".\n        // See https://github.com/facebook/react/pull/25927\n        return {\n            fetchPriority\n        };\n    }\n    // In React 18.2.0 or older, we must use lowercase prop\n    // to avoid \"Warning: Invalid DOM property\".\n    return {\n        fetchpriority: fetchPriority\n    };\n}\nconst ImageElement = /*#__PURE__*/ (0, _react.forwardRef)((param, forwardedRef)=>{\n    let { src, srcSet, sizes, height, width, decoding, className, style, fetchPriority, placeholder, loading, unoptimized, fill, onLoadRef, onLoadingCompleteRef, setBlurComplete, setShowAltText, sizesInput, onLoad, onError, ...rest } = param;\n    const ownRef = (0, _react.useCallback)((img)=>{\n        if (!img) {\n            return;\n        }\n        if (onError) {\n            // If the image has an error before react hydrates, then the error is lost.\n            // The workaround is to wait until the image is mounted which is after hydration,\n            // then we set the src again to trigger the error handler (if there was an error).\n            // eslint-disable-next-line no-self-assign\n            img.src = img.src;\n        }\n        if (true) {\n            if (!src) {\n                console.error('Image is missing required \"src\" property:', img);\n            }\n            if (img.getAttribute('alt') === null) {\n                console.error('Image is missing required \"alt\" property. Please add Alternative Text to describe the image for screen readers and search engines.');\n            }\n        }\n        if (img.complete) {\n            handleLoading(img, placeholder, onLoadRef, onLoadingCompleteRef, setBlurComplete, unoptimized, sizesInput);\n        }\n    }, [\n        src,\n        placeholder,\n        onLoadRef,\n        onLoadingCompleteRef,\n        setBlurComplete,\n        onError,\n        unoptimized,\n        sizesInput\n    ]);\n    const ref = (0, _usemergedref.useMergedRef)(forwardedRef, ownRef);\n    return /*#__PURE__*/ (0, _jsxruntime.jsx)(\"img\", {\n        ...rest,\n        ...getDynamicProps(fetchPriority),\n        // It's intended to keep `loading` before `src` because React updates\n        // props in order which causes Safari/Firefox to not lazy load properly.\n        // See https://github.com/facebook/react/issues/25883\n        loading: loading,\n        width: width,\n        height: height,\n        decoding: decoding,\n        \"data-nimg\": fill ? 'fill' : '1',\n        className: className,\n        style: style,\n        // It's intended to keep `src` the last attribute because React updates\n        // attributes in order. If we keep `src` the first one, Safari will\n        // immediately start to fetch `src`, before `sizes` and `srcSet` are even\n        // updated by React. That causes multiple unnecessary requests if `srcSet`\n        // and `sizes` are defined.\n        // This bug cannot be reproduced in Chrome or Firefox.\n        sizes: sizes,\n        srcSet: srcSet,\n        src: src,\n        ref: ref,\n        onLoad: (event)=>{\n            const img = event.currentTarget;\n            handleLoading(img, placeholder, onLoadRef, onLoadingCompleteRef, setBlurComplete, unoptimized, sizesInput);\n        },\n        onError: (event)=>{\n            // if the real image fails to load, this will ensure \"alt\" is visible\n            setShowAltText(true);\n            if (placeholder !== 'empty') {\n                // If the real image fails to load, this will still remove the placeholder.\n                setBlurComplete(true);\n            }\n            if (onError) {\n                onError(event);\n            }\n        }\n    });\n});\nfunction ImagePreload(param) {\n    let { isAppRouter, imgAttributes } = param;\n    const opts = {\n        as: 'image',\n        imageSrcSet: imgAttributes.srcSet,\n        imageSizes: imgAttributes.sizes,\n        crossOrigin: imgAttributes.crossOrigin,\n        referrerPolicy: imgAttributes.referrerPolicy,\n        ...getDynamicProps(imgAttributes.fetchPriority)\n    };\n    if (isAppRouter && _reactdom.default.preload) {\n        // See https://github.com/facebook/react/pull/26940\n        _reactdom.default.preload(imgAttributes.src, opts);\n        return null;\n    }\n    return /*#__PURE__*/ (0, _jsxruntime.jsx)(_head.default, {\n        children: /*#__PURE__*/ (0, _jsxruntime.jsx)(\"link\", {\n            rel: \"preload\",\n            // Note how we omit the `href` attribute, as it would only be relevant\n            // for browsers that do not support `imagesrcset`, and in those cases\n            // it would cause the incorrect image to be preloaded.\n            //\n            // https://html.spec.whatwg.org/multipage/semantics.html#attr-link-imagesrcset\n            href: imgAttributes.srcSet ? undefined : imgAttributes.src,\n            ...opts\n        }, '__nimg-' + imgAttributes.src + imgAttributes.srcSet + imgAttributes.sizes)\n    });\n}\n_c = ImagePreload;\nconst Image = /*#__PURE__*/ (0, _react.forwardRef)((props, forwardedRef)=>{\n    const pagesRouter = (0, _react.useContext)(_routercontextsharedruntime.RouterContext);\n    // We're in the app directory if there is no pages router.\n    const isAppRouter = !pagesRouter;\n    const configContext = (0, _react.useContext)(_imageconfigcontextsharedruntime.ImageConfigContext);\n    const config = (0, _react.useMemo)(()=>{\n        var _c_qualities;\n        const c = configEnv || configContext || _imageconfig.imageConfigDefault;\n        const allSizes = [\n            ...c.deviceSizes,\n            ...c.imageSizes\n        ].sort((a, b)=>a - b);\n        const deviceSizes = c.deviceSizes.sort((a, b)=>a - b);\n        const qualities = (_c_qualities = c.qualities) == null ? void 0 : _c_qualities.sort((a, b)=>a - b);\n        return {\n            ...c,\n            allSizes,\n            deviceSizes,\n            qualities\n        };\n    }, [\n        configContext\n    ]);\n    const { onLoad, onLoadingComplete } = props;\n    const onLoadRef = (0, _react.useRef)(onLoad);\n    (0, _react.useEffect)(()=>{\n        onLoadRef.current = onLoad;\n    }, [\n        onLoad\n    ]);\n    const onLoadingCompleteRef = (0, _react.useRef)(onLoadingComplete);\n    (0, _react.useEffect)(()=>{\n        onLoadingCompleteRef.current = onLoadingComplete;\n    }, [\n        onLoadingComplete\n    ]);\n    const [blurComplete, setBlurComplete] = (0, _react.useState)(false);\n    const [showAltText, setShowAltText] = (0, _react.useState)(false);\n    const { props: imgAttributes, meta: imgMeta } = (0, _getimgprops.getImgProps)(props, {\n        defaultLoader: _imageloader.default,\n        imgConf: config,\n        blurComplete,\n        showAltText\n    });\n    return /*#__PURE__*/ (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {\n        children: [\n            /*#__PURE__*/ (0, _jsxruntime.jsx)(ImageElement, {\n                ...imgAttributes,\n                unoptimized: imgMeta.unoptimized,\n                placeholder: imgMeta.placeholder,\n                fill: imgMeta.fill,\n                onLoadRef: onLoadRef,\n                onLoadingCompleteRef: onLoadingCompleteRef,\n                setBlurComplete: setBlurComplete,\n                setShowAltText: setShowAltText,\n                sizesInput: props.sizes,\n                ref: forwardedRef\n            }),\n            imgMeta.priority ? /*#__PURE__*/ (0, _jsxruntime.jsx)(ImagePreload, {\n                isAppRouter: isAppRouter,\n                imgAttributes: imgAttributes\n            }) : null\n        ]\n    });\n});\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=image-component.js.map\nvar _c;\n$RefreshReg$(_c, \"ImagePreload\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2ltYWdlLWNvbXBvbmVudC5qcyIsIm1hcHBpbmdzIjoiOzs7O3lDQTBXYUE7OztlQUFBQTs7Ozs7OzZFQS9WTjsrRUFDYzsyRUFDSjt5Q0FDVzt5Q0FZTzs2REFDQTtzQ0FDVjt3REFDSztrRkFHSjswQ0FDRztBQUU3Qiw0Q0FBNEM7QUFDNUMsTUFBTUMsWUFBWUMseU5BQTZCO0FBRS9DLElBQUksT0FBT0csV0FBVyxhQUFhOztJQUMvQkMsV0FBbUJDLHFCQUFxQixHQUFHO0FBQy9DO0FBbUJBLDBFQUEwRTtBQUMxRSxpREFBaUQ7QUFDakQsU0FBU0MsY0FDUEMsR0FBMkIsRUFDM0JDLFdBQTZCLEVBQzdCQyxTQUFxRCxFQUNyREMsb0JBQTJFLEVBQzNFQyxlQUFxQyxFQUNyQ0MsV0FBb0IsRUFDcEJDLFVBQThCO0lBRTlCLE1BQU1DLE1BQU1QLE9BQUFBLE9BQUFBLEtBQUFBLElBQUFBLElBQUtPLEdBQUc7SUFDcEIsSUFBSSxDQUFDUCxPQUFPQSxHQUFHLENBQUMsa0JBQWtCLEtBQUtPLEtBQUs7UUFDMUM7SUFDRjtJQUNBUCxHQUFHLENBQUMsa0JBQWtCLEdBQUdPO0lBQ3pCLE1BQU1DLElBQUksWUFBWVIsTUFBTUEsSUFBSVMsTUFBTSxLQUFLQyxRQUFRQyxPQUFPO0lBQzFESCxFQUFFSSxLQUFLLENBQUMsS0FBTyxHQUFHQyxJQUFJLENBQUM7UUFDckIsSUFBSSxDQUFDYixJQUFJYyxhQUFhLElBQUksQ0FBQ2QsSUFBSWUsV0FBVyxFQUFFO1lBQzFDLHdDQUF3QztZQUN4Qyx1QkFBdUI7WUFDdkIsc0NBQXNDO1lBQ3RDLHNCQUFzQjtZQUN0Qix1QkFBdUI7WUFDdkI7UUFDRjtRQUNBLElBQUlkLGdCQUFnQixTQUFTO1lBQzNCRyxnQkFBZ0I7UUFDbEI7UUFDQSxJQUFJRixhQUFBQSxPQUFBQSxLQUFBQSxJQUFBQSxVQUFXYyxPQUFPLEVBQUU7WUFDdEIsK0NBQStD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QUdSMkQsUUFBUUksUUFBUSxpQkFDZixxQkFBQzNDLGNBQUFBO2dCQUNDQyxhQUFhQTtnQkFDYkMsZUFBZUE7aUJBRWY7OztBQUdWIiwic291cmNlcyI6WyIvVXNlcnMvam9uYXRoYW52aW5jZW50aXVzL0RvY3VtZW50cy9Vb2ZUL3NyYy9jbGllbnQvaW1hZ2UtY29tcG9uZW50LnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCdcblxuaW1wb3J0IFJlYWN0LCB7XG4gIHVzZVJlZixcbiAgdXNlRWZmZWN0LFxuICB1c2VDYWxsYmFjayxcbiAgdXNlQ29udGV4dCxcbiAgdXNlTWVtbyxcbiAgdXNlU3RhdGUsXG4gIGZvcndhcmRSZWYsXG4gIHVzZSxcbn0gZnJvbSAncmVhY3QnXG5pbXBvcnQgUmVhY3RET00gZnJvbSAncmVhY3QtZG9tJ1xuaW1wb3J0IEhlYWQgZnJvbSAnLi4vc2hhcmVkL2xpYi9oZWFkJ1xuaW1wb3J0IHsgZ2V0SW1nUHJvcHMgfSBmcm9tICcuLi9zaGFyZWQvbGliL2dldC1pbWctcHJvcHMnXG5pbXBvcnQgdHlwZSB7XG4gIEltYWdlUHJvcHMsXG4gIEltZ1Byb3BzLFxuICBPbkxvYWQsXG4gIE9uTG9hZGluZ0NvbXBsZXRlLFxuICBQbGFjZWhvbGRlclZhbHVlLFxufSBmcm9tICcuLi9zaGFyZWQvbGliL2dldC1pbWctcHJvcHMnXG5pbXBvcnQgdHlwZSB7XG4gIEltYWdlQ29uZmlnQ29tcGxldGUsXG4gIEltYWdlTG9hZGVyUHJvcHMsXG59IGZyb20gJy4uL3NoYXJlZC9saWIvaW1hZ2UtY29uZmlnJ1xuaW1wb3J0IHsgaW1hZ2VDb25maWdEZWZhdWx0IH0gZnJvbSAnLi4vc2hhcmVkL2xpYi9pbWFnZS1jb25maWcnXG5pbXBvcnQgeyBJbWFnZUNvbmZpZ0NvbnRleHQgfSBmcm9tICcuLi9zaGFyZWQvbGliL2ltYWdlLWNvbmZpZy1jb250ZXh0LnNoYXJlZC1ydW50aW1lJ1xuaW1wb3J0IHsgd2Fybk9uY2UgfSBmcm9tICcuLi9zaGFyZWQvbGliL3V0aWxzL3dhcm4tb25jZSdcbmltcG9ydCB7IFJvdXRlckNvbnRleHQgfSBmcm9tICcuLi9zaGFyZWQvbGliL3JvdXRlci1jb250ZXh0LnNoYXJlZC1ydW50aW1lJ1xuXG4vLyBAdHMtaWdub3JlIC0gVGhpcyBpcyByZXBsYWNlZCBieSB3ZWJwYWNrIGFsaWFzXG5pbXBvcnQgZGVmYXVsdExvYWRlciBmcm9tICduZXh0L2Rpc3Qvc2hhcmVkL2xpYi9pbWFnZS1sb2FkZXInXG5pbXBvcnQgeyB1c2VNZXJnZWRSZWYgfSBmcm9tICcuL3VzZS1tZXJnZWQtcmVmJ1xuXG4vLyBUaGlzIGlzIHJlcGxhY2VkIGJ5IHdlYnBhY2sgZGVmaW5lIHBsdWdpblxuY29uc3QgY29uZmlnRW52ID0gcHJvY2Vzcy5lbnYuX19ORVhUX0lNQUdFX09QVFMgYXMgYW55IGFzIEltYWdlQ29uZmlnQ29tcGxldGVcblxuaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gIDsoZ2xvYmFsVGhpcyBhcyBhbnkpLl9fTkVYVF9JTUFHRV9JTVBPUlRFRCA9IHRydWVcbn1cblxuZXhwb3J0IHR5cGUgeyBJbWFnZUxvYWRlclByb3BzIH1cbmV4cG9ydCB0eXBlIEltYWdlTG9hZGVyID0gKHA6IEltYWdlTG9hZGVyUHJvcHMpID0+IHN0cmluZ1xuXG50eXBlIEltZ0VsZW1lbnRXaXRoRGF0YVByb3AgPSBIVE1MSW1hZ2VFbGVtZW50ICYge1xuICAnZGF0YS1sb2FkZWQtc3JjJzogc3RyaW5nIHwgdW5kZWZpbmVkXG59XG5cbnR5cGUgSW1hZ2VFbGVtZW50UHJvcHMgPSBJbWdQcm9wcyAmIHtcbiAgdW5vcHRpbWl6ZWQ6IGJvb2xlYW5cbiAgcGxhY2Vob2xkZXI6IFBsYWNlaG9sZGVyVmFsdWVcbiAgb25Mb2FkUmVmOiBSZWFjdC5NdXRhYmxlUmVmT2JqZWN0PE9uTG9hZCB8IHVuZGVmaW5lZD5cbiAgb25Mb2FkaW5nQ29tcGxldGVSZWY6IFJlYWN0Lk11dGFibGVSZWZPYmplY3Q8T25Mb2FkaW5nQ29tcGxldGUgfCB1bmRlZmluZWQ+XG4gIHNldEJsdXJDb21wbGV0ZTogKGI6IGJvb2xlYW4pID0+IHZvaWRcbiAgc2V0U2hvd0FsdFRleHQ6IChiOiBib29sZWFuKSA9PiB2b2lkXG4gIHNpemVzSW5wdXQ6IHN0cmluZyB8IHVuZGVmaW5lZFxufVxuXG4vLyBTZWUgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xLzM5Nzc3ODMzLzI2NjUzNSBmb3Igd2h5IHdlIHVzZSB0aGlzIHJlZlxuLy8gaGFuZGxlciBpbnN0ZWFkIG9mIHRoZSBpbWcncyBvbkxvYWQgYXR0cmlidXRlLlxuZnVuY3Rpb24gaGFuZGxlTG9hZGluZyhcbiAgaW1nOiBJbWdFbGVtZW50V2l0aERhdGFQcm9wLFxuICBwbGFjZWhvbGRlcjogUGxhY2Vob2xkZXJWYWx1ZSxcbiAgb25Mb2FkUmVmOiBSZWFjdC5NdXRhYmxlUmVmT2JqZWN0PE9uTG9hZCB8IHVuZGVmaW5lZD4sXG4gIG9uTG9hZGluZ0NvbXBsZXRlUmVmOiBSZWFjdC5NdXRhYmxlUmVmT2JqZWN0PE9uTG9hZGluZ0NvbXBsZXRlIHwgdW5kZWZpbmVkPixcbiAgc2V0Qmx1ckNvbXBsZXRlOiAoYjogYm9vbGVhbikgPT4gdm9pZCxcbiAgdW5vcHRpbWl6ZWQ6IGJvb2xlYW4sXG4gIHNpemVzSW5wdXQ6IHN0cmluZyB8IHVuZGVmaW5lZFxuKSB7XG4gIGNvbnN0IHNyYyA9IGltZz8uc3JjXG4gIGlmICghaW1nIHx8IGltZ1snZGF0YS1sb2FkZWQtc3JjJ10gPT09IHNyYykge1xuICAgIHJldHVyblxuICB9XG4gIGltZ1snZGF0YS1sb2FkZWQtc3JjJ10gPSBzcmNcbiAgY29uc3QgcCA9ICdkZWNvZGUnIGluIGltZyA/IGltZy5kZWNvZGUoKSA6IFByb21pc2UucmVzb2x2ZSgpXG4gIHAuY2F0Y2goKCkgPT4ge30pLnRoZW4oKCkgPT4ge1xuICAgIGlmICghaW1nLnBhcmVudEVsZW1lbnQgfHwgIWltZy5pc0Nvbm5lY3RlZCkge1xuICAgICAgLy8gRXhpdCBlYXJseSBpbiBjYXNlIG9mIHJhY2UgY29uZGl0aW9uOlxuICAgICAgLy8gLSBvbmxvYWQoKSBpcyBjYWxsZWRcbiAgICAgIC8vIC0gZGVjb2RlKCkgaXMgY2FsbGVkIGJ1dCBpbmNvbXBsZXRlXG4gICAgICAvLyAtIHVubW91bnQgaXMgY2FsbGVkXG4gICAgICAvLyAtIGRlY29kZSgpIGNvbXBsZXRlc1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGlmIChwbGFjZWhvbGRlciAhPT0gJ2VtcHR5Jykge1xuICAgICAgc2V0Qmx1ckNvbXBsZXRlKHRydWUpXG4gICAgfVxuICAgIGlmIChvbkxvYWRSZWY/LmN1cnJlbnQpIHtcbiAgICAgIC8vIFNpbmNlIHdlIGRvbid0IGhhdmUgdGhlIFN5bnRoZXRpY0V2ZW50IGhlcmUsXG4gICAgICAvLyB3ZSBtdXN0IGNyZWF0ZSBvbmUgd2l0aCB0aGUgc2FtZSBzaGFwZS5cbiAgICAgIC8vIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvZXZlbnRzLmh0bWxcbiAgICAgIGNvbnN0IGV2ZW50ID0gbmV3IEV2ZW50KCdsb2FkJylcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShldmVudCwgJ3RhcmdldCcsIHsgd3JpdGFibGU6IGZhbHNlLCB2YWx1ZTogaW1nIH0pXG4gICAgICBsZXQgcHJldmVudGVkID0gZmFsc2VcbiAgICAgIGxldCBzdG9wcGVkID0gZmFsc2VcbiAgICAgIG9uTG9hZFJlZi5jdXJyZW50KHtcbiAgICAgICAgLi4uZXZlbnQsXG4gICAgICAgIG5hdGl2ZUV2ZW50OiBldmVudCxcbiAgICAgICAgY3VycmVudFRhcmdldDogaW1nLFxuICAgICAgICB0YXJnZXQ6IGltZyxcbiAgICAgICAgaXNEZWZhdWx0UHJldmVudGVkOiAoKSA9PiBwcmV2ZW50ZWQsXG4gICAgICAgIGlzUHJvcGFnYXRpb25TdG9wcGVkOiAoKSA9PiBzdG9wcGVkLFxuICAgICAgICBwZXJzaXN0OiAoKSA9PiB7fSxcbiAgICAgICAgcHJldmVudERlZmF1bHQ6ICgpID0+IHtcbiAgICAgICAgICBwcmV2ZW50ZWQgPSB0cnVlXG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKVxuICAgICAgICB9LFxuICAgICAgICBzdG9wUHJvcGFnYXRpb246ICgpID0+IHtcbiAgICAgICAgICBzdG9wcGVkID0gdHJ1ZVxuICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpXG4gICAgICAgIH0sXG4gICAgICB9KVxuICAgIH1cbiAgICBpZiAob25Mb2FkaW5nQ29tcGxldGVSZWY/LmN1cnJlbnQpIHtcbiAgICAgIG9uTG9hZGluZ0NvbXBsZXRlUmVmLmN1cnJlbnQoaW1nKVxuICAgIH1cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgY29uc3Qgb3JpZ1NyYyA9IG5ldyBVUkwoc3JjLCAnaHR0cDovL24nKS5zZWFyY2hQYXJhbXMuZ2V0KCd1cmwnKSB8fCBzcmNcbiAgICAgIGlmIChpbWcuZ2V0QXR0cmlidXRlKCdkYXRhLW5pbWcnKSA9PT0gJ2ZpbGwnKSB7XG4gICAgICAgIGlmICghdW5vcHRpbWl6ZWQgJiYgKCFzaXplc0lucHV0IHx8IHNpemVzSW5wdXQgPT09ICcxMDB2dycpKSB7XG4gICAgICAgICAgbGV0IHdpZHRoVmlld3BvcnRSYXRpbyA9XG4gICAgICAgICAgICBpbWcuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggLyB3aW5kb3cuaW5uZXJXaWR0aFxuICAgICAgICAgIGlmICh3aWR0aFZpZXdwb3J0UmF0aW8gPCAwLjYpIHtcbiAgICAgICAgICAgIGlmIChzaXplc0lucHV0ID09PSAnMTAwdncnKSB7XG4gICAgICAgICAgICAgIHdhcm5PbmNlKFxuICAgICAgICAgICAgICAgIGBJbWFnZSB3aXRoIHNyYyBcIiR7b3JpZ1NyY31cIiBoYXMgXCJmaWxsXCIgcHJvcCBhbmQgXCJzaXplc1wiIHByb3Agb2YgXCIxMDB2d1wiLCBidXQgaW1hZ2UgaXMgbm90IHJlbmRlcmVkIGF0IGZ1bGwgdmlld3BvcnQgd2lkdGguIFBsZWFzZSBhZGp1c3QgXCJzaXplc1wiIHRvIGltcHJvdmUgcGFnZSBwZXJmb3JtYW5jZS4gUmVhZCBtb3JlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9hcGktcmVmZXJlbmNlL25leHQvaW1hZ2Ujc2l6ZXNgXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHdhcm5PbmNlKFxuICAgICAgICAgICAgICAgIGBJbWFnZSB3aXRoIHNyYyBcIiR7b3JpZ1NyY31cIiBoYXMgXCJmaWxsXCIgYnV0IGlzIG1pc3NpbmcgXCJzaXplc1wiIHByb3AuIFBsZWFzZSBhZGQgaXQgdG8gaW1wcm92ZSBwYWdlIHBlcmZvcm1hbmNlLiBSZWFkIG1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwaS1yZWZlcmVuY2UvbmV4dC9pbWFnZSNzaXplc2BcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaW1nLnBhcmVudEVsZW1lbnQpIHtcbiAgICAgICAgICBjb25zdCB7IHBvc2l0aW9uIH0gPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShpbWcucGFyZW50RWxlbWVudClcbiAgICAgICAgICBjb25zdCB2YWxpZCA9IFsnYWJzb2x1dGUnLCAnZml4ZWQnLCAncmVsYXRpdmUnXVxuICAgICAgICAgIGlmICghdmFsaWQuaW5jbHVkZXMocG9zaXRpb24pKSB7XG4gICAgICAgICAgICB3YXJuT25jZShcbiAgICAgICAgICAgICAgYEltYWdlIHdpdGggc3JjIFwiJHtvcmlnU3JjfVwiIGhhcyBcImZpbGxcIiBhbmQgcGFyZW50IGVsZW1lbnQgd2l0aCBpbnZhbGlkIFwicG9zaXRpb25cIi4gUHJvdmlkZWQgXCIke3Bvc2l0aW9ufVwiIHNob3VsZCBiZSBvbmUgb2YgJHt2YWxpZFxuICAgICAgICAgICAgICAgIC5tYXAoU3RyaW5nKVxuICAgICAgICAgICAgICAgIC5qb2luKCcsJyl9LmBcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGltZy5oZWlnaHQgPT09IDApIHtcbiAgICAgICAgICB3YXJuT25jZShcbiAgICAgICAgICAgIGBJbWFnZSB3aXRoIHNyYyBcIiR7b3JpZ1NyY31cIiBoYXMgXCJmaWxsXCIgYW5kIGEgaGVpZ2h0IHZhbHVlIG9mIDAuIFRoaXMgaXMgbGlrZWx5IGJlY2F1c2UgdGhlIHBhcmVudCBlbGVtZW50IG9mIHRoZSBpbWFnZSBoYXMgbm90IGJlZW4gc3R5bGVkIHRvIGhhdmUgYSBzZXQgaGVpZ2h0LmBcbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgaGVpZ2h0TW9kaWZpZWQgPVxuICAgICAgICBpbWcuaGVpZ2h0LnRvU3RyaW5nKCkgIT09IGltZy5nZXRBdHRyaWJ1dGUoJ2hlaWdodCcpXG4gICAgICBjb25zdCB3aWR0aE1vZGlmaWVkID0gaW1nLndpZHRoLnRvU3RyaW5nKCkgIT09IGltZy5nZXRBdHRyaWJ1dGUoJ3dpZHRoJylcbiAgICAgIGlmIChcbiAgICAgICAgKGhlaWdodE1vZGlmaWVkICYmICF3aWR0aE1vZGlmaWVkKSB8fFxuICAgICAgICAoIWhlaWdodE1vZGlmaWVkICYmIHdpZHRoTW9kaWZpZWQpXG4gICAgICApIHtcbiAgICAgICAgd2Fybk9uY2UoXG4gICAgICAgICAgYEltYWdlIHdpdGggc3JjIFwiJHtvcmlnU3JjfVwiIGhhcyBlaXRoZXIgd2lkdGggb3IgaGVpZ2h0IG1vZGlmaWVkLCBidXQgbm90IHRoZSBvdGhlci4gSWYgeW91IHVzZSBDU1MgdG8gY2hhbmdlIHRoZSBzaXplIG9mIHlvdXIgaW1hZ2UsIGFsc28gaW5jbHVkZSB0aGUgc3R5bGVzICd3aWR0aDogXCJhdXRvXCInIG9yICdoZWlnaHQ6IFwiYXV0b1wiJyB0byBtYWludGFpbiB0aGUgYXNwZWN0IHJhdGlvLmBcbiAgICAgICAgKVxuICAgICAgfVxuICAgIH1cbiAgfSlcbn1cblxuZnVuY3Rpb24gZ2V0RHluYW1pY1Byb3BzKFxuICBmZXRjaFByaW9yaXR5Pzogc3RyaW5nXG4pOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmcgfCB1bmRlZmluZWQ+IHtcbiAgaWYgKEJvb2xlYW4odXNlKSkge1xuICAgIC8vIEluIFJlYWN0IDE5LjAuMCBvciBuZXdlciwgd2UgbXVzdCB1c2UgY2FtZWxDYXNlXG4gICAgLy8gcHJvcCB0byBhdm9pZCBcIldhcm5pbmc6IEludmFsaWQgRE9NIHByb3BlcnR5XCIuXG4gICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzI1OTI3XG4gICAgcmV0dXJuIHsgZmV0Y2hQcmlvcml0eSB9XG4gIH1cbiAgLy8gSW4gUmVhY3QgMTguMi4wIG9yIG9sZGVyLCB3ZSBtdXN0IHVzZSBsb3dlcmNhc2UgcHJvcFxuICAvLyB0byBhdm9pZCBcIldhcm5pbmc6IEludmFsaWQgRE9NIHByb3BlcnR5XCIuXG4gIHJldHVybiB7IGZldGNocHJpb3JpdHk6IGZldGNoUHJpb3JpdHkgfVxufVxuXG5jb25zdCBJbWFnZUVsZW1lbnQgPSBmb3J3YXJkUmVmPEhUTUxJbWFnZUVsZW1lbnQgfCBudWxsLCBJbWFnZUVsZW1lbnRQcm9wcz4oXG4gIChcbiAgICB7XG4gICAgICBzcmMsXG4gICAgICBzcmNTZXQsXG4gICAgICBzaXplcyxcbiAgICAgIGhlaWdodCxcbiAgICAgIHdpZHRoLFxuICAgICAgZGVjb2RpbmcsXG4gICAgICBjbGFzc05hbWUsXG4gICAgICBzdHlsZSxcbiAgICAgIGZldGNoUHJpb3JpdHksXG4gICAgICBwbGFjZWhvbGRlcixcbiAgICAgIGxvYWRpbmcsXG4gICAgICB1bm9wdGltaXplZCxcbiAgICAgIGZpbGwsXG4gICAgICBvbkxvYWRSZWYsXG4gICAgICBvbkxvYWRpbmdDb21wbGV0ZVJlZixcbiAgICAgIHNldEJsdXJDb21wbGV0ZSxcbiAgICAgIHNldFNob3dBbHRUZXh0LFxuICAgICAgc2l6ZXNJbnB1dCxcbiAgICAgIG9uTG9hZCxcbiAgICAgIG9uRXJyb3IsXG4gICAgICAuLi5yZXN0XG4gICAgfSxcbiAgICBmb3J3YXJkZWRSZWZcbiAgKSA9PiB7XG4gICAgY29uc3Qgb3duUmVmID0gdXNlQ2FsbGJhY2soXG4gICAgICAoaW1nOiBJbWdFbGVtZW50V2l0aERhdGFQcm9wIHwgbnVsbCkgPT4ge1xuICAgICAgICBpZiAoIWltZykge1xuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIGlmIChvbkVycm9yKSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGltYWdlIGhhcyBhbiBlcnJvciBiZWZvcmUgcmVhY3QgaHlkcmF0ZXMsIHRoZW4gdGhlIGVycm9yIGlzIGxvc3QuXG4gICAgICAgICAgLy8gVGhlIHdvcmthcm91bmQgaXMgdG8gd2FpdCB1bnRpbCB0aGUgaW1hZ2UgaXMgbW91bnRlZCB3aGljaCBpcyBhZnRlciBoeWRyYXRpb24sXG4gICAgICAgICAgLy8gdGhlbiB3ZSBzZXQgdGhlIHNyYyBhZ2FpbiB0byB0cmlnZ2VyIHRoZSBlcnJvciBoYW5kbGVyIChpZiB0aGVyZSB3YXMgYW4gZXJyb3IpLlxuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWFzc2lnblxuICAgICAgICAgIGltZy5zcmMgPSBpbWcuc3JjXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBpZiAoIXNyYykge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgSW1hZ2UgaXMgbWlzc2luZyByZXF1aXJlZCBcInNyY1wiIHByb3BlcnR5OmAsIGltZylcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGltZy5nZXRBdHRyaWJ1dGUoJ2FsdCcpID09PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBgSW1hZ2UgaXMgbWlzc2luZyByZXF1aXJlZCBcImFsdFwiIHByb3BlcnR5LiBQbGVhc2UgYWRkIEFsdGVybmF0aXZlIFRleHQgdG8gZGVzY3JpYmUgdGhlIGltYWdlIGZvciBzY3JlZW4gcmVhZGVycyBhbmQgc2VhcmNoIGVuZ2luZXMuYFxuICAgICAgICAgICAgKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaW1nLmNvbXBsZXRlKSB7XG4gICAgICAgICAgaGFuZGxlTG9hZGluZyhcbiAgICAgICAgICAgIGltZyxcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyLFxuICAgICAgICAgICAgb25Mb2FkUmVmLFxuICAgICAgICAgICAgb25Mb2FkaW5nQ29tcGxldGVSZWYsXG4gICAgICAgICAgICBzZXRCbHVyQ29tcGxldGUsXG4gICAgICAgICAgICB1bm9wdGltaXplZCxcbiAgICAgICAgICAgIHNpemVzSW5wdXRcbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBbXG4gICAgICAgIHNyYyxcbiAgICAgICAgcGxhY2Vob2xkZXIsXG4gICAgICAgIG9uTG9hZFJlZixcbiAgICAgICAgb25Mb2FkaW5nQ29tcGxldGVSZWYsXG4gICAgICAgIHNldEJsdXJDb21wbGV0ZSxcbiAgICAgICAgb25FcnJvcixcbiAgICAgICAgdW5vcHRpbWl6ZWQsXG4gICAgICAgIHNpemVzSW5wdXQsXG4gICAgICBdXG4gICAgKVxuXG4gICAgY29uc3QgcmVmID0gdXNlTWVyZ2VkUmVmKGZvcndhcmRlZFJlZiwgb3duUmVmKVxuXG4gICAgcmV0dXJuIChcbiAgICAgIDxpbWdcbiAgICAgICAgey4uLnJlc3R9XG4gICAgICAgIHsuLi5nZXREeW5hbWljUHJvcHMoZmV0Y2hQcmlvcml0eSl9XG4gICAgICAgIC8vIEl0J3MgaW50ZW5kZWQgdG8ga2VlcCBgbG9hZGluZ2AgYmVmb3JlIGBzcmNgIGJlY2F1c2UgUmVhY3QgdXBkYXRlc1xuICAgICAgICAvLyBwcm9wcyBpbiBvcmRlciB3aGljaCBjYXVzZXMgU2FmYXJpL0ZpcmVmb3ggdG8gbm90IGxhenkgbG9hZCBwcm9wZXJseS5cbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMjU4ODNcbiAgICAgICAgbG9hZGluZz17bG9hZGluZ31cbiAgICAgICAgd2lkdGg9e3dpZHRofVxuICAgICAgICBoZWlnaHQ9e2hlaWdodH1cbiAgICAgICAgZGVjb2Rpbmc9e2RlY29kaW5nfVxuICAgICAgICBkYXRhLW5pbWc9e2ZpbGwgPyAnZmlsbCcgOiAnMSd9XG4gICAgICAgIGNsYXNzTmFtZT17Y2xhc3NOYW1lfVxuICAgICAgICBzdHlsZT17c3R5bGV9XG4gICAgICAgIC8vIEl0J3MgaW50ZW5kZWQgdG8ga2VlcCBgc3JjYCB0aGUgbGFzdCBhdHRyaWJ1dGUgYmVjYXVzZSBSZWFjdCB1cGRhdGVzXG4gICAgICAgIC8vIGF0dHJpYnV0ZXMgaW4gb3JkZXIuIElmIHdlIGtlZXAgYHNyY2AgdGhlIGZpcnN0IG9uZSwgU2FmYXJpIHdpbGxcbiAgICAgICAgLy8gaW1tZWRpYXRlbHkgc3RhcnQgdG8gZmV0Y2ggYHNyY2AsIGJlZm9yZSBgc2l6ZXNgIGFuZCBgc3JjU2V0YCBhcmUgZXZlblxuICAgICAgICAvLyB1cGRhdGVkIGJ5IFJlYWN0LiBUaGF0IGNhdXNlcyBtdWx0aXBsZSB1bm5lY2Vzc2FyeSByZXF1ZXN0cyBpZiBgc3JjU2V0YFxuICAgICAgICAvLyBhbmQgYHNpemVzYCBhcmUgZGVmaW5lZC5cbiAgICAgICAgLy8gVGhpcyBidWcgY2Fubm90IGJlIHJlcHJvZHVjZWQgaW4gQ2hyb21lIG9yIEZpcmVmb3guXG4gICAgICAgIHNpemVzPXtzaXplc31cbiAgICAgICAgc3JjU2V0PXtzcmNTZXR9XG4gICAgICAgIHNyYz17c3JjfVxuICAgICAgICByZWY9e3JlZn1cbiAgICAgICAgb25Mb2FkPXsoZXZlbnQpID0+IHtcbiAgICAgICAgICBjb25zdCBpbWcgPSBldmVudC5jdXJyZW50VGFyZ2V0IGFzIEltZ0VsZW1lbnRXaXRoRGF0YVByb3BcbiAgICAgICAgICBoYW5kbGVMb2FkaW5nKFxuICAgICAgICAgICAgaW1nLFxuICAgICAgICAgICAgcGxhY2Vob2xkZXIsXG4gICAgICAgICAgICBvbkxvYWRSZWYsXG4gICAgICAgICAgICBvbkxvYWRpbmdDb21wbGV0ZVJlZixcbiAgICAgICAgICAgIHNldEJsdXJDb21wbGV0ZSxcbiAgICAgICAgICAgIHVub3B0aW1pemVkLFxuICAgICAgICAgICAgc2l6ZXNJbnB1dFxuICAgICAgICAgIClcbiAgICAgICAgfX1cbiAgICAgICAgb25FcnJvcj17KGV2ZW50KSA9PiB7XG4gICAgICAgICAgLy8gaWYgdGhlIHJlYWwgaW1hZ2UgZmFpbHMgdG8gbG9hZCwgdGhpcyB3aWxsIGVuc3VyZSBcImFsdFwiIGlzIHZpc2libGVcbiAgICAgICAgICBzZXRTaG93QWx0VGV4dCh0cnVlKVxuICAgICAgICAgIGlmIChwbGFjZWhvbGRlciAhPT0gJ2VtcHR5Jykge1xuICAgICAgICAgICAgLy8gSWYgdGhlIHJlYWwgaW1hZ2UgZmFpbHMgdG8gbG9hZCwgdGhpcyB3aWxsIHN0aWxsIHJlbW92ZSB0aGUgcGxhY2Vob2xkZXIuXG4gICAgICAgICAgICBzZXRCbHVyQ29tcGxldGUodHJ1ZSlcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9uRXJyb3IpIHtcbiAgICAgICAgICAgIG9uRXJyb3IoZXZlbnQpXG4gICAgICAgICAgfVxuICAgICAgICB9fVxuICAgICAgLz5cbiAgICApXG4gIH1cbilcblxuZnVuY3Rpb24gSW1hZ2VQcmVsb2FkKHtcbiAgaXNBcHBSb3V0ZXIsXG4gIGltZ0F0dHJpYnV0ZXMsXG59OiB7XG4gIGlzQXBwUm91dGVyOiBib29sZWFuXG4gIGltZ0F0dHJpYnV0ZXM6IEltZ1Byb3BzXG59KSB7XG4gIGNvbnN0IG9wdHMgPSB7XG4gICAgYXM6ICdpbWFnZScsXG4gICAgaW1hZ2VTcmNTZXQ6IGltZ0F0dHJpYnV0ZXMuc3JjU2V0LFxuICAgIGltYWdlU2l6ZXM6IGltZ0F0dHJpYnV0ZXMuc2l6ZXMsXG4gICAgY3Jvc3NPcmlnaW46IGltZ0F0dHJpYnV0ZXMuY3Jvc3NPcmlnaW4sXG4gICAgcmVmZXJyZXJQb2xpY3k6IGltZ0F0dHJpYnV0ZXMucmVmZXJyZXJQb2xpY3ksXG4gICAgLi4uZ2V0RHluYW1pY1Byb3BzKGltZ0F0dHJpYnV0ZXMuZmV0Y2hQcmlvcml0eSksXG4gIH1cblxuICBpZiAoaXNBcHBSb3V0ZXIgJiYgUmVhY3RET00ucHJlbG9hZCkge1xuICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC8yNjk0MFxuICAgIFJlYWN0RE9NLnByZWxvYWQoXG4gICAgICBpbWdBdHRyaWJ1dGVzLnNyYyxcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgVE9ETzogdXBncmFkZSB0byBgQHR5cGVzL3JlYWN0LWRvbUAxOC4zLnhgXG4gICAgICBvcHRzXG4gICAgKVxuICAgIHJldHVybiBudWxsXG4gIH1cblxuICByZXR1cm4gKFxuICAgIDxIZWFkPlxuICAgICAgPGxpbmtcbiAgICAgICAga2V5PXtcbiAgICAgICAgICAnX19uaW1nLScgK1xuICAgICAgICAgIGltZ0F0dHJpYnV0ZXMuc3JjICtcbiAgICAgICAgICBpbWdBdHRyaWJ1dGVzLnNyY1NldCArXG4gICAgICAgICAgaW1nQXR0cmlidXRlcy5zaXplc1xuICAgICAgICB9XG4gICAgICAgIHJlbD1cInByZWxvYWRcIlxuICAgICAgICAvLyBOb3RlIGhvdyB3ZSBvbWl0IHRoZSBgaHJlZmAgYXR0cmlidXRlLCBhcyBpdCB3b3VsZCBvbmx5IGJlIHJlbGV2YW50XG4gICAgICAgIC8vIGZvciBicm93c2VycyB0aGF0IGRvIG5vdCBzdXBwb3J0IGBpbWFnZXNyY3NldGAsIGFuZCBpbiB0aG9zZSBjYXNlc1xuICAgICAgICAvLyBpdCB3b3VsZCBjYXVzZSB0aGUgaW5jb3JyZWN0IGltYWdlIHRvIGJlIHByZWxvYWRlZC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc2VtYW50aWNzLmh0bWwjYXR0ci1saW5rLWltYWdlc3Jjc2V0XG4gICAgICAgIGhyZWY9e2ltZ0F0dHJpYnV0ZXMuc3JjU2V0ID8gdW5kZWZpbmVkIDogaW1nQXR0cmlidXRlcy5zcmN9XG4gICAgICAgIHsuLi5vcHRzfVxuICAgICAgLz5cbiAgICA8L0hlYWQ+XG4gIClcbn1cblxuLyoqXG4gKiBUaGUgYEltYWdlYCBjb21wb25lbnQgaXMgdXNlZCB0byBvcHRpbWl6ZSBpbWFnZXMuXG4gKlxuICogUmVhZCBtb3JlOiBbTmV4dC5qcyBkb2NzOiBgSW1hZ2VgXShodHRwczovL25leHRqcy5vcmcvZG9jcy9hcHAvYXBpLXJlZmVyZW5jZS9jb21wb25lbnRzL2ltYWdlKVxuICovXG5leHBvcnQgY29uc3QgSW1hZ2UgPSBmb3J3YXJkUmVmPEhUTUxJbWFnZUVsZW1lbnQgfCBudWxsLCBJbWFnZVByb3BzPihcbiAgKHByb3BzLCBmb3J3YXJkZWRSZWYpID0+IHtcbiAgICBjb25zdCBwYWdlc1JvdXRlciA9IHVzZUNvbnRleHQoUm91dGVyQ29udGV4dClcbiAgICAvLyBXZSdyZSBpbiB0aGUgYXBwIGRpcmVjdG9yeSBpZiB0aGVyZSBpcyBubyBwYWdlcyByb3V0ZXIuXG4gICAgY29uc3QgaXNBcHBSb3V0ZXIgPSAhcGFnZXNSb3V0ZXJcblxuICAgIGNvbnN0IGNvbmZpZ0NvbnRleHQgPSB1c2VDb250ZXh0KEltYWdlQ29uZmlnQ29udGV4dClcbiAgICBjb25zdCBjb25maWcgPSB1c2VNZW1vKCgpID0+IHtcbiAgICAgIGNvbnN0IGMgPSBjb25maWdFbnYgfHwgY29uZmlnQ29udGV4dCB8fCBpbWFnZUNvbmZpZ0RlZmF1bHRcbiAgICAgIGNvbnN0IGFsbFNpemVzID0gWy4uLmMuZGV2aWNlU2l6ZXMsIC4uLmMuaW1hZ2VTaXplc10uc29ydCgoYSwgYikgPT4gYSAtIGIpXG4gICAgICBjb25zdCBkZXZpY2VTaXplcyA9IGMuZGV2aWNlU2l6ZXMuc29ydCgoYSwgYikgPT4gYSAtIGIpXG4gICAgICBjb25zdCBxdWFsaXRpZXMgPSBjLnF1YWxpdGllcz8uc29ydCgoYSwgYikgPT4gYSAtIGIpXG4gICAgICByZXR1cm4geyAuLi5jLCBhbGxTaXplcywgZGV2aWNlU2l6ZXMsIHF1YWxpdGllcyB9XG4gICAgfSwgW2NvbmZpZ0NvbnRleHRdKVxuXG4gICAgY29uc3QgeyBvbkxvYWQsIG9uTG9hZGluZ0NvbXBsZXRlIH0gPSBwcm9wc1xuICAgIGNvbnN0IG9uTG9hZFJlZiA9IHVzZVJlZihvbkxvYWQpXG5cbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgb25Mb2FkUmVmLmN1cnJlbnQgPSBvbkxvYWRcbiAgICB9LCBbb25Mb2FkXSlcblxuICAgIGNvbnN0IG9uTG9hZGluZ0NvbXBsZXRlUmVmID0gdXNlUmVmKG9uTG9hZGluZ0NvbXBsZXRlKVxuXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgIG9uTG9hZGluZ0NvbXBsZXRlUmVmLmN1cnJlbnQgPSBvbkxvYWRpbmdDb21wbGV0ZVxuICAgIH0sIFtvbkxvYWRpbmdDb21wbGV0ZV0pXG5cbiAgICBjb25zdCBbYmx1ckNvbXBsZXRlLCBzZXRCbHVyQ29tcGxldGVdID0gdXNlU3RhdGUoZmFsc2UpXG4gICAgY29uc3QgW3Nob3dBbHRUZXh0LCBzZXRTaG93QWx0VGV4dF0gPSB1c2VTdGF0ZShmYWxzZSlcblxuICAgIGNvbnN0IHsgcHJvcHM6IGltZ0F0dHJpYnV0ZXMsIG1ldGE6IGltZ01ldGEgfSA9IGdldEltZ1Byb3BzKHByb3BzLCB7XG4gICAgICBkZWZhdWx0TG9hZGVyLFxuICAgICAgaW1nQ29uZjogY29uZmlnLFxuICAgICAgYmx1ckNvbXBsZXRlLFxuICAgICAgc2hvd0FsdFRleHQsXG4gICAgfSlcblxuICAgIHJldHVybiAoXG4gICAgICA8PlxuICAgICAgICB7XG4gICAgICAgICAgPEltYWdlRWxlbWVudFxuICAgICAgICAgICAgey4uLmltZ0F0dHJpYnV0ZXN9XG4gICAgICAgICAgICB1bm9wdGltaXplZD17aW1nTWV0YS51bm9wdGltaXplZH1cbiAgICAgICAgICAgIHBsYWNlaG9sZGVyPXtpbWdNZXRhLnBsYWNlaG9sZGVyfVxuICAgICAgICAgICAgZmlsbD17aW1nTWV0YS5maWxsfVxuICAgICAgICAgICAgb25Mb2FkUmVmPXtvbkxvYWRSZWZ9XG4gICAgICAgICAgICBvbkxvYWRpbmdDb21wbGV0ZVJlZj17b25Mb2FkaW5nQ29tcGxldGVSZWZ9XG4gICAgICAgICAgICBzZXRCbHVyQ29tcGxldGU9e3NldEJsdXJDb21wbGV0ZX1cbiAgICAgICAgICAgIHNldFNob3dBbHRUZXh0PXtzZXRTaG93QWx0VGV4dH1cbiAgICAgICAgICAgIHNpemVzSW5wdXQ9e3Byb3BzLnNpemVzfVxuICAgICAgICAgICAgcmVmPXtmb3J3YXJkZWRSZWZ9XG4gICAgICAgICAgLz5cbiAgICAgICAgfVxuICAgICAgICB7aW1nTWV0YS5wcmlvcml0eSA/IChcbiAgICAgICAgICA8SW1hZ2VQcmVsb2FkXG4gICAgICAgICAgICBpc0FwcFJvdXRlcj17aXNBcHBSb3V0ZXJ9XG4gICAgICAgICAgICBpbWdBdHRyaWJ1dGVzPXtpbWdBdHRyaWJ1dGVzfVxuICAgICAgICAgIC8+XG4gICAgICAgICkgOiBudWxsfVxuICAgICAgPC8+XG4gICAgKVxuICB9XG4pXG4iXSwibmFtZXMiOlsiSW1hZ2UiLCJjb25maWdFbnYiLCJwcm9jZXNzIiwiZW52IiwiX19ORVhUX0lNQUdFX09QVFMiLCJ3aW5kb3ciLCJnbG9iYWxUaGlzIiwiX19ORVhUX0lNQUdFX0lNUE9SVEVEIiwiaGFuZGxlTG9hZGluZyIsImltZyIsInBsYWNlaG9sZGVyIiwib25Mb2FkUmVmIiwib25Mb2FkaW5nQ29tcGxldGVSZWYiLCJzZXRCbHVyQ29tcGxldGUiLCJ1bm9wdGltaXplZCIsInNpemVzSW5wdXQiLCJzcmMiLCJwIiwiZGVjb2RlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJjYXRjaCIsInRoZW4iLCJwYXJlbnRFbGVtZW50IiwiaXNDb25uZWN0ZWQiLCJjdXJyZW50IiwiZXZlbnQiLCJFdmVudCIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5Iiwid3JpdGFibGUiLCJ2YWx1ZSIsInByZXZlbnRlZCIsInN0b3BwZWQiLCJuYXRpdmVFdmVudCIsImN1cnJlbnRUYXJnZXQiLCJ0YXJnZXQiLCJpc0RlZmF1bHRQcmV2ZW50ZWQiLCJpc1Byb3BhZ2F0aW9uU3RvcHBlZCIsInBlcnNpc3QiLCJwcmV2ZW50RGVmYXVsdCIsInN0b3BQcm9wYWdhdGlvbiIsIk5PREVfRU5WIiwib3JpZ1NyYyIsIlVSTCIsInNlYXJjaFBhcmFtcyIsImdldCIsImdldEF0dHJpYnV0ZSIsIndpZHRoVmlld3BvcnRSYXRpbyIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsIndpZHRoIiwiaW5uZXJXaWR0aCIsIndhcm5PbmNlIiwicG9zaXRpb24iLCJnZXRDb21wdXRlZFN0eWxlIiwidmFsaWQiLCJpbmNsdWRlcyIsIm1hcCIsIlN0cmluZyIsImpvaW4iLCJoZWlnaHQiLCJoZWlnaHRNb2RpZmllZCIsInRvU3RyaW5nIiwid2lkdGhNb2RpZmllZCIsImdldER5bmFtaWNQcm9wcyIsImZldGNoUHJpb3JpdHkiLCJCb29sZWFuIiwidXNlIiwiZmV0Y2hwcmlvcml0eSIsIkltYWdlRWxlbWVudCIsImZvcndhcmRSZWYiLCJmb3J3YXJkZWRSZWYiLCJzcmNTZXQiLCJzaXplcyIsImRlY29kaW5nIiwiY2xhc3NOYW1lIiwic3R5bGUiLCJsb2FkaW5nIiwiZmlsbCIsInNldFNob3dBbHRUZXh0Iiwib25Mb2FkIiwib25FcnJvciIsInJlc3QiLCJvd25SZWYiLCJ1c2VDYWxsYmFjayIsImNvbnNvbGUiLCJlcnJvciIsImNvbXBsZXRlIiwicmVmIiwidXNlTWVyZ2VkUmVmIiwiZGF0YS1uaW1nIiwiSW1hZ2VQcmVsb2FkIiwiaXNBcHBSb3V0ZXIiLCJpbWdBdHRyaWJ1dGVzIiwib3B0cyIsImFzIiwiaW1hZ2VTcmNTZXQiLCJpbWFnZVNpemVzIiwiY3Jvc3NPcmlnaW4iLCJyZWZlcnJlclBvbGljeSIsIlJlYWN0RE9NIiwicHJlbG9hZCIsIkhlYWQiLCJsaW5rIiwicmVsIiwiaHJlZiIsInVuZGVmaW5lZCIsInByb3BzIiwicGFnZXNSb3V0ZXIiLCJ1c2VDb250ZXh0IiwiUm91dGVyQ29udGV4dCIsImNvbmZpZ0NvbnRleHQiLCJJbWFnZUNvbmZpZ0NvbnRleHQiLCJjb25maWciLCJ1c2VNZW1vIiwiYyIsImltYWdlQ29uZmlnRGVmYXVsdCIsImFsbFNpemVzIiwiZGV2aWNlU2l6ZXMiLCJzb3J0IiwiYSIsImIiLCJxdWFsaXRpZXMiLCJvbkxvYWRpbmdDb21wbGV0ZSIsInVzZVJlZiIsInVzZUVmZmVjdCIsImJsdXJDb21wbGV0ZSIsInVzZVN0YXRlIiwic2hvd0FsdFRleHQiLCJtZXRhIiwiaW1nTWV0YSIsImdldEltZ1Byb3BzIiwiZGVmYXVsdExvYWRlciIsImltZ0NvbmYiLCJwcmlvcml0eSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/image-component.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/use-merged-ref.js":
/*!*********************************************************!*\
  !*** ./node_modules/next/dist/client/use-merged-ref.js ***!
  \*********************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"useMergedRef\", ({\n    enumerable: true,\n    get: function() {\n        return useMergedRef;\n    }\n}));\nconst _react = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\nfunction useMergedRef(refA, refB) {\n    const cleanupA = (0, _react.useRef)(()=>{});\n    const cleanupB = (0, _react.useRef)(()=>{});\n    return (0, _react.useMemo)(()=>{\n        if (!refA || !refB) {\n            return refA || refB;\n        }\n        return (current)=>{\n            if (current === null) {\n                cleanupA.current();\n                cleanupB.current();\n            } else {\n                cleanupA.current = applyRef(refA, current);\n                cleanupB.current = applyRef(refB, current);\n            }\n        };\n    }, [\n        refA,\n        refB\n    ]);\n}\nfunction applyRef(refA, current) {\n    if (typeof refA === 'function') {\n        const cleanup = refA(current);\n        if (typeof cleanup === 'function') {\n            return cleanup;\n        } else {\n            return ()=>refA(null);\n        }\n    } else {\n        refA.current = current;\n        return ()=>{\n            refA.current = null;\n        };\n    }\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=use-merged-ref.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3VzZS1tZXJnZWQtcmVmLmpzIiwibWFwcGluZ3MiOiI7Ozs7Z0RBU2dCQTs7O2VBQUFBOzs7bUNBVDBCO0FBU25DLFNBQVNBLGFBQ2RDLElBQW1CLEVBQ25CQyxJQUFtQjtJQUVuQixNQUFNQyxXQUFXQyxDQUFBQSxHQUFBQSxPQUFBQSxNQUFBQSxFQUFtQixLQUFPO0lBQzNDLE1BQU1DLFdBQVdELENBQUFBLEdBQUFBLE9BQUFBLE1BQUFBLEVBQW1CLEtBQU87SUFFM0MsT0FBT0UsQ0FBQUEsR0FBQUEsT0FBQUEsT0FBQUEsRUFBUTtRQUNiLElBQUksQ0FBQ0wsUUFBUSxDQUFDQyxNQUFNO1lBQ2xCLE9BQU9ELFFBQVFDO1FBQ2pCO1FBRUEsT0FBTyxDQUFDSztZQUNOLElBQUlBLFlBQVksTUFBTTtnQkFDcEJKLFNBQVNJLE9BQU87Z0JBQ2hCRixTQUFTRSxPQUFPO1lBQ2xCLE9BQU87Z0JBQ0xKLFNBQVNJLE9BQU8sR0FBR0MsU0FBU1AsTUFBTU07Z0JBQ2xDRixTQUFTRSxPQUFPLEdBQUdDLFNBQVNOLE1BQU1LO1lBQ3BDO1FBQ0Y7SUFDRixHQUFHO1FBQUNOO1FBQU1DO0tBQUs7QUFDakI7QUFFQSxTQUFTTSxTQUNQUCxJQUFnQyxFQUNoQ00sT0FBaUI7SUFFakIsSUFBSSxPQUFPTixTQUFTLFlBQVk7UUFDOUIsTUFBTVEsVUFBVVIsS0FBS007UUFDckIsSUFBSSxPQUFPRSxZQUFZLFlBQVk7WUFDakMsT0FBT0E7UUFDVCxPQUFPO1lBQ0wsT0FBTyxJQUFNUixLQUFLO1FBQ3BCO0lBQ0YsT0FBTztRQUNMQSxLQUFLTSxPQUFPLEdBQUdBO1FBQ2YsT0FBTztZQUNMTixLQUFLTSxPQUFPLEdBQUc7UUFDakI7SUFDRjtBQUNGIiwic291cmNlcyI6WyIvVXNlcnMvam9uYXRoYW52aW5jZW50aXVzL0RvY3VtZW50cy9Vb2ZUL3NyYy9jbGllbnQvdXNlLW1lcmdlZC1yZWYudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlTWVtbywgdXNlUmVmLCB0eXBlIFJlZiB9IGZyb20gJ3JlYWN0J1xuXG4vLyBUaGlzIGlzIGEgY29tcGF0aWJpbGl0eSBob29rIHRvIHN1cHBvcnQgUmVhY3QgMTggYW5kIDE5IHJlZnMuXG4vLyBJbiAxOSwgYSBjbGVhbnVwIGZ1bmN0aW9uIGZyb20gcmVmcyBtYXkgYmUgcmV0dXJuZWQuXG4vLyBJbiAxOCwgcmV0dXJuaW5nIGEgY2xlYW51cCBmdW5jdGlvbiBjcmVhdGVzIGEgd2FybmluZy5cbi8vIFNpbmNlIHdlIHRha2UgdXNlcnNwYWNlIHJlZnMsIHdlIGRvbid0IGtub3cgYWhlYWQgb2YgdGltZSBpZiBhIGNsZWFudXAgZnVuY3Rpb24gd2lsbCBiZSByZXR1cm5lZC5cbi8vIFRoaXMgaW1wbGVtZW50cyBjbGVhbnVwIGZ1bmN0aW9ucyB3aXRoIHRoZSBvbGQgYmVoYXZpb3IgaW4gMTguXG4vLyBXZSBrbm93IHJlZnMgYXJlIGFsd2F5cyBjYWxsZWQgYWx0ZXJuYXRpbmcgd2l0aCBgbnVsbGAgYW5kIHRoZW4gYFRgLlxuLy8gU28gYSBjYWxsIHdpdGggYG51bGxgIG1lYW5zIHdlIG5lZWQgdG8gY2FsbCB0aGUgcHJldmlvdXMgY2xlYW51cCBmdW5jdGlvbnMuXG5leHBvcnQgZnVuY3Rpb24gdXNlTWVyZ2VkUmVmPFRFbGVtZW50PihcbiAgcmVmQTogUmVmPFRFbGVtZW50PixcbiAgcmVmQjogUmVmPFRFbGVtZW50PlxuKTogUmVmPFRFbGVtZW50PiB7XG4gIGNvbnN0IGNsZWFudXBBID0gdXNlUmVmPCgpID0+IHZvaWQ+KCgpID0+IHt9KVxuICBjb25zdCBjbGVhbnVwQiA9IHVzZVJlZjwoKSA9PiB2b2lkPigoKSA9PiB7fSlcblxuICByZXR1cm4gdXNlTWVtbygoKSA9PiB7XG4gICAgaWYgKCFyZWZBIHx8ICFyZWZCKSB7XG4gICAgICByZXR1cm4gcmVmQSB8fCByZWZCXG4gICAgfVxuXG4gICAgcmV0dXJuIChjdXJyZW50OiBURWxlbWVudCB8IG51bGwpOiB2b2lkID0+IHtcbiAgICAgIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgICAgIGNsZWFudXBBLmN1cnJlbnQoKVxuICAgICAgICBjbGVhbnVwQi5jdXJyZW50KClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNsZWFudXBBLmN1cnJlbnQgPSBhcHBseVJlZihyZWZBLCBjdXJyZW50KVxuICAgICAgICBjbGVhbnVwQi5jdXJyZW50ID0gYXBwbHlSZWYocmVmQiwgY3VycmVudClcbiAgICAgIH1cbiAgICB9XG4gIH0sIFtyZWZBLCByZWZCXSlcbn1cblxuZnVuY3Rpb24gYXBwbHlSZWY8VEVsZW1lbnQ+KFxuICByZWZBOiBOb25OdWxsYWJsZTxSZWY8VEVsZW1lbnQ+PixcbiAgY3VycmVudDogVEVsZW1lbnRcbikge1xuICBpZiAodHlwZW9mIHJlZkEgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjb25zdCBjbGVhbnVwID0gcmVmQShjdXJyZW50KVxuICAgIGlmICh0eXBlb2YgY2xlYW51cCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIGNsZWFudXBcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgpID0+IHJlZkEobnVsbClcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmVmQS5jdXJyZW50ID0gY3VycmVudFxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICByZWZBLmN1cnJlbnQgPSBudWxsXG4gICAgfVxuICB9XG59XG4iXSwibmFtZXMiOlsidXNlTWVyZ2VkUmVmIiwicmVmQSIsInJlZkIiLCJjbGVhbnVwQSIsInVzZVJlZiIsImNsZWFudXBCIiwidXNlTWVtbyIsImN1cnJlbnQiLCJhcHBseVJlZiIsImNsZWFudXAiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/use-merged-ref.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/amp-context.shared-runtime.js":
/*!*************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/amp-context.shared-runtime.js ***!
  \*************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"AmpStateContext\", ({\n    enumerable: true,\n    get: function() {\n        return AmpStateContext;\n    }\n}));\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _react = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nconst AmpStateContext = _react.default.createContext({});\nif (true) {\n    AmpStateContext.displayName = 'AmpStateContext';\n} //# sourceMappingURL=amp-context.shared-runtime.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9hbXAtY29udGV4dC5zaGFyZWQtcnVudGltZS5qcyIsIm1hcHBpbmdzIjoiOzs7O21EQUVhQTs7O2VBQUFBOzs7OzRFQUZLO0FBRVgsTUFBTUEsa0JBQXNDQyxPQUFBQSxPQUFLLENBQUNDLGFBQWEsQ0FBQyxDQUFDO0FBRXhFLElBQUlDLElBQW9CLEVBQW1CO0lBQ3pDSCxnQkFBZ0JNLFdBQVcsR0FBRztBQUNoQyIsInNvdXJjZXMiOlsiL1VzZXJzL2pvbmF0aGFudmluY2VudGl1cy9Eb2N1bWVudHMvc3JjL3NoYXJlZC9saWIvYW1wLWNvbnRleHQuc2hhcmVkLXJ1bnRpbWUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0J1xuXG5leHBvcnQgY29uc3QgQW1wU3RhdGVDb250ZXh0OiBSZWFjdC5Db250ZXh0PGFueT4gPSBSZWFjdC5jcmVhdGVDb250ZXh0KHt9KVxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBBbXBTdGF0ZUNvbnRleHQuZGlzcGxheU5hbWUgPSAnQW1wU3RhdGVDb250ZXh0J1xufVxuIl0sIm5hbWVzIjpbIkFtcFN0YXRlQ29udGV4dCIsIlJlYWN0IiwiY3JlYXRlQ29udGV4dCIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsImRpc3BsYXlOYW1lIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/amp-context.shared-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/amp-mode.js":
/*!*******************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/amp-mode.js ***!
  \*******************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"isInAmpMode\", ({\n    enumerable: true,\n    get: function() {\n        return isInAmpMode;\n    }\n}));\nfunction isInAmpMode(param) {\n    let { ampFirst = false, hybrid = false, hasQuery = false } = param === void 0 ? {} : param;\n    return ampFirst || hybrid && hasQuery;\n} //# sourceMappingURL=amp-mode.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9hbXAtbW9kZS5qcyIsIm1hcHBpbmdzIjoiOzs7OytDQUFnQkE7OztlQUFBQTs7O0FBQVQsU0FBU0EsWUFBWTtJQUFBLE1BQzFCQyxXQUFXLEtBQUssRUFDaEJDLFNBQVMsS0FBSyxFQUNkQyxXQUFXLEtBQUssRUFDakIsR0FKMkIsbUJBSXhCLENBQUMsSUFKdUI7SUFLMUIsT0FBT0YsWUFBYUMsVUFBVUM7QUFDaEMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9qb25hdGhhbnZpbmNlbnRpdXMvRG9jdW1lbnRzL3NyYy9zaGFyZWQvbGliL2FtcC1tb2RlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBmdW5jdGlvbiBpc0luQW1wTW9kZSh7XG4gIGFtcEZpcnN0ID0gZmFsc2UsXG4gIGh5YnJpZCA9IGZhbHNlLFxuICBoYXNRdWVyeSA9IGZhbHNlLFxufSA9IHt9KTogYm9vbGVhbiB7XG4gIHJldHVybiBhbXBGaXJzdCB8fCAoaHlicmlkICYmIGhhc1F1ZXJ5KVxufVxuIl0sIm5hbWVzIjpbImlzSW5BbXBNb2RlIiwiYW1wRmlyc3QiLCJoeWJyaWQiLCJoYXNRdWVyeSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/amp-mode.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/get-img-props.js":
/*!************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/get-img-props.js ***!
  \************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"getImgProps\", ({\n    enumerable: true,\n    get: function() {\n        return getImgProps;\n    }\n}));\nconst _warnonce = __webpack_require__(/*! ./utils/warn-once */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/utils/warn-once.js\");\nconst _imageblursvg = __webpack_require__(/*! ./image-blur-svg */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/image-blur-svg.js\");\nconst _imageconfig = __webpack_require__(/*! ./image-config */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/image-config.js\");\nconst VALID_LOADING_VALUES = [\n    'lazy',\n    'eager',\n    undefined\n];\nfunction isStaticRequire(src) {\n    return src.default !== undefined;\n}\nfunction isStaticImageData(src) {\n    return src.src !== undefined;\n}\nfunction isStaticImport(src) {\n    return !!src && typeof src === 'object' && (isStaticRequire(src) || isStaticImageData(src));\n}\nconst allImgs = new Map();\nlet perfObserver;\nfunction getInt(x) {\n    if (typeof x === 'undefined') {\n        return x;\n    }\n    if (typeof x === 'number') {\n        return Number.isFinite(x) ? x : NaN;\n    }\n    if (typeof x === 'string' && /^[0-9]+$/.test(x)) {\n        return parseInt(x, 10);\n    }\n    return NaN;\n}\nfunction getWidths(param, width, sizes) {\n    let { deviceSizes, allSizes } = param;\n    if (sizes) {\n        // Find all the \"vw\" percent sizes used in the sizes prop\n        const viewportWidthRe = /(^|\\s)(1?\\d?\\d)vw/g;\n        const percentSizes = [];\n        for(let match; match = viewportWidthRe.exec(sizes); match){\n            percentSizes.push(parseInt(match[2]));\n        }\n        if (percentSizes.length) {\n            const smallestRatio = Math.min(...percentSizes) * 0.01;\n            return {\n                widths: allSizes.filter((s)=>s >= deviceSizes[0] * smallestRatio),\n                kind: 'w'\n            };\n        }\n        return {\n            widths: allSizes,\n            kind: 'w'\n        };\n    }\n    if (typeof width !== 'number') {\n        return {\n            widths: deviceSizes,\n            kind: 'w'\n        };\n    }\n    const widths = [\n        ...new Set(// > are actually 3x in the green color, but only 1.5x in the red and\n        // > blue colors. Showing a 3x resolution image in the app vs a 2x\n        // > resolution image will be visually the same, though the 3x image\n        // > takes significantly more data. Even true 3x resolution screens are\n        // > wasteful as the human eye cannot see that level of detail without\n        // > something like a magnifying glass.\n        // https://blog.twitter.com/engineering/en_us/topics/infrastructure/2019/capping-image-fidelity-on-ultra-high-resolution-devices.html\n        [\n            width,\n            width * 2 /*, width * 3*/ \n        ].map((w)=>allSizes.find((p)=>p >= w) || allSizes[allSizes.length - 1]))\n    ];\n    return {\n        widths,\n        kind: 'x'\n    };\n}\nfunction generateImgAttrs(param) {\n    let { config, src, unoptimized, width, quality, sizes, loader } = param;\n    if (unoptimized) {\n        return {\n            src,\n            srcSet: undefined,\n            sizes: undefined\n        };\n    }\n    const { widths, kind } = getWidths(config, width, sizes);\n    const last = widths.length - 1;\n    return {\n        sizes: !sizes && kind === 'w' ? '100vw' : sizes,\n        srcSet: widths.map((w, i)=>loader({\n                config,\n                src,\n                quality,\n                width: w\n            }) + \" \" + (kind === 'w' ? w : i + 1) + kind).join(', '),\n        // It's intended to keep `src` the last attribute because React updates\n        // attributes in order. If we keep `src` the first one, Safari will\n        // immediately start to fetch `src`, before `sizes` and `srcSet` are even\n        // updated by React. That causes multiple unnecessary requests if `srcSet`\n        // and `sizes` are defined.\n        // This bug cannot be reproduced in Chrome or Firefox.\n        src: loader({\n            config,\n            src,\n            quality,\n            width: widths[last]\n        })\n    };\n}\nfunction getImgProps(param, _state) {\n    let { src, sizes, unoptimized = false, priority = false, loading, className, quality, width, height, fill = false, style, overrideSrc, onLoad, onLoadingComplete, placeholder = 'empty', blurDataURL, fetchPriority, decoding = 'async', layout, objectFit, objectPosition, lazyBoundary, lazyRoot, ...rest } = param;\n    const { imgConf, showAltText, blurComplete, defaultLoader } = _state;\n    let config;\n    let c = imgConf || _imageconfig.imageConfigDefault;\n    if ('allSizes' in c) {\n        config = c;\n    } else {\n        var _c_qualities;\n        const allSizes = [\n            ...c.deviceSizes,\n            ...c.imageSizes\n        ].sort((a, b)=>a - b);\n        const deviceSizes = c.deviceSizes.sort((a, b)=>a - b);\n        const qualities = (_c_qualities = c.qualities) == null ? void 0 : _c_qualities.sort((a, b)=>a - b);\n        config = {\n            ...c,\n            allSizes,\n            deviceSizes,\n            qualities\n        };\n    }\n    if (typeof defaultLoader === 'undefined') {\n        throw new Error('images.loaderFile detected but the file is missing default export.\\nRead more: https://nextjs.org/docs/messages/invalid-images-config');\n    }\n    let loader = rest.loader || defaultLoader;\n    // Remove property so it's not spread on <img> element\n    delete rest.loader;\n    delete rest.srcSet;\n    // This special value indicates that the user\n    // didn't define a \"loader\" prop or \"loader\" config.\n    const isDefaultLoader = '__next_img_default' in loader;\n    if (isDefaultLoader) {\n        if (config.loader === 'custom') {\n            throw new Error('Image with src \"' + src + '\" is missing \"loader\" prop.' + \"\\nRead more: https://nextjs.org/docs/messages/next-image-missing-loader\");\n        }\n    } else {\n        // The user defined a \"loader\" prop or config.\n        // Since the config object is internal only, we\n        // must not pass it to the user-defined \"loader\".\n        const customImageLoader = loader;\n        loader = (obj)=>{\n            const { config: _, ...opts } = obj;\n            return customImageLoader(opts);\n        };\n    }\n    if (layout) {\n        if (layout === 'fill') {\n            fill = true;\n        }\n        const layoutToStyle = {\n            intrinsic: {\n                maxWidth: '100%',\n                height: 'auto'\n            },\n            responsive: {\n                width: '100%',\n                height: 'auto'\n            }\n        };\n        const layoutToSizes = {\n            responsive: '100vw',\n            fill: '100vw'\n        };\n        const layoutStyle = layoutToStyle[layout];\n        if (layoutStyle) {\n            style = {\n                ...style,\n                ...layoutStyle\n            };\n        }\n        const layoutSizes = layoutToSizes[layout];\n        if (layoutSizes && !sizes) {\n            sizes = layoutSizes;\n        }\n    }\n    let staticSrc = '';\n    let widthInt = getInt(width);\n    let heightInt = getInt(height);\n    let blurWidth;\n    let blurHeight;\n    if (isStaticImport(src)) {\n        const staticImageData = isStaticRequire(src) ? src.default : src;\n        if (!staticImageData.src) {\n            throw new Error(\"An object should only be passed to the image component src parameter if it comes from a static image import. It must include src. Received \" + JSON.stringify(staticImageData));\n        }\n        if (!staticImageData.height || !staticImageData.width) {\n            throw new Error(\"An object should only be passed to the image component src parameter if it comes from a static image import. It must include height and width. Received \" + JSON.stringify(staticImageData));\n        }\n        blurWidth = staticImageData.blurWidth;\n        blurHeight = staticImageData.blurHeight;\n        blurDataURL = blurDataURL || staticImageData.blurDataURL;\n        staticSrc = staticImageData.src;\n        if (!fill) {\n            if (!widthInt && !heightInt) {\n                widthInt = staticImageData.width;\n                heightInt = staticImageData.height;\n            } else if (widthInt && !heightInt) {\n                const ratio = widthInt / staticImageData.width;\n                heightInt = Math.round(staticImageData.height * ratio);\n            } else if (!widthInt && heightInt) {\n                const ratio = heightInt / staticImageData.height;\n                widthInt = Math.round(staticImageData.width * ratio);\n            }\n        }\n    }\n    src = typeof src === 'string' ? src : staticSrc;\n    let isLazy = !priority && (loading === 'lazy' || typeof loading === 'undefined');\n    if (!src || src.startsWith('data:') || src.startsWith('blob:')) {\n        // https://developer.mozilla.org/docs/Web/HTTP/Basics_of_HTTP/Data_URIs\n        unoptimized = true;\n        isLazy = false;\n    }\n    if (config.unoptimized) {\n        unoptimized = true;\n    }\n    if (isDefaultLoader && !config.dangerouslyAllowSVG && src.split('?', 1)[0].endsWith('.svg')) {\n        // Special case to make svg serve as-is to avoid proxying\n        // through the built-in Image Optimization API.\n        unoptimized = true;\n    }\n    const qualityInt = getInt(quality);\n    if (true) {\n        if (config.output === 'export' && isDefaultLoader && !unoptimized) {\n            throw new Error(\"Image Optimization using the default loader is not compatible with `{ output: 'export' }`.\\n  Possible solutions:\\n    - Remove `{ output: 'export' }` and run \\\"next start\\\" to run server mode including the Image Optimization API.\\n    - Configure `{ images: { unoptimized: true } }` in `next.config.js` to disable the Image Optimization API.\\n  Read more: https://nextjs.org/docs/messages/export-image-api\");\n        }\n        if (!src) {\n            // React doesn't show the stack trace and there's\n            // no `src` to help identify which image, so we\n            // instead console.error(ref) during mount.\n            unoptimized = true;\n        } else {\n            if (fill) {\n                if (width) {\n                    throw new Error('Image with src \"' + src + '\" has both \"width\" and \"fill\" properties. Only one should be used.');\n                }\n                if (height) {\n                    throw new Error('Image with src \"' + src + '\" has both \"height\" and \"fill\" properties. Only one should be used.');\n                }\n                if ((style == null ? void 0 : style.position) && style.position !== 'absolute') {\n                    throw new Error('Image with src \"' + src + '\" has both \"fill\" and \"style.position\" properties. Images with \"fill\" always use position absolute - it cannot be modified.');\n                }\n                if ((style == null ? void 0 : style.width) && style.width !== '100%') {\n                    throw new Error('Image with src \"' + src + '\" has both \"fill\" and \"style.width\" properties. Images with \"fill\" always use width 100% - it cannot be modified.');\n                }\n                if ((style == null ? void 0 : style.height) && style.height !== '100%') {\n                    throw new Error('Image with src \"' + src + '\" has both \"fill\" and \"style.height\" properties. Images with \"fill\" always use height 100% - it cannot be modified.');\n                }\n            } else {\n                if (typeof widthInt === 'undefined') {\n                    throw new Error('Image with src \"' + src + '\" is missing required \"width\" property.');\n                } else if (isNaN(widthInt)) {\n                    throw new Error('Image with src \"' + src + '\" has invalid \"width\" property. Expected a numeric value in pixels but received \"' + width + '\".');\n                }\n                if (typeof heightInt === 'undefined') {\n                    throw new Error('Image with src \"' + src + '\" is missing required \"height\" property.');\n                } else if (isNaN(heightInt)) {\n                    throw new Error('Image with src \"' + src + '\" has invalid \"height\" property. Expected a numeric value in pixels but received \"' + height + '\".');\n                }\n                // eslint-disable-next-line no-control-regex\n                if (/^[\\x00-\\x20]/.test(src)) {\n                    throw new Error('Image with src \"' + src + '\" cannot start with a space or control character. Use src.trimStart() to remove it or encodeURIComponent(src) to keep it.');\n                }\n                // eslint-disable-next-line no-control-regex\n                if (/[\\x00-\\x20]$/.test(src)) {\n                    throw new Error('Image with src \"' + src + '\" cannot end with a space or control character. Use src.trimEnd() to remove it or encodeURIComponent(src) to keep it.');\n                }\n            }\n        }\n        if (!VALID_LOADING_VALUES.includes(loading)) {\n            throw new Error('Image with src \"' + src + '\" has invalid \"loading\" property. Provided \"' + loading + '\" should be one of ' + VALID_LOADING_VALUES.map(String).join(',') + \".\");\n        }\n        if (priority && loading === 'lazy') {\n            throw new Error('Image with src \"' + src + '\" has both \"priority\" and \"loading=\\'lazy\\'\" properties. Only one should be used.');\n        }\n        if (placeholder !== 'empty' && placeholder !== 'blur' && !placeholder.startsWith('data:image/')) {\n            throw new Error('Image with src \"' + src + '\" has invalid \"placeholder\" property \"' + placeholder + '\".');\n        }\n        if (placeholder !== 'empty') {\n            if (widthInt && heightInt && widthInt * heightInt < 1600) {\n                (0, _warnonce.warnOnce)('Image with src \"' + src + '\" is smaller than 40x40. Consider removing the \"placeholder\" property to improve performance.');\n            }\n        }\n        if (placeholder === 'blur' && !blurDataURL) {\n            const VALID_BLUR_EXT = [\n                'jpeg',\n                'png',\n                'webp',\n                'avif'\n            ] // should match next-image-loader\n            ;\n            throw new Error('Image with src \"' + src + '\" has \"placeholder=\\'blur\\'\" property but is missing the \"blurDataURL\" property.\\n        Possible solutions:\\n          - Add a \"blurDataURL\" property, the contents should be a small Data URL to represent the image\\n          - Change the \"src\" property to a static import with one of the supported file types: ' + VALID_BLUR_EXT.join(',') + ' (animated images not supported)\\n          - Remove the \"placeholder\" property, effectively no blur effect\\n        Read more: https://nextjs.org/docs/messages/placeholder-blur-data-url');\n        }\n        if ('ref' in rest) {\n            (0, _warnonce.warnOnce)('Image with src \"' + src + '\" is using unsupported \"ref\" property. Consider using the \"onLoad\" property instead.');\n        }\n        if (!unoptimized && !isDefaultLoader) {\n            const urlStr = loader({\n                config,\n                src,\n                width: widthInt || 400,\n                quality: qualityInt || 75\n            });\n            let url;\n            try {\n                url = new URL(urlStr);\n            } catch (err) {}\n            if (urlStr === src || url && url.pathname === src && !url.search) {\n                (0, _warnonce.warnOnce)('Image with src \"' + src + '\" has a \"loader\" property that does not implement width. Please implement it or use the \"unoptimized\" property instead.' + \"\\nRead more: https://nextjs.org/docs/messages/next-image-missing-loader-width\");\n            }\n        }\n        if (onLoadingComplete) {\n            (0, _warnonce.warnOnce)('Image with src \"' + src + '\" is using deprecated \"onLoadingComplete\" property. Please use the \"onLoad\" property instead.');\n        }\n        for (const [legacyKey, legacyValue] of Object.entries({\n            layout,\n            objectFit,\n            objectPosition,\n            lazyBoundary,\n            lazyRoot\n        })){\n            if (legacyValue) {\n                (0, _warnonce.warnOnce)('Image with src \"' + src + '\" has legacy prop \"' + legacyKey + '\". Did you forget to run the codemod?' + \"\\nRead more: https://nextjs.org/docs/messages/next-image-upgrade-to-13\");\n            }\n        }\n        if (typeof window !== 'undefined' && !perfObserver && window.PerformanceObserver) {\n            perfObserver = new PerformanceObserver((entryList)=>{\n                for (const entry of entryList.getEntries()){\n                    var _entry_element;\n                    // @ts-ignore - missing \"LargestContentfulPaint\" class with \"element\" prop\n                    const imgSrc = (entry == null ? void 0 : (_entry_element = entry.element) == null ? void 0 : _entry_element.src) || '';\n                    const lcpImage = allImgs.get(imgSrc);\n                    if (lcpImage && !lcpImage.priority && lcpImage.placeholder === 'empty' && !lcpImage.src.startsWith('data:') && !lcpImage.src.startsWith('blob:')) {\n                        // https://web.dev/lcp/#measure-lcp-in-javascript\n                        (0, _warnonce.warnOnce)('Image with src \"' + lcpImage.src + '\" was detected as the Largest Contentful Paint (LCP). Please add the \"priority\" property if this image is above the fold.' + \"\\nRead more: https://nextjs.org/docs/api-reference/next/image#priority\");\n                    }\n                }\n            });\n            try {\n                perfObserver.observe({\n                    type: 'largest-contentful-paint',\n                    buffered: true\n                });\n            } catch (err) {\n                // Log error but don't crash the app\n                console.error(err);\n            }\n        }\n    }\n    const imgStyle = Object.assign(fill ? {\n        position: 'absolute',\n        height: '100%',\n        width: '100%',\n        left: 0,\n        top: 0,\n        right: 0,\n        bottom: 0,\n        objectFit,\n        objectPosition\n    } : {}, showAltText ? {} : {\n        color: 'transparent'\n    }, style);\n    const backgroundImage = !blurComplete && placeholder !== 'empty' ? placeholder === 'blur' ? 'url(\"data:image/svg+xml;charset=utf-8,' + (0, _imageblursvg.getImageBlurSvg)({\n        widthInt,\n        heightInt,\n        blurWidth,\n        blurHeight,\n        blurDataURL: blurDataURL || '',\n        objectFit: imgStyle.objectFit\n    }) + '\")' : 'url(\"' + placeholder + '\")' // assume `data:image/`\n     : null;\n    let placeholderStyle = backgroundImage ? {\n        backgroundSize: imgStyle.objectFit || 'cover',\n        backgroundPosition: imgStyle.objectPosition || '50% 50%',\n        backgroundRepeat: 'no-repeat',\n        backgroundImage\n    } : {};\n    if (true) {\n        if (placeholderStyle.backgroundImage && placeholder === 'blur' && (blurDataURL == null ? void 0 : blurDataURL.startsWith('/'))) {\n            // During `next dev`, we don't want to generate blur placeholders with webpack\n            // because it can delay starting the dev server. Instead, `next-image-loader.js`\n            // will inline a special url to lazily generate the blur placeholder at request time.\n            placeholderStyle.backgroundImage = 'url(\"' + blurDataURL + '\")';\n        }\n    }\n    const imgAttributes = generateImgAttrs({\n        config,\n        src,\n        unoptimized,\n        width: widthInt,\n        quality: qualityInt,\n        sizes,\n        loader\n    });\n    if (true) {\n        if (typeof window !== 'undefined') {\n            let fullUrl;\n            try {\n                fullUrl = new URL(imgAttributes.src);\n            } catch (e) {\n                fullUrl = new URL(imgAttributes.src, window.location.href);\n            }\n            allImgs.set(fullUrl.href, {\n                src,\n                priority,\n                placeholder\n            });\n        }\n    }\n    const props = {\n        ...rest,\n        loading: isLazy ? 'lazy' : loading,\n        fetchPriority,\n        width: widthInt,\n        height: heightInt,\n        decoding,\n        className,\n        style: {\n            ...imgStyle,\n            ...placeholderStyle\n        },\n        sizes: imgAttributes.sizes,\n        srcSet: imgAttributes.srcSet,\n        src: overrideSrc || imgAttributes.src\n    };\n    const meta = {\n        unoptimized,\n        priority,\n        placeholder,\n        fill\n    };\n    return {\n        props,\n        meta\n    };\n} //# sourceMappingURL=get-img-props.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9nZXQtaW1nLXByb3BzLmpzIiwibWFwcGluZ3MiOiI7Ozs7K0NBOE9nQkE7OztlQUFBQTs7O3NDQTlPUzswQ0FDTzt5Q0FDRztBQStFbkMsTUFBTUMsdUJBQXVCO0lBQUM7SUFBUTtJQUFTQztDQUFVO0FBa0J6RCxTQUFTQyxnQkFDUEMsR0FBb0M7SUFFcEMsT0FBUUEsSUFBc0JDLE9BQU8sS0FBS0g7QUFDNUM7QUFFQSxTQUFTSSxrQkFDUEYsR0FBb0M7SUFFcEMsT0FBUUEsSUFBd0JBLEdBQUcsS0FBS0Y7QUFDMUM7QUFFQSxTQUFTSyxlQUFlSCxHQUEwQjtJQUNoRCxPQUNFLENBQUMsQ0FBQ0EsT0FDRixPQUFPQSxRQUFRLFlBQ2RELENBQUFBLGdCQUFnQkMsUUFDZkUsa0JBQWtCRixJQUFBQSxDQUFtQjtBQUUzQztBQUVBLE1BQU1JLFVBQVUsSUFBSUM7QUFJcEIsSUFBSUM7QUFFSixTQUFTQyxPQUFPQyxDQUFVO0lBQ3hCLElBQUksT0FBT0EsTUFBTSxhQUFhO1FBQzVCLE9BQU9BO0lBQ1Q7SUFDQSxJQUFJLE9BQU9BLE1BQU0sVUFBVTtRQUN6QixPQUFPQyxPQUFPQyxRQUFRLENBQUNGLEtBQUtBLElBQUlHO0lBQ2xDO0lBQ0EsSUFBSSxPQUFPSCxNQUFNLFlBQVksV0FBV0ksSUFBSSxDQUFDSixJQUFJO1FBQy9DLE9BQU9LLFNBQVNMLEdBQUc7SUFDckI7SUFDQSxPQUFPRztBQUNUO0FBRUEsU0FBU0csVUFDUCxLQUFzQyxFQUN0Q0MsS0FBeUIsRUFDekJDLEtBQXlCO0lBRnpCLE1BQUVDLFdBQVcsRUFBRUMsUUFBUSxFQUFlLEdBQXRDO0lBSUEsSUFBSUYsT0FBTztRQUNULHlEQUF5RDtRQUN6RCxNQUFNRyxrQkFBa0I7UUFDeEIsTUFBTUMsZUFBZSxFQUFFO1FBQ3ZCLElBQUssSUFBSUMsT0FBUUEsUUFBUUYsZ0JBQWdCRyxJQUFJLENBQUNOLFFBQVNL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Y0FBY3pKLEdBQUc7SUFDdkM7SUFDQSxNQUFNZ0ssT0FBTztRQUFFekg7UUFBYVE7UUFBVVM7UUFBYUw7SUFBSztJQUN4RCxPQUFPO1FBQUU0RztRQUFPQztJQUFLO0FBQ3ZCIiwic291cmNlcyI6WyIvVXNlcnMvam9uYXRoYW52aW5jZW50aXVzL0RvY3VtZW50cy9zcmMvc2hhcmVkL2xpYi9nZXQtaW1nLXByb3BzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHdhcm5PbmNlIH0gZnJvbSAnLi91dGlscy93YXJuLW9uY2UnXG5pbXBvcnQgeyBnZXRJbWFnZUJsdXJTdmcgfSBmcm9tICcuL2ltYWdlLWJsdXItc3ZnJ1xuaW1wb3J0IHsgaW1hZ2VDb25maWdEZWZhdWx0IH0gZnJvbSAnLi9pbWFnZS1jb25maWcnXG5pbXBvcnQgdHlwZSB7XG4gIEltYWdlQ29uZmlnQ29tcGxldGUsXG4gIEltYWdlTG9hZGVyUHJvcHMsXG4gIEltYWdlTG9hZGVyUHJvcHNXaXRoQ29uZmlnLFxufSBmcm9tICcuL2ltYWdlLWNvbmZpZydcblxuaW1wb3J0IHR5cGUgeyBKU1ggfSBmcm9tICdyZWFjdCdcblxuZXhwb3J0IGludGVyZmFjZSBTdGF0aWNJbWFnZURhdGEge1xuICBzcmM6IHN0cmluZ1xuICBoZWlnaHQ6IG51bWJlclxuICB3aWR0aDogbnVtYmVyXG4gIGJsdXJEYXRhVVJMPzogc3RyaW5nXG4gIGJsdXJXaWR0aD86IG51bWJlclxuICBibHVySGVpZ2h0PzogbnVtYmVyXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU3RhdGljUmVxdWlyZSB7XG4gIGRlZmF1bHQ6IFN0YXRpY0ltYWdlRGF0YVxufVxuXG5leHBvcnQgdHlwZSBTdGF0aWNJbXBvcnQgPSBTdGF0aWNSZXF1aXJlIHwgU3RhdGljSW1hZ2VEYXRhXG5cbmV4cG9ydCB0eXBlIEltYWdlUHJvcHMgPSBPbWl0PFxuICBKU1guSW50cmluc2ljRWxlbWVudHNbJ2ltZyddLFxuICAnc3JjJyB8ICdzcmNTZXQnIHwgJ3JlZicgfCAnYWx0JyB8ICd3aWR0aCcgfCAnaGVpZ2h0JyB8ICdsb2FkaW5nJ1xuPiAmIHtcbiAgc3JjOiBzdHJpbmcgfCBTdGF0aWNJbXBvcnRcbiAgYWx0OiBzdHJpbmdcbiAgd2lkdGg/OiBudW1iZXIgfCBgJHtudW1iZXJ9YFxuICBoZWlnaHQ/OiBudW1iZXIgfCBgJHtudW1iZXJ9YFxuICBmaWxsPzogYm9vbGVhblxuICBsb2FkZXI/OiBJbWFnZUxvYWRlclxuICBxdWFsaXR5PzogbnVtYmVyIHwgYCR7bnVtYmVyfWBcbiAgcHJpb3JpdHk/OiBib29sZWFuXG4gIGxvYWRpbmc/OiBMb2FkaW5nVmFsdWVcbiAgcGxhY2Vob2xkZXI/OiBQbGFjZWhvbGRlclZhbHVlXG4gIGJsdXJEYXRhVVJMPzogc3RyaW5nXG4gIHVub3B0aW1pemVkPzogYm9vbGVhblxuICBvdmVycmlkZVNyYz86IHN0cmluZ1xuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGBvbkxvYWRgIGluc3RlYWQuXG4gICAqIEBzZWUgaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBwL2FwaS1yZWZlcmVuY2UvY29tcG9uZW50cy9pbWFnZSNvbmxvYWRcbiAgICovXG4gIG9uTG9hZGluZ0NvbXBsZXRlPzogT25Mb2FkaW5nQ29tcGxldGVcbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBgZmlsbGAgcHJvcCBpbnN0ZWFkIG9mIGBsYXlvdXQ9XCJmaWxsXCJgIG9yIGNoYW5nZSBpbXBvcnQgdG8gYG5leHQvbGVnYWN5L2ltYWdlYC5cbiAgICogQHNlZSBodHRwczovL25leHRqcy5vcmcvZG9jcy9hcGktcmVmZXJlbmNlL25leHQvbGVnYWN5L2ltYWdlXG4gICAqL1xuICBsYXlvdXQ/OiBzdHJpbmdcbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBgc3R5bGVgIHByb3AgaW5zdGVhZC5cbiAgICovXG4gIG9iamVjdEZpdD86IHN0cmluZ1xuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGBzdHlsZWAgcHJvcCBpbnN0ZWFkLlxuICAgKi9cbiAgb2JqZWN0UG9zaXRpb24/OiBzdHJpbmdcbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIFRoaXMgcHJvcCBkb2VzIG5vdCBkbyBhbnl0aGluZy5cbiAgICovXG4gIGxhenlCb3VuZGFyeT86IHN0cmluZ1xuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgVGhpcyBwcm9wIGRvZXMgbm90IGRvIGFueXRoaW5nLlxuICAgKi9cbiAgbGF6eVJvb3Q/OiBzdHJpbmdcbn1cblxuZXhwb3J0IHR5cGUgSW1nUHJvcHMgPSBPbWl0PEltYWdlUHJvcHMsICdzcmMnIHwgJ2xvYWRlcic+ICYge1xuICBsb2FkaW5nOiBMb2FkaW5nVmFsdWVcbiAgd2lkdGg6IG51bWJlciB8IHVuZGVmaW5lZFxuICBoZWlnaHQ6IG51bWJlciB8IHVuZGVmaW5lZFxuICBzdHlsZTogTm9uTnVsbGFibGU8SlNYLkludHJpbnNpY0VsZW1lbnRzWydpbWcnXVsnc3R5bGUnXT5cbiAgc2l6ZXM6IHN0cmluZyB8IHVuZGVmaW5lZFxuICBzcmNTZXQ6IHN0cmluZyB8IHVuZGVmaW5lZFxuICBzcmM6IHN0cmluZ1xufVxuXG5jb25zdCBWQUxJRF9MT0FESU5HX1ZBTFVFUyA9IFsnbGF6eScsICdlYWdlcicsIHVuZGVmaW5lZF0gYXMgY29uc3RcbnR5cGUgTG9hZGluZ1ZhbHVlID0gKHR5cGVvZiBWQUxJRF9MT0FESU5HX1ZBTFVFUylbbnVtYmVyXVxudHlwZSBJbWFnZUNvbmZpZyA9IEltYWdlQ29uZmlnQ29tcGxldGUgJiB7XG4gIGFsbFNpemVzOiBudW1iZXJbXVxuICBvdXRwdXQ/OiAnc3RhbmRhbG9uZScgfCAnZXhwb3J0J1xufVxuXG5leHBvcnQgdHlwZSBJbWFnZUxvYWRlciA9IChwOiBJbWFnZUxvYWRlclByb3BzKSA9PiBzdHJpbmdcblxuLy8gRG8gbm90IGV4cG9ydCAtIHRoaXMgaXMgYW4gaW50ZXJuYWwgdHlwZSBvbmx5XG4vLyBiZWNhdXNlIGBuZXh0LmNvbmZpZy5qc2AgaXMgb25seSBtZWFudCBmb3IgdGhlXG4vLyBidWlsdC1pbiBsb2FkZXJzLCBub3QgZm9yIGEgY3VzdG9tIGxvYWRlcigpIHByb3AuXG50eXBlIEltYWdlTG9hZGVyV2l0aENvbmZpZyA9IChwOiBJbWFnZUxvYWRlclByb3BzV2l0aENvbmZpZykgPT4gc3RyaW5nXG5cbmV4cG9ydCB0eXBlIFBsYWNlaG9sZGVyVmFsdWUgPSAnYmx1cicgfCAnZW1wdHknIHwgYGRhdGE6aW1hZ2UvJHtzdHJpbmd9YFxuZXhwb3J0IHR5cGUgT25Mb2FkID0gUmVhY3QuUmVhY3RFdmVudEhhbmRsZXI8SFRNTEltYWdlRWxlbWVudD4gfCB1bmRlZmluZWRcbmV4cG9ydCB0eXBlIE9uTG9hZGluZ0NvbXBsZXRlID0gKGltZzogSFRNTEltYWdlRWxlbWVudCkgPT4gdm9pZFxuXG5mdW5jdGlvbiBpc1N0YXRpY1JlcXVpcmUoXG4gIHNyYzogU3RhdGljUmVxdWlyZSB8IFN0YXRpY0ltYWdlRGF0YVxuKTogc3JjIGlzIFN0YXRpY1JlcXVpcmUge1xuICByZXR1cm4gKHNyYyBhcyBTdGF0aWNSZXF1aXJlKS5kZWZhdWx0ICE9PSB1bmRlZmluZWRcbn1cblxuZnVuY3Rpb24gaXNTdGF0aWNJbWFnZURhdGEoXG4gIHNyYzogU3RhdGljUmVxdWlyZSB8IFN0YXRpY0ltYWdlRGF0YVxuKTogc3JjIGlzIFN0YXRpY0ltYWdlRGF0YSB7XG4gIHJldHVybiAoc3JjIGFzIFN0YXRpY0ltYWdlRGF0YSkuc3JjICE9PSB1bmRlZmluZWRcbn1cblxuZnVuY3Rpb24gaXNTdGF0aWNJbXBvcnQoc3JjOiBzdHJpbmcgfCBTdGF0aWNJbXBvcnQpOiBzcmMgaXMgU3RhdGljSW1wb3J0IHtcbiAgcmV0dXJuIChcbiAgICAhIXNyYyAmJlxuICAgIHR5cGVvZiBzcmMgPT09ICdvYmplY3QnICYmXG4gICAgKGlzU3RhdGljUmVxdWlyZShzcmMgYXMgU3RhdGljSW1wb3J0KSB8fFxuICAgICAgaXNTdGF0aWNJbWFnZURhdGEoc3JjIGFzIFN0YXRpY0ltcG9ydCkpXG4gIClcbn1cblxuY29uc3QgYWxsSW1ncyA9IG5ldyBNYXA8XG4gIHN0cmluZyxcbiAgeyBzcmM6IHN0cmluZzsgcHJpb3JpdHk6IGJvb2xlYW47IHBsYWNlaG9sZGVyOiBQbGFjZWhvbGRlclZhbHVlIH1cbj4oKVxubGV0IHBlcmZPYnNlcnZlcjogUGVyZm9ybWFuY2VPYnNlcnZlciB8IHVuZGVmaW5lZFxuXG5mdW5jdGlvbiBnZXRJbnQoeDogdW5rbm93bik6IG51bWJlciB8IHVuZGVmaW5lZCB7XG4gIGlmICh0eXBlb2YgeCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4geFxuICB9XG4gIGlmICh0eXBlb2YgeCA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gTnVtYmVyLmlzRmluaXRlKHgpID8geCA6IE5hTlxuICB9XG4gIGlmICh0eXBlb2YgeCA9PT0gJ3N0cmluZycgJiYgL15bMC05XSskLy50ZXN0KHgpKSB7XG4gICAgcmV0dXJuIHBhcnNlSW50KHgsIDEwKVxuICB9XG4gIHJldHVybiBOYU5cbn1cblxuZnVuY3Rpb24gZ2V0V2lkdGhzKFxuICB7IGRldmljZVNpemVzLCBhbGxTaXplcyB9OiBJbWFnZUNvbmZpZyxcbiAgd2lkdGg6IG51bWJlciB8IHVuZGVmaW5lZCxcbiAgc2l6ZXM6IHN0cmluZyB8IHVuZGVmaW5lZFxuKTogeyB3aWR0aHM6IG51bWJlcltdOyBraW5kOiAndycgfCAneCcgfSB7XG4gIGlmIChzaXplcykge1xuICAgIC8vIEZpbmQgYWxsIHRoZSBcInZ3XCIgcGVyY2VudCBzaXplcyB1c2VkIGluIHRoZSBzaXplcyBwcm9wXG4gICAgY29uc3Qgdmlld3BvcnRXaWR0aFJlID0gLyhefFxccykoMT9cXGQ/XFxkKXZ3L2dcbiAgICBjb25zdCBwZXJjZW50U2l6ZXMgPSBbXVxuICAgIGZvciAobGV0IG1hdGNoOyAobWF0Y2ggPSB2aWV3cG9ydFdpZHRoUmUuZXhlYyhzaXplcykpOyBtYXRjaCkge1xuICAgICAgcGVyY2VudFNpemVzLnB1c2gocGFyc2VJbnQobWF0Y2hbMl0pKVxuICAgIH1cbiAgICBpZiAocGVyY2VudFNpemVzLmxlbmd0aCkge1xuICAgICAgY29uc3Qgc21hbGxlc3RSYXRpbyA9IE1hdGgubWluKC4uLnBlcmNlbnRTaXplcykgKiAwLjAxXG4gICAgICByZXR1cm4ge1xuICAgICAgICB3aWR0aHM6IGFsbFNpemVzLmZpbHRlcigocykgPT4gcyA+PSBkZXZpY2VTaXplc1swXSAqIHNtYWxsZXN0UmF0aW8pLFxuICAgICAgICBraW5kOiAndycsXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IHdpZHRoczogYWxsU2l6ZXMsIGtpbmQ6ICd3JyB9XG4gIH1cbiAgaWYgKHR5cGVvZiB3aWR0aCAhPT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4geyB3aWR0aHM6IGRldmljZVNpemVzLCBraW5kOiAndycgfVxuICB9XG5cbiAgY29uc3Qgd2lkdGhzID0gW1xuICAgIC4uLm5ldyBTZXQoXG4gICAgICAvLyA+IFRoaXMgbWVhbnMgdGhhdCBtb3N0IE9MRUQgc2NyZWVucyB0aGF0IHNheSB0aGV5IGFyZSAzeCByZXNvbHV0aW9uLFxuICAgICAgLy8gPiBhcmUgYWN0dWFsbHkgM3ggaW4gdGhlIGdyZWVuIGNvbG9yLCBidXQgb25seSAxLjV4IGluIHRoZSByZWQgYW5kXG4gICAgICAvLyA+IGJsdWUgY29sb3JzLiBTaG93aW5nIGEgM3ggcmVzb2x1dGlvbiBpbWFnZSBpbiB0aGUgYXBwIHZzIGEgMnhcbiAgICAgIC8vID4gcmVzb2x1dGlvbiBpbWFnZSB3aWxsIGJlIHZpc3VhbGx5IHRoZSBzYW1lLCB0aG91Z2ggdGhlIDN4IGltYWdlXG4gICAgICAvLyA+IHRha2VzIHNpZ25pZmljYW50bHkgbW9yZSBkYXRhLiBFdmVuIHRydWUgM3ggcmVzb2x1dGlvbiBzY3JlZW5zIGFyZVxuICAgICAgLy8gPiB3YXN0ZWZ1bCBhcyB0aGUgaHVtYW4gZXllIGNhbm5vdCBzZWUgdGhhdCBsZXZlbCBvZiBkZXRhaWwgd2l0aG91dFxuICAgICAgLy8gPiBzb21ldGhpbmcgbGlrZSBhIG1hZ25pZnlpbmcgZ2xhc3MuXG4gICAgICAvLyBodHRwczovL2Jsb2cudHdpdHRlci5jb20vZW5naW5lZXJpbmcvZW5fdXMvdG9waWNzL2luZnJhc3RydWN0dXJlLzIwMTkvY2FwcGluZy1pbWFnZS1maWRlbGl0eS1vbi11bHRyYS1oaWdoLXJlc29sdXRpb24tZGV2aWNlcy5odG1sXG4gICAgICBbd2lkdGgsIHdpZHRoICogMiAvKiwgd2lkdGggKiAzKi9dLm1hcChcbiAgICAgICAgKHcpID0+IGFsbFNpemVzLmZpbmQoKHApID0+IHAgPj0gdykgfHwgYWxsU2l6ZXNbYWxsU2l6ZXMubGVuZ3RoIC0gMV1cbiAgICAgIClcbiAgICApLFxuICBdXG4gIHJldHVybiB7IHdpZHRocywga2luZDogJ3gnIH1cbn1cblxudHlwZSBHZW5JbWdBdHRyc0RhdGEgPSB7XG4gIGNvbmZpZzogSW1hZ2VDb25maWdcbiAgc3JjOiBzdHJpbmdcbiAgdW5vcHRpbWl6ZWQ6IGJvb2xlYW5cbiAgbG9hZGVyOiBJbWFnZUxvYWRlcldpdGhDb25maWdcbiAgd2lkdGg/OiBudW1iZXJcbiAgcXVhbGl0eT86IG51bWJlclxuICBzaXplcz86IHN0cmluZ1xufVxuXG50eXBlIEdlbkltZ0F0dHJzUmVzdWx0ID0ge1xuICBzcmM6IHN0cmluZ1xuICBzcmNTZXQ6IHN0cmluZyB8IHVuZGVmaW5lZFxuICBzaXplczogc3RyaW5nIHwgdW5kZWZpbmVkXG59XG5cbmZ1bmN0aW9uIGdlbmVyYXRlSW1nQXR0cnMoe1xuICBjb25maWcsXG4gIHNyYyxcbiAgdW5vcHRpbWl6ZWQsXG4gIHdpZHRoLFxuICBxdWFsaXR5LFxuICBzaXplcyxcbiAgbG9hZGVyLFxufTogR2VuSW1nQXR0cnNEYXRhKTogR2VuSW1nQXR0cnNSZXN1bHQge1xuICBpZiAodW5vcHRpbWl6ZWQpIHtcbiAgICByZXR1cm4geyBzcmMsIHNyY1NldDogdW5kZWZpbmVkLCBzaXplczogdW5kZWZpbmVkIH1cbiAgfVxuXG4gIGNvbnN0IHsgd2lkdGhzLCBraW5kIH0gPSBnZXRXaWR0aHMoY29uZmlnLCB3aWR0aCwgc2l6ZXMpXG4gIGNvbnN0IGxhc3QgPSB3aWR0aHMubGVuZ3RoIC0gMVxuXG4gIHJldHVybiB7XG4gICAgc2l6ZXM6ICFzaXplcyAmJiBraW5kID09PSAndycgPyAnMTAwdncnIDogc2l6ZXMsXG4gICAgc3JjU2V0OiB3aWR0aHNcbiAgICAgIC5tYXAoXG4gICAgICAgICh3LCBpKSA9PlxuICAgICAgICAgIGAke2xvYWRlcih7IGNvbmZpZywgc3JjLCBxdWFsaXR5LCB3aWR0aDogdyB9KX0gJHtcbiAgICAgICAgICAgIGtpbmQgPT09ICd3JyA/IHcgOiBpICsgMVxuICAgICAgICAgIH0ke2tpbmR9YFxuICAgICAgKVxuICAgICAgLmpvaW4oJywgJyksXG5cbiAgICAvLyBJdCdzIGludGVuZGVkIHRvIGtlZXAgYHNyY2AgdGhlIGxhc3QgYXR0cmlidXRlIGJlY2F1c2UgUmVhY3QgdXBkYXRlc1xuICAgIC8vIGF0dHJpYnV0ZXMgaW4gb3JkZXIuIElmIHdlIGtlZXAgYHNyY2AgdGhlIGZpcnN0IG9uZSwgU2FmYXJpIHdpbGxcbiAgICAvLyBpbW1lZGlhdGVseSBzdGFydCB0byBmZXRjaCBgc3JjYCwgYmVmb3JlIGBzaXplc2AgYW5kIGBzcmNTZXRgIGFyZSBldmVuXG4gICAgLy8gdXBkYXRlZCBieSBSZWFjdC4gVGhhdCBjYXVzZXMgbXVsdGlwbGUgdW5uZWNlc3NhcnkgcmVxdWVzdHMgaWYgYHNyY1NldGBcbiAgICAvLyBhbmQgYHNpemVzYCBhcmUgZGVmaW5lZC5cbiAgICAvLyBUaGlzIGJ1ZyBjYW5ub3QgYmUgcmVwcm9kdWNlZCBpbiBDaHJvbWUgb3IgRmlyZWZveC5cbiAgICBzcmM6IGxvYWRlcih7IGNvbmZpZywgc3JjLCBxdWFsaXR5LCB3aWR0aDogd2lkdGhzW2xhc3RdIH0pLFxuICB9XG59XG5cbi8qKlxuICogQSBzaGFyZWQgZnVuY3Rpb24sIHVzZWQgb24gYm90aCBjbGllbnQgYW5kIHNlcnZlciwgdG8gZ2VuZXJhdGUgdGhlIHByb3BzIGZvciA8aW1nPi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEltZ1Byb3BzKFxuICB7XG4gICAgc3JjLFxuICAgIHNpemVzLFxuICAgIHVub3B0aW1pemVkID0gZmFsc2UsXG4gICAgcHJpb3JpdHkgPSBmYWxzZSxcbiAgICBsb2FkaW5nLFxuICAgIGNsYXNzTmFtZSxcbiAgICBxdWFsaXR5LFxuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICBmaWxsID0gZmFsc2UsXG4gICAgc3R5bGUsXG4gICAgb3ZlcnJpZGVTcmMsXG4gICAgb25Mb2FkLFxuICAgIG9uTG9hZGluZ0NvbXBsZXRlLFxuICAgIHBsYWNlaG9sZGVyID0gJ2VtcHR5JyxcbiAgICBibHVyRGF0YVVSTCxcbiAgICBmZXRjaFByaW9yaXR5LFxuICAgIGRlY29kaW5nID0gJ2FzeW5jJyxcbiAgICBsYXlvdXQsXG4gICAgb2JqZWN0Rml0LFxuICAgIG9iamVjdFBvc2l0aW9uLFxuICAgIGxhenlCb3VuZGFyeSxcbiAgICBsYXp5Um9vdCxcbiAgICAuLi5yZXN0XG4gIH06IEltYWdlUHJvcHMsXG4gIF9zdGF0ZToge1xuICAgIGRlZmF1bHRMb2FkZXI6IEltYWdlTG9hZGVyV2l0aENvbmZpZ1xuICAgIGltZ0NvbmY6IEltYWdlQ29uZmlnQ29tcGxldGVcbiAgICBzaG93QWx0VGV4dD86IGJvb2xlYW5cbiAgICBibHVyQ29tcGxldGU/OiBib29sZWFuXG4gIH1cbik6IHtcbiAgcHJvcHM6IEltZ1Byb3BzXG4gIG1ldGE6IHtcbiAgICB1bm9wdGltaXplZDogYm9vbGVhblxuICAgIHByaW9yaXR5OiBib29sZWFuXG4gICAgcGxhY2Vob2xkZXI6IE5vbk51bGxhYmxlPEltYWdlUHJvcHNbJ3BsYWNlaG9sZGVyJ10+XG4gICAgZmlsbDogYm9vbGVhblxuICB9XG59IHtcbiAgY29uc3QgeyBpbWdDb25mLCBzaG93QWx0VGV4dCwgYmx1ckNvbXBsZXRlLCBkZWZhdWx0TG9hZGVyIH0gPSBfc3RhdGVcbiAgbGV0IGNvbmZpZzogSW1hZ2VDb25maWdcbiAgbGV0IGMgPSBpbWdDb25mIHx8IGltYWdlQ29uZmlnRGVmYXVsdFxuICBpZiAoJ2FsbFNpemVzJyBpbiBjKSB7XG4gICAgY29uZmlnID0gYyBhcyBJbWFnZUNvbmZpZ1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGFsbFNpemVzID0gWy4uLmMuZGV2aWNlU2l6ZXMsIC4uLmMuaW1hZ2VTaXplc10uc29ydCgoYSwgYikgPT4gYSAtIGIpXG4gICAgY29uc3QgZGV2aWNlU2l6ZXMgPSBjLmRldmljZVNpemVzLnNvcnQoKGEsIGIpID0+IGEgLSBiKVxuICAgIGNvbnN0IHF1YWxpdGllcyA9IGMucXVhbGl0aWVzPy5zb3J0KChhLCBiKSA9PiBhIC0gYilcbiAgICBjb25maWcgPSB7IC4uLmMsIGFsbFNpemVzLCBkZXZpY2VTaXplcywgcXVhbGl0aWVzIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgZGVmYXVsdExvYWRlciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnaW1hZ2VzLmxvYWRlckZpbGUgZGV0ZWN0ZWQgYnV0IHRoZSBmaWxlIGlzIG1pc3NpbmcgZGVmYXVsdCBleHBvcnQuXFxuUmVhZCBtb3JlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9pbnZhbGlkLWltYWdlcy1jb25maWcnXG4gICAgKVxuICB9XG4gIGxldCBsb2FkZXI6IEltYWdlTG9hZGVyV2l0aENvbmZpZyA9IHJlc3QubG9hZGVyIHx8IGRlZmF1bHRMb2FkZXJcblxuICAvLyBSZW1vdmUgcHJvcGVydHkgc28gaXQncyBub3Qgc3ByZWFkIG9uIDxpbWc+IGVsZW1lbnRcbiAgZGVsZXRlIHJlc3QubG9hZGVyXG4gIGRlbGV0ZSAocmVzdCBhcyBhbnkpLnNyY1NldFxuXG4gIC8vIFRoaXMgc3BlY2lhbCB2YWx1ZSBpbmRpY2F0ZXMgdGhhdCB0aGUgdXNlclxuICAvLyBkaWRuJ3QgZGVmaW5lIGEgXCJsb2FkZXJcIiBwcm9wIG9yIFwibG9hZGVyXCIgY29uZmlnLlxuICBjb25zdCBpc0RlZmF1bHRMb2FkZXIgPSAnX19uZXh0X2ltZ19kZWZhdWx0JyBpbiBsb2FkZXJcblxuICBpZiAoaXNEZWZhdWx0TG9hZGVyKSB7XG4gICAgaWYgKGNvbmZpZy5sb2FkZXIgPT09ICdjdXN0b20nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBJbWFnZSB3aXRoIHNyYyBcIiR7c3JjfVwiIGlzIG1pc3NpbmcgXCJsb2FkZXJcIiBwcm9wLmAgK1xuICAgICAgICAgIGBcXG5SZWFkIG1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL25leHQtaW1hZ2UtbWlzc2luZy1sb2FkZXJgXG4gICAgICApXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIFRoZSB1c2VyIGRlZmluZWQgYSBcImxvYWRlclwiIHByb3Agb3IgY29uZmlnLlxuICAgIC8vIFNpbmNlIHRoZSBjb25maWcgb2JqZWN0IGlzIGludGVybmFsIG9ubHksIHdlXG4gICAgLy8gbXVzdCBub3QgcGFzcyBpdCB0byB0aGUgdXNlci1kZWZpbmVkIFwibG9hZGVyXCIuXG4gICAgY29uc3QgY3VzdG9tSW1hZ2VMb2FkZXIgPSBsb2FkZXIgYXMgSW1hZ2VMb2FkZXJcbiAgICBsb2FkZXIgPSAob2JqKSA9PiB7XG4gICAgICBjb25zdCB7IGNvbmZpZzogXywgLi4ub3B0cyB9ID0gb2JqXG4gICAgICByZXR1cm4gY3VzdG9tSW1hZ2VMb2FkZXIob3B0cylcbiAgICB9XG4gIH1cblxuICBpZiAobGF5b3V0KSB7XG4gICAgaWYgKGxheW91dCA9PT0gJ2ZpbGwnKSB7XG4gICAgICBmaWxsID0gdHJ1ZVxuICAgIH1cbiAgICBjb25zdCBsYXlvdXRUb1N0eWxlOiBSZWNvcmQ8c3RyaW5nLCBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+IHwgdW5kZWZpbmVkPiA9IHtcbiAgICAgIGludHJpbnNpYzogeyBtYXhXaWR0aDogJzEwMCUnLCBoZWlnaHQ6ICdhdXRvJyB9LFxuICAgICAgcmVzcG9uc2l2ZTogeyB3aWR0aDogJzEwMCUnLCBoZWlnaHQ6ICdhdXRvJyB9LFxuICAgIH1cbiAgICBjb25zdCBsYXlvdXRUb1NpemVzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmcgfCB1bmRlZmluZWQ+ID0ge1xuICAgICAgcmVzcG9uc2l2ZTogJzEwMHZ3JyxcbiAgICAgIGZpbGw6ICcxMDB2dycsXG4gICAgfVxuICAgIGNvbnN0IGxheW91dFN0eWxlID0gbGF5b3V0VG9TdHlsZVtsYXlvdXRdXG4gICAgaWYgKGxheW91dFN0eWxlKSB7XG4gICAgICBzdHlsZSA9IHsgLi4uc3R5bGUsIC4uLmxheW91dFN0eWxlIH1cbiAgICB9XG4gICAgY29uc3QgbGF5b3V0U2l6ZXMgPSBsYXlvdXRUb1NpemVzW2xheW91dF1cbiAgICBpZiAobGF5b3V0U2l6ZXMgJiYgIXNpemVzKSB7XG4gICAgICBzaXplcyA9IGxheW91dFNpemVzXG4gICAgfVxuICB9XG5cbiAgbGV0IHN0YXRpY1NyYyA9ICcnXG4gIGxldCB3aWR0aEludCA9IGdldEludCh3aWR0aClcbiAgbGV0IGhlaWdodEludCA9IGdldEludChoZWlnaHQpXG4gIGxldCBibHVyV2lkdGg6IG51bWJlciB8IHVuZGVmaW5lZFxuICBsZXQgYmx1ckhlaWdodDogbnVtYmVyIHwgdW5kZWZpbmVkXG4gIGlmIChpc1N0YXRpY0ltcG9ydChzcmMpKSB7XG4gICAgY29uc3Qgc3RhdGljSW1hZ2VEYXRhID0gaXNTdGF0aWNSZXF1aXJlKHNyYykgPyBzcmMuZGVmYXVsdCA6IHNyY1xuXG4gICAgaWYgKCFzdGF0aWNJbWFnZURhdGEuc3JjKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBBbiBvYmplY3Qgc2hvdWxkIG9ubHkgYmUgcGFzc2VkIHRvIHRoZSBpbWFnZSBjb21wb25lbnQgc3JjIHBhcmFtZXRlciBpZiBpdCBjb21lcyBmcm9tIGEgc3RhdGljIGltYWdlIGltcG9ydC4gSXQgbXVzdCBpbmNsdWRlIHNyYy4gUmVjZWl2ZWQgJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICBzdGF0aWNJbWFnZURhdGFcbiAgICAgICAgKX1gXG4gICAgICApXG4gICAgfVxuICAgIGlmICghc3RhdGljSW1hZ2VEYXRhLmhlaWdodCB8fCAhc3RhdGljSW1hZ2VEYXRhLndpZHRoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBBbiBvYmplY3Qgc2hvdWxkIG9ubHkgYmUgcGFzc2VkIHRvIHRoZSBpbWFnZSBjb21wb25lbnQgc3JjIHBhcmFtZXRlciBpZiBpdCBjb21lcyBmcm9tIGEgc3RhdGljIGltYWdlIGltcG9ydC4gSXQgbXVzdCBpbmNsdWRlIGhlaWdodCBhbmQgd2lkdGguIFJlY2VpdmVkICR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgc3RhdGljSW1hZ2VEYXRhXG4gICAgICAgICl9YFxuICAgICAgKVxuICAgIH1cblxuICAgIGJsdXJXaWR0aCA9IHN0YXRpY0ltYWdlRGF0YS5ibHVyV2lkdGhcbiAgICBibHVySGVpZ2h0ID0gc3RhdGljSW1hZ2VEYXRhLmJsdXJIZWlnaHRcbiAgICBibHVyRGF0YVVSTCA9IGJsdXJEYXRhVVJMIHx8IHN0YXRpY0ltYWdlRGF0YS5ibHVyRGF0YVVSTFxuICAgIHN0YXRpY1NyYyA9IHN0YXRpY0ltYWdlRGF0YS5zcmNcblxuICAgIGlmICghZmlsbCkge1xuICAgICAgaWYgKCF3aWR0aEludCAmJiAhaGVpZ2h0SW50KSB7XG4gICAgICAgIHdpZHRoSW50ID0gc3RhdGljSW1hZ2VEYXRhLndpZHRoXG4gICAgICAgIGhlaWdodEludCA9IHN0YXRpY0ltYWdlRGF0YS5oZWlnaHRcbiAgICAgIH0gZWxzZSBpZiAod2lkdGhJbnQgJiYgIWhlaWdodEludCkge1xuICAgICAgICBjb25zdCByYXRpbyA9IHdpZHRoSW50IC8gc3RhdGljSW1hZ2VEYXRhLndpZHRoXG4gICAgICAgIGhlaWdodEludCA9IE1hdGgucm91bmQoc3RhdGljSW1hZ2VEYXRhLmhlaWdodCAqIHJhdGlvKVxuICAgICAgfSBlbHNlIGlmICghd2lkdGhJbnQgJiYgaGVpZ2h0SW50KSB7XG4gICAgICAgIGNvbnN0IHJhdGlvID0gaGVpZ2h0SW50IC8gc3RhdGljSW1hZ2VEYXRhLmhlaWdodFxuICAgICAgICB3aWR0aEludCA9IE1hdGgucm91bmQoc3RhdGljSW1hZ2VEYXRhLndpZHRoICogcmF0aW8pXG4gICAgICB9XG4gICAgfVxuICB9XG4gIHNyYyA9IHR5cGVvZiBzcmMgPT09ICdzdHJpbmcnID8gc3JjIDogc3RhdGljU3JjXG5cbiAgbGV0IGlzTGF6eSA9XG4gICAgIXByaW9yaXR5ICYmIChsb2FkaW5nID09PSAnbGF6eScgfHwgdHlwZW9mIGxvYWRpbmcgPT09ICd1bmRlZmluZWQnKVxuICBpZiAoIXNyYyB8fCBzcmMuc3RhcnRzV2l0aCgnZGF0YTonKSB8fCBzcmMuc3RhcnRzV2l0aCgnYmxvYjonKSkge1xuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0hUVFAvQmFzaWNzX29mX0hUVFAvRGF0YV9VUklzXG4gICAgdW5vcHRpbWl6ZWQgPSB0cnVlXG4gICAgaXNMYXp5ID0gZmFsc2VcbiAgfVxuICBpZiAoY29uZmlnLnVub3B0aW1pemVkKSB7XG4gICAgdW5vcHRpbWl6ZWQgPSB0cnVlXG4gIH1cbiAgaWYgKFxuICAgIGlzRGVmYXVsdExvYWRlciAmJlxuICAgICFjb25maWcuZGFuZ2Vyb3VzbHlBbGxvd1NWRyAmJlxuICAgIHNyYy5zcGxpdCgnPycsIDEpWzBdLmVuZHNXaXRoKCcuc3ZnJylcbiAgKSB7XG4gICAgLy8gU3BlY2lhbCBjYXNlIHRvIG1ha2Ugc3ZnIHNlcnZlIGFzLWlzIHRvIGF2b2lkIHByb3h5aW5nXG4gICAgLy8gdGhyb3VnaCB0aGUgYnVpbHQtaW4gSW1hZ2UgT3B0aW1pemF0aW9uIEFQSS5cbiAgICB1bm9wdGltaXplZCA9IHRydWVcbiAgfVxuXG4gIGNvbnN0IHF1YWxpdHlJbnQgPSBnZXRJbnQocXVhbGl0eSlcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlmIChjb25maWcub3V0cHV0ID09PSAnZXhwb3J0JyAmJiBpc0RlZmF1bHRMb2FkZXIgJiYgIXVub3B0aW1pemVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBJbWFnZSBPcHRpbWl6YXRpb24gdXNpbmcgdGhlIGRlZmF1bHQgbG9hZGVyIGlzIG5vdCBjb21wYXRpYmxlIHdpdGggXFxgeyBvdXRwdXQ6ICdleHBvcnQnIH1cXGAuXG4gIFBvc3NpYmxlIHNvbHV0aW9uczpcbiAgICAtIFJlbW92ZSBcXGB7IG91dHB1dDogJ2V4cG9ydCcgfVxcYCBhbmQgcnVuIFwibmV4dCBzdGFydFwiIHRvIHJ1biBzZXJ2ZXIgbW9kZSBpbmNsdWRpbmcgdGhlIEltYWdlIE9wdGltaXphdGlvbiBBUEkuXG4gICAgLSBDb25maWd1cmUgXFxgeyBpbWFnZXM6IHsgdW5vcHRpbWl6ZWQ6IHRydWUgfSB9XFxgIGluIFxcYG5leHQuY29uZmlnLmpzXFxgIHRvIGRpc2FibGUgdGhlIEltYWdlIE9wdGltaXphdGlvbiBBUEkuXG4gIFJlYWQgbW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvZXhwb3J0LWltYWdlLWFwaWBcbiAgICAgIClcbiAgICB9XG4gICAgaWYgKCFzcmMpIHtcbiAgICAgIC8vIFJlYWN0IGRvZXNuJ3Qgc2hvdyB0aGUgc3RhY2sgdHJhY2UgYW5kIHRoZXJlJ3NcbiAgICAgIC8vIG5vIGBzcmNgIHRvIGhlbHAgaWRlbnRpZnkgd2hpY2ggaW1hZ2UsIHNvIHdlXG4gICAgICAvLyBpbnN0ZWFkIGNvbnNvbGUuZXJyb3IocmVmKSBkdXJpbmcgbW91bnQuXG4gICAgICB1bm9wdGltaXplZCA9IHRydWVcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGZpbGwpIHtcbiAgICAgICAgaWYgKHdpZHRoKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYEltYWdlIHdpdGggc3JjIFwiJHtzcmN9XCIgaGFzIGJvdGggXCJ3aWR0aFwiIGFuZCBcImZpbGxcIiBwcm9wZXJ0aWVzLiBPbmx5IG9uZSBzaG91bGQgYmUgdXNlZC5gXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICAgIGlmIChoZWlnaHQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgSW1hZ2Ugd2l0aCBzcmMgXCIke3NyY31cIiBoYXMgYm90aCBcImhlaWdodFwiIGFuZCBcImZpbGxcIiBwcm9wZXJ0aWVzLiBPbmx5IG9uZSBzaG91bGQgYmUgdXNlZC5gXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICAgIGlmIChzdHlsZT8ucG9zaXRpb24gJiYgc3R5bGUucG9zaXRpb24gIT09ICdhYnNvbHV0ZScpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgSW1hZ2Ugd2l0aCBzcmMgXCIke3NyY31cIiBoYXMgYm90aCBcImZpbGxcIiBhbmQgXCJzdHlsZS5wb3NpdGlvblwiIHByb3BlcnRpZXMuIEltYWdlcyB3aXRoIFwiZmlsbFwiIGFsd2F5cyB1c2UgcG9zaXRpb24gYWJzb2x1dGUgLSBpdCBjYW5ub3QgYmUgbW9kaWZpZWQuYFxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3R5bGU/LndpZHRoICYmIHN0eWxlLndpZHRoICE9PSAnMTAwJScpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgSW1hZ2Ugd2l0aCBzcmMgXCIke3NyY31cIiBoYXMgYm90aCBcImZpbGxcIiBhbmQgXCJzdHlsZS53aWR0aFwiIHByb3BlcnRpZXMuIEltYWdlcyB3aXRoIFwiZmlsbFwiIGFsd2F5cyB1c2Ugd2lkdGggMTAwJSAtIGl0IGNhbm5vdCBiZSBtb2RpZmllZC5gXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICAgIGlmIChzdHlsZT8uaGVpZ2h0ICYmIHN0eWxlLmhlaWdodCAhPT0gJzEwMCUnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYEltYWdlIHdpdGggc3JjIFwiJHtzcmN9XCIgaGFzIGJvdGggXCJmaWxsXCIgYW5kIFwic3R5bGUuaGVpZ2h0XCIgcHJvcGVydGllcy4gSW1hZ2VzIHdpdGggXCJmaWxsXCIgYWx3YXlzIHVzZSBoZWlnaHQgMTAwJSAtIGl0IGNhbm5vdCBiZSBtb2RpZmllZC5gXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodHlwZW9mIHdpZHRoSW50ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBJbWFnZSB3aXRoIHNyYyBcIiR7c3JjfVwiIGlzIG1pc3NpbmcgcmVxdWlyZWQgXCJ3aWR0aFwiIHByb3BlcnR5LmBcbiAgICAgICAgICApXG4gICAgICAgIH0gZWxzZSBpZiAoaXNOYU4od2lkdGhJbnQpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYEltYWdlIHdpdGggc3JjIFwiJHtzcmN9XCIgaGFzIGludmFsaWQgXCJ3aWR0aFwiIHByb3BlcnR5LiBFeHBlY3RlZCBhIG51bWVyaWMgdmFsdWUgaW4gcGl4ZWxzIGJ1dCByZWNlaXZlZCBcIiR7d2lkdGh9XCIuYFxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGhlaWdodEludCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgSW1hZ2Ugd2l0aCBzcmMgXCIke3NyY31cIiBpcyBtaXNzaW5nIHJlcXVpcmVkIFwiaGVpZ2h0XCIgcHJvcGVydHkuYFxuICAgICAgICAgIClcbiAgICAgICAgfSBlbHNlIGlmIChpc05hTihoZWlnaHRJbnQpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYEltYWdlIHdpdGggc3JjIFwiJHtzcmN9XCIgaGFzIGludmFsaWQgXCJoZWlnaHRcIiBwcm9wZXJ0eS4gRXhwZWN0ZWQgYSBudW1lcmljIHZhbHVlIGluIHBpeGVscyBidXQgcmVjZWl2ZWQgXCIke2hlaWdodH1cIi5gXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb250cm9sLXJlZ2V4XG4gICAgICAgIGlmICgvXltcXHgwMC1cXHgyMF0vLnRlc3Qoc3JjKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBJbWFnZSB3aXRoIHNyYyBcIiR7c3JjfVwiIGNhbm5vdCBzdGFydCB3aXRoIGEgc3BhY2Ugb3IgY29udHJvbCBjaGFyYWN0ZXIuIFVzZSBzcmMudHJpbVN0YXJ0KCkgdG8gcmVtb3ZlIGl0IG9yIGVuY29kZVVSSUNvbXBvbmVudChzcmMpIHRvIGtlZXAgaXQuYFxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29udHJvbC1yZWdleFxuICAgICAgICBpZiAoL1tcXHgwMC1cXHgyMF0kLy50ZXN0KHNyYykpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgSW1hZ2Ugd2l0aCBzcmMgXCIke3NyY31cIiBjYW5ub3QgZW5kIHdpdGggYSBzcGFjZSBvciBjb250cm9sIGNoYXJhY3Rlci4gVXNlIHNyYy50cmltRW5kKCkgdG8gcmVtb3ZlIGl0IG9yIGVuY29kZVVSSUNvbXBvbmVudChzcmMpIHRvIGtlZXAgaXQuYFxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIVZBTElEX0xPQURJTkdfVkFMVUVTLmluY2x1ZGVzKGxvYWRpbmcpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBJbWFnZSB3aXRoIHNyYyBcIiR7c3JjfVwiIGhhcyBpbnZhbGlkIFwibG9hZGluZ1wiIHByb3BlcnR5LiBQcm92aWRlZCBcIiR7bG9hZGluZ31cIiBzaG91bGQgYmUgb25lIG9mICR7VkFMSURfTE9BRElOR19WQUxVRVMubWFwKFxuICAgICAgICAgIFN0cmluZ1xuICAgICAgICApLmpvaW4oJywnKX0uYFxuICAgICAgKVxuICAgIH1cbiAgICBpZiAocHJpb3JpdHkgJiYgbG9hZGluZyA9PT0gJ2xhenknKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBJbWFnZSB3aXRoIHNyYyBcIiR7c3JjfVwiIGhhcyBib3RoIFwicHJpb3JpdHlcIiBhbmQgXCJsb2FkaW5nPSdsYXp5J1wiIHByb3BlcnRpZXMuIE9ubHkgb25lIHNob3VsZCBiZSB1c2VkLmBcbiAgICAgIClcbiAgICB9XG4gICAgaWYgKFxuICAgICAgcGxhY2Vob2xkZXIgIT09ICdlbXB0eScgJiZcbiAgICAgIHBsYWNlaG9sZGVyICE9PSAnYmx1cicgJiZcbiAgICAgICFwbGFjZWhvbGRlci5zdGFydHNXaXRoKCdkYXRhOmltYWdlLycpXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBJbWFnZSB3aXRoIHNyYyBcIiR7c3JjfVwiIGhhcyBpbnZhbGlkIFwicGxhY2Vob2xkZXJcIiBwcm9wZXJ0eSBcIiR7cGxhY2Vob2xkZXJ9XCIuYFxuICAgICAgKVxuICAgIH1cbiAgICBpZiAocGxhY2Vob2xkZXIgIT09ICdlbXB0eScpIHtcbiAgICAgIGlmICh3aWR0aEludCAmJiBoZWlnaHRJbnQgJiYgd2lkdGhJbnQgKiBoZWlnaHRJbnQgPCAxNjAwKSB7XG4gICAgICAgIHdhcm5PbmNlKFxuICAgICAgICAgIGBJbWFnZSB3aXRoIHNyYyBcIiR7c3JjfVwiIGlzIHNtYWxsZXIgdGhhbiA0MHg0MC4gQ29uc2lkZXIgcmVtb3ZpbmcgdGhlIFwicGxhY2Vob2xkZXJcIiBwcm9wZXJ0eSB0byBpbXByb3ZlIHBlcmZvcm1hbmNlLmBcbiAgICAgICAgKVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAocGxhY2Vob2xkZXIgPT09ICdibHVyJyAmJiAhYmx1ckRhdGFVUkwpIHtcbiAgICAgIGNvbnN0IFZBTElEX0JMVVJfRVhUID0gWydqcGVnJywgJ3BuZycsICd3ZWJwJywgJ2F2aWYnXSAvLyBzaG91bGQgbWF0Y2ggbmV4dC1pbWFnZS1sb2FkZXJcblxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgSW1hZ2Ugd2l0aCBzcmMgXCIke3NyY31cIiBoYXMgXCJwbGFjZWhvbGRlcj0nYmx1cidcIiBwcm9wZXJ0eSBidXQgaXMgbWlzc2luZyB0aGUgXCJibHVyRGF0YVVSTFwiIHByb3BlcnR5LlxuICAgICAgICBQb3NzaWJsZSBzb2x1dGlvbnM6XG4gICAgICAgICAgLSBBZGQgYSBcImJsdXJEYXRhVVJMXCIgcHJvcGVydHksIHRoZSBjb250ZW50cyBzaG91bGQgYmUgYSBzbWFsbCBEYXRhIFVSTCB0byByZXByZXNlbnQgdGhlIGltYWdlXG4gICAgICAgICAgLSBDaGFuZ2UgdGhlIFwic3JjXCIgcHJvcGVydHkgdG8gYSBzdGF0aWMgaW1wb3J0IHdpdGggb25lIG9mIHRoZSBzdXBwb3J0ZWQgZmlsZSB0eXBlczogJHtWQUxJRF9CTFVSX0VYVC5qb2luKFxuICAgICAgICAgICAgJywnXG4gICAgICAgICAgKX0gKGFuaW1hdGVkIGltYWdlcyBub3Qgc3VwcG9ydGVkKVxuICAgICAgICAgIC0gUmVtb3ZlIHRoZSBcInBsYWNlaG9sZGVyXCIgcHJvcGVydHksIGVmZmVjdGl2ZWx5IG5vIGJsdXIgZWZmZWN0XG4gICAgICAgIFJlYWQgbW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvcGxhY2Vob2xkZXItYmx1ci1kYXRhLXVybGBcbiAgICAgIClcbiAgICB9XG4gICAgaWYgKCdyZWYnIGluIHJlc3QpIHtcbiAgICAgIHdhcm5PbmNlKFxuICAgICAgICBgSW1hZ2Ugd2l0aCBzcmMgXCIke3NyY31cIiBpcyB1c2luZyB1bnN1cHBvcnRlZCBcInJlZlwiIHByb3BlcnR5LiBDb25zaWRlciB1c2luZyB0aGUgXCJvbkxvYWRcIiBwcm9wZXJ0eSBpbnN0ZWFkLmBcbiAgICAgIClcbiAgICB9XG5cbiAgICBpZiAoIXVub3B0aW1pemVkICYmICFpc0RlZmF1bHRMb2FkZXIpIHtcbiAgICAgIGNvbnN0IHVybFN0ciA9IGxvYWRlcih7XG4gICAgICAgIGNvbmZpZyxcbiAgICAgICAgc3JjLFxuICAgICAgICB3aWR0aDogd2lkdGhJbnQgfHwgNDAwLFxuICAgICAgICBxdWFsaXR5OiBxdWFsaXR5SW50IHx8IDc1LFxuICAgICAgfSlcbiAgICAgIGxldCB1cmw6IFVSTCB8IHVuZGVmaW5lZFxuICAgICAgdHJ5IHtcbiAgICAgICAgdXJsID0gbmV3IFVSTCh1cmxTdHIpXG4gICAgICB9IGNhdGNoIChlcnIpIHt9XG4gICAgICBpZiAodXJsU3RyID09PSBzcmMgfHwgKHVybCAmJiB1cmwucGF0aG5hbWUgPT09IHNyYyAmJiAhdXJsLnNlYXJjaCkpIHtcbiAgICAgICAgd2Fybk9uY2UoXG4gICAgICAgICAgYEltYWdlIHdpdGggc3JjIFwiJHtzcmN9XCIgaGFzIGEgXCJsb2FkZXJcIiBwcm9wZXJ0eSB0aGF0IGRvZXMgbm90IGltcGxlbWVudCB3aWR0aC4gUGxlYXNlIGltcGxlbWVudCBpdCBvciB1c2UgdGhlIFwidW5vcHRpbWl6ZWRcIiBwcm9wZXJ0eSBpbnN0ZWFkLmAgK1xuICAgICAgICAgICAgYFxcblJlYWQgbW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvbmV4dC1pbWFnZS1taXNzaW5nLWxvYWRlci13aWR0aGBcbiAgICAgICAgKVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChvbkxvYWRpbmdDb21wbGV0ZSkge1xuICAgICAgd2Fybk9uY2UoXG4gICAgICAgIGBJbWFnZSB3aXRoIHNyYyBcIiR7c3JjfVwiIGlzIHVzaW5nIGRlcHJlY2F0ZWQgXCJvbkxvYWRpbmdDb21wbGV0ZVwiIHByb3BlcnR5LiBQbGVhc2UgdXNlIHRoZSBcIm9uTG9hZFwiIHByb3BlcnR5IGluc3RlYWQuYFxuICAgICAgKVxuICAgIH1cblxuICAgIGZvciAoY29uc3QgW2xlZ2FjeUtleSwgbGVnYWN5VmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHtcbiAgICAgIGxheW91dCxcbiAgICAgIG9iamVjdEZpdCxcbiAgICAgIG9iamVjdFBvc2l0aW9uLFxuICAgICAgbGF6eUJvdW5kYXJ5LFxuICAgICAgbGF6eVJvb3QsXG4gICAgfSkpIHtcbiAgICAgIGlmIChsZWdhY3lWYWx1ZSkge1xuICAgICAgICB3YXJuT25jZShcbiAgICAgICAgICBgSW1hZ2Ugd2l0aCBzcmMgXCIke3NyY31cIiBoYXMgbGVnYWN5IHByb3AgXCIke2xlZ2FjeUtleX1cIi4gRGlkIHlvdSBmb3JnZXQgdG8gcnVuIHRoZSBjb2RlbW9kP2AgK1xuICAgICAgICAgICAgYFxcblJlYWQgbW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvbmV4dC1pbWFnZS11cGdyYWRlLXRvLTEzYFxuICAgICAgICApXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICFwZXJmT2JzZXJ2ZXIgJiZcbiAgICAgIHdpbmRvdy5QZXJmb3JtYW5jZU9ic2VydmVyXG4gICAgKSB7XG4gICAgICBwZXJmT2JzZXJ2ZXIgPSBuZXcgUGVyZm9ybWFuY2VPYnNlcnZlcigoZW50cnlMaXN0KSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgZW50cnlMaXN0LmdldEVudHJpZXMoKSkge1xuICAgICAgICAgIC8vIEB0cy1pZ25vcmUgLSBtaXNzaW5nIFwiTGFyZ2VzdENvbnRlbnRmdWxQYWludFwiIGNsYXNzIHdpdGggXCJlbGVtZW50XCIgcHJvcFxuICAgICAgICAgIGNvbnN0IGltZ1NyYyA9IGVudHJ5Py5lbGVtZW50Py5zcmMgfHwgJydcbiAgICAgICAgICBjb25zdCBsY3BJbWFnZSA9IGFsbEltZ3MuZ2V0KGltZ1NyYylcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBsY3BJbWFnZSAmJlxuICAgICAgICAgICAgIWxjcEltYWdlLnByaW9yaXR5ICYmXG4gICAgICAgICAgICBsY3BJbWFnZS5wbGFjZWhvbGRlciA9PT0gJ2VtcHR5JyAmJlxuICAgICAgICAgICAgIWxjcEltYWdlLnNyYy5zdGFydHNXaXRoKCdkYXRhOicpICYmXG4gICAgICAgICAgICAhbGNwSW1hZ2Uuc3JjLnN0YXJ0c1dpdGgoJ2Jsb2I6JylcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vd2ViLmRldi9sY3AvI21lYXN1cmUtbGNwLWluLWphdmFzY3JpcHRcbiAgICAgICAgICAgIHdhcm5PbmNlKFxuICAgICAgICAgICAgICBgSW1hZ2Ugd2l0aCBzcmMgXCIke2xjcEltYWdlLnNyY31cIiB3YXMgZGV0ZWN0ZWQgYXMgdGhlIExhcmdlc3QgQ29udGVudGZ1bCBQYWludCAoTENQKS4gUGxlYXNlIGFkZCB0aGUgXCJwcmlvcml0eVwiIHByb3BlcnR5IGlmIHRoaXMgaW1hZ2UgaXMgYWJvdmUgdGhlIGZvbGQuYCArXG4gICAgICAgICAgICAgICAgYFxcblJlYWQgbW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBpLXJlZmVyZW5jZS9uZXh0L2ltYWdlI3ByaW9yaXR5YFxuICAgICAgICAgICAgKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIHRyeSB7XG4gICAgICAgIHBlcmZPYnNlcnZlci5vYnNlcnZlKHtcbiAgICAgICAgICB0eXBlOiAnbGFyZ2VzdC1jb250ZW50ZnVsLXBhaW50JyxcbiAgICAgICAgICBidWZmZXJlZDogdHJ1ZSxcbiAgICAgICAgfSlcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAvLyBMb2cgZXJyb3IgYnV0IGRvbid0IGNyYXNoIHRoZSBhcHBcbiAgICAgICAgY29uc29sZS5lcnJvcihlcnIpXG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNvbnN0IGltZ1N0eWxlID0gT2JqZWN0LmFzc2lnbihcbiAgICBmaWxsXG4gICAgICA/IHtcbiAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgICBoZWlnaHQ6ICcxMDAlJyxcbiAgICAgICAgICB3aWR0aDogJzEwMCUnLFxuICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgIHJpZ2h0OiAwLFxuICAgICAgICAgIGJvdHRvbTogMCxcbiAgICAgICAgICBvYmplY3RGaXQsXG4gICAgICAgICAgb2JqZWN0UG9zaXRpb24sXG4gICAgICAgIH1cbiAgICAgIDoge30sXG4gICAgc2hvd0FsdFRleHQgPyB7fSA6IHsgY29sb3I6ICd0cmFuc3BhcmVudCcgfSxcbiAgICBzdHlsZVxuICApXG5cbiAgY29uc3QgYmFja2dyb3VuZEltYWdlID1cbiAgICAhYmx1ckNvbXBsZXRlICYmIHBsYWNlaG9sZGVyICE9PSAnZW1wdHknXG4gICAgICA/IHBsYWNlaG9sZGVyID09PSAnYmx1cidcbiAgICAgICAgPyBgdXJsKFwiZGF0YTppbWFnZS9zdmcreG1sO2NoYXJzZXQ9dXRmLTgsJHtnZXRJbWFnZUJsdXJTdmcoe1xuICAgICAgICAgICAgd2lkdGhJbnQsXG4gICAgICAgICAgICBoZWlnaHRJbnQsXG4gICAgICAgICAgICBibHVyV2lkdGgsXG4gICAgICAgICAgICBibHVySGVpZ2h0LFxuICAgICAgICAgICAgYmx1ckRhdGFVUkw6IGJsdXJEYXRhVVJMIHx8ICcnLCAvLyBhc3N1bWUgbm90IHVuZGVmaW5lZFxuICAgICAgICAgICAgb2JqZWN0Rml0OiBpbWdTdHlsZS5vYmplY3RGaXQsXG4gICAgICAgICAgfSl9XCIpYFxuICAgICAgICA6IGB1cmwoXCIke3BsYWNlaG9sZGVyfVwiKWAgLy8gYXNzdW1lIGBkYXRhOmltYWdlL2BcbiAgICAgIDogbnVsbFxuXG4gIGxldCBwbGFjZWhvbGRlclN0eWxlID0gYmFja2dyb3VuZEltYWdlXG4gICAgPyB7XG4gICAgICAgIGJhY2tncm91bmRTaXplOiBpbWdTdHlsZS5vYmplY3RGaXQgfHwgJ2NvdmVyJyxcbiAgICAgICAgYmFja2dyb3VuZFBvc2l0aW9uOiBpbWdTdHlsZS5vYmplY3RQb3NpdGlvbiB8fCAnNTAlIDUwJScsXG4gICAgICAgIGJhY2tncm91bmRSZXBlYXQ6ICduby1yZXBlYXQnLFxuICAgICAgICBiYWNrZ3JvdW5kSW1hZ2UsXG4gICAgICB9XG4gICAgOiB7fVxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgIGlmIChcbiAgICAgIHBsYWNlaG9sZGVyU3R5bGUuYmFja2dyb3VuZEltYWdlICYmXG4gICAgICBwbGFjZWhvbGRlciA9PT0gJ2JsdXInICYmXG4gICAgICBibHVyRGF0YVVSTD8uc3RhcnRzV2l0aCgnLycpXG4gICAgKSB7XG4gICAgICAvLyBEdXJpbmcgYG5leHQgZGV2YCwgd2UgZG9uJ3Qgd2FudCB0byBnZW5lcmF0ZSBibHVyIHBsYWNlaG9sZGVycyB3aXRoIHdlYnBhY2tcbiAgICAgIC8vIGJlY2F1c2UgaXQgY2FuIGRlbGF5IHN0YXJ0aW5nIHRoZSBkZXYgc2VydmVyLiBJbnN0ZWFkLCBgbmV4dC1pbWFnZS1sb2FkZXIuanNgXG4gICAgICAvLyB3aWxsIGlubGluZSBhIHNwZWNpYWwgdXJsIHRvIGxhemlseSBnZW5lcmF0ZSB0aGUgYmx1ciBwbGFjZWhvbGRlciBhdCByZXF1ZXN0IHRpbWUuXG4gICAgICBwbGFjZWhvbGRlclN0eWxlLmJhY2tncm91bmRJbWFnZSA9IGB1cmwoXCIke2JsdXJEYXRhVVJMfVwiKWBcbiAgICB9XG4gIH1cblxuICBjb25zdCBpbWdBdHRyaWJ1dGVzID0gZ2VuZXJhdGVJbWdBdHRycyh7XG4gICAgY29uZmlnLFxuICAgIHNyYyxcbiAgICB1bm9wdGltaXplZCxcbiAgICB3aWR0aDogd2lkdGhJbnQsXG4gICAgcXVhbGl0eTogcXVhbGl0eUludCxcbiAgICBzaXplcyxcbiAgICBsb2FkZXIsXG4gIH0pXG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGxldCBmdWxsVXJsOiBVUkxcbiAgICAgIHRyeSB7XG4gICAgICAgIGZ1bGxVcmwgPSBuZXcgVVJMKGltZ0F0dHJpYnV0ZXMuc3JjKVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBmdWxsVXJsID0gbmV3IFVSTChpbWdBdHRyaWJ1dGVzLnNyYywgd2luZG93LmxvY2F0aW9uLmhyZWYpXG4gICAgICB9XG4gICAgICBhbGxJbWdzLnNldChmdWxsVXJsLmhyZWYsIHsgc3JjLCBwcmlvcml0eSwgcGxhY2Vob2xkZXIgfSlcbiAgICB9XG4gIH1cblxuICBjb25zdCBwcm9wczogSW1nUHJvcHMgPSB7XG4gICAgLi4ucmVzdCxcbiAgICBsb2FkaW5nOiBpc0xhenkgPyAnbGF6eScgOiBsb2FkaW5nLFxuICAgIGZldGNoUHJpb3JpdHksXG4gICAgd2lkdGg6IHdpZHRoSW50LFxuICAgIGhlaWdodDogaGVpZ2h0SW50LFxuICAgIGRlY29kaW5nLFxuICAgIGNsYXNzTmFtZSxcbiAgICBzdHlsZTogeyAuLi5pbWdTdHlsZSwgLi4ucGxhY2Vob2xkZXJTdHlsZSB9LFxuICAgIHNpemVzOiBpbWdBdHRyaWJ1dGVzLnNpemVzLFxuICAgIHNyY1NldDogaW1nQXR0cmlidXRlcy5zcmNTZXQsXG4gICAgc3JjOiBvdmVycmlkZVNyYyB8fCBpbWdBdHRyaWJ1dGVzLnNyYyxcbiAgfVxuICBjb25zdCBtZXRhID0geyB1bm9wdGltaXplZCwgcHJpb3JpdHksIHBsYWNlaG9sZGVyLCBmaWxsIH1cbiAgcmV0dXJuIHsgcHJvcHMsIG1ldGEgfVxufVxuIl0sIm5hbWVzIjpbImdldEltZ1Byb3BzIiwiVkFMSURfTE9BRElOR19WQUxVRVMiLCJ1bmRlZmluZWQiLCJpc1N0YXRpY1JlcXVpcmUiLCJzcmMiLCJkZWZhdWx0IiwiaXNTdGF0aWNJbWFnZURhdGEiLCJpc1N0YXRpY0ltcG9ydCIsImFsbEltZ3MiLCJNYXAiLCJwZXJmT2JzZXJ2ZXIiLCJnZXRJbnQiLCJ4IiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJOYU4iLCJ0ZXN0IiwicGFyc2VJbnQiLCJnZXRXaWR0aHMiLCJ3aWR0aCIsInNpemVzIiwiZGV2aWNlU2l6ZXMiLCJhbGxTaXplcyIsInZpZXdwb3J0V2lkdGhSZSIsInBlcmNlbnRTaXplcyIsIm1hdGNoIiwiZXhlYyIsInB1c2giLCJsZW5ndGgiLCJzbWFsbGVzdFJhdGlvIiwiTWF0aCIsIm1pbiIsIndpZHRocyIsImZpbHRlciIsInMiLCJraW5kIiwiU2V0IiwibWFwIiwidyIsImZpbmQiLCJwIiwiZ2VuZXJhdGVJbWdBdHRycyIsImNvbmZpZyIsInVub3B0aW1pemVkIiwicXVhbGl0eSIsImxvYWRlciIsInNyY1NldCIsImxhc3QiLCJpIiwiam9pbiIsIl9zdGF0ZSIsInByaW9yaXR5IiwibG9hZGluZyIsImNsYXNzTmFtZSIsImhlaWdodCIsImZpbGwiLCJzdHlsZSIsIm92ZXJyaWRlU3JjIiwib25Mb2FkIiwib25Mb2FkaW5nQ29tcGxldGUiLCJwbGFjZWhvbGRlciIsImJsdXJEYXRhVVJMIiwiZmV0Y2hQcmlvcml0eSIsImRlY29kaW5nIiwibGF5b3V0Iiwib2JqZWN0Rml0Iiwib2JqZWN0UG9zaXRpb24iLCJsYXp5Qm91bmRhcnkiLCJsYXp5Um9vdCIsInJlc3QiLCJpbWdDb25mIiwic2hvd0FsdFRleHQiLCJibHVyQ29tcGxldGUiLCJkZWZhdWx0TG9hZGVyIiwiYyIsImltYWdlQ29uZmlnRGVmYXVsdCIsImltYWdlU2l6ZXMiLCJzb3J0IiwiYSIsImIiLCJxdWFsaXRpZXMiLCJFcnJvciIsImlzRGVmYXVsdExvYWRlciIsImN1c3RvbUltYWdlTG9hZGVyIiwib2JqIiwiXyIsIm9wdHMiLCJsYXlvdXRUb1N0eWxlIiwiaW50cmluc2ljIiwibWF4V2lkdGgiLCJyZXNwb25zaXZlIiwibGF5b3V0VG9TaXplcyIsImxheW91dFN0eWxlIiwibGF5b3V0U2l6ZXMiLCJzdGF0aWNTcmMiLCJ3aWR0aEludCIsImhlaWdodEludCIsImJsdXJXaWR0aCIsImJsdXJIZWlnaHQiLCJzdGF0aWNJbWFnZURhdGEiLCJKU09OIiwic3RyaW5naWZ5IiwicmF0aW8iLCJyb3VuZCIsImlzTGF6eSIsInN0YXJ0c1dpdGgiLCJkYW5nZXJvdXNseUFsbG93U1ZHIiwic3BsaXQiLCJlbmRzV2l0aCIsInF1YWxpdHlJbnQiLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJvdXRwdXQiLCJwb3NpdGlvbiIsImlzTmFOIiwiaW5jbHVkZXMiLCJTdHJpbmciLCJ3YXJuT25jZSIsIlZBTElEX0JMVVJfRVhUIiwidXJsU3RyIiwidXJsIiwiVVJMIiwiZXJyIiwicGF0aG5hbWUiLCJzZWFyY2giLCJsZWdhY3lLZXkiLCJsZWdhY3lWYWx1ZSIsIk9iamVjdCIsImVudHJpZXMiLCJ3aW5kb3ciLCJQZXJmb3JtYW5jZU9ic2VydmVyIiwiZW50cnlMaXN0IiwiZW50cnkiLCJnZXRFbnRyaWVzIiwiaW1nU3JjIiwiZWxlbWVudCIsImxjcEltYWdlIiwiZ2V0Iiwib2JzZXJ2ZSIsInR5cGUiLCJidWZmZXJlZCIsImNvbnNvbGUiLCJlcnJvciIsImltZ1N0eWxlIiwiYXNzaWduIiwibGVmdCIsInRvcCIsInJpZ2h0IiwiYm90dG9tIiwiY29sb3IiLCJiYWNrZ3JvdW5kSW1hZ2UiLCJnZXRJbWFnZUJsdXJTdmciLCJwbGFjZWhvbGRlclN0eWxlIiwiYmFja2dyb3VuZFNpemUiLCJiYWNrZ3JvdW5kUG9zaXRpb24iLCJiYWNrZ3JvdW5kUmVwZWF0IiwiaW1nQXR0cmlidXRlcyIsImZ1bGxVcmwiLCJlIiwibG9jYXRpb24iLCJocmVmIiwic2V0IiwicHJvcHMiLCJtZXRhIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/get-img-props.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/head.js":
/*!***************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/head.js ***!
  \***************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    default: function() {\n        return _default;\n    },\n    defaultHead: function() {\n        return defaultHead;\n    }\n});\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nconst _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js\");\nconst _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nconst _sideeffect = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ./side-effect */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/side-effect.js\"));\nconst _ampcontextsharedruntime = __webpack_require__(/*! ./amp-context.shared-runtime */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/amp-context.shared-runtime.js\");\nconst _headmanagercontextsharedruntime = __webpack_require__(/*! ./head-manager-context.shared-runtime */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/head-manager-context.shared-runtime.js\");\nconst _ampmode = __webpack_require__(/*! ./amp-mode */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/amp-mode.js\");\nconst _warnonce = __webpack_require__(/*! ./utils/warn-once */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/utils/warn-once.js\");\nfunction defaultHead(inAmpMode) {\n    if (inAmpMode === void 0) inAmpMode = false;\n    const head = [\n        /*#__PURE__*/ (0, _jsxruntime.jsx)(\"meta\", {\n            charSet: \"utf-8\"\n        }, \"charset\")\n    ];\n    if (!inAmpMode) {\n        head.push(/*#__PURE__*/ (0, _jsxruntime.jsx)(\"meta\", {\n            name: \"viewport\",\n            content: \"width=device-width\"\n        }, \"viewport\"));\n    }\n    return head;\n}\nfunction onlyReactElement(list, child) {\n    // React children can be \"string\" or \"number\" in this case we ignore them for backwards compat\n    if (typeof child === 'string' || typeof child === 'number') {\n        return list;\n    }\n    // Adds support for React.Fragment\n    if (child.type === _react.default.Fragment) {\n        return list.concat(_react.default.Children.toArray(child.props.children).reduce((fragmentList, fragmentChild)=>{\n            if (typeof fragmentChild === 'string' || typeof fragmentChild === 'number') {\n                return fragmentList;\n            }\n            return fragmentList.concat(fragmentChild);\n        }, []));\n    }\n    return list.concat(child);\n}\nconst METATYPES = [\n    'name',\n    'httpEquiv',\n    'charSet',\n    'itemProp'\n];\n/*\n returns a function for filtering head child elements\n which shouldn't be duplicated, like <title/>\n Also adds support for deduplicated `key` properties\n*/ function unique() {\n    const keys = new Set();\n    const tags = new Set();\n    const metaTypes = new Set();\n    const metaCategories = {};\n    return (h)=>{\n        let isUnique = true;\n        let hasKey = false;\n        if (h.key && typeof h.key !== 'number' && h.key.indexOf('$') > 0) {\n            hasKey = true;\n            const key = h.key.slice(h.key.indexOf('$') + 1);\n            if (keys.has(key)) {\n                isUnique = false;\n            } else {\n                keys.add(key);\n            }\n        }\n        // eslint-disable-next-line default-case\n        switch(h.type){\n            case 'title':\n            case 'base':\n                if (tags.has(h.type)) {\n                    isUnique = false;\n                } else {\n                    tags.add(h.type);\n                }\n                break;\n            case 'meta':\n                for(let i = 0, len = METATYPES.length; i < len; i++){\n                    const metatype = METATYPES[i];\n                    if (!h.props.hasOwnProperty(metatype)) continue;\n                    if (metatype === 'charSet') {\n                        if (metaTypes.has(metatype)) {\n                            isUnique = false;\n                        } else {\n                            metaTypes.add(metatype);\n                        }\n                    } else {\n                        const category = h.props[metatype];\n                        const categories = metaCategories[metatype] || new Set();\n                        if ((metatype !== 'name' || !hasKey) && categories.has(category)) {\n                            isUnique = false;\n                        } else {\n                            categories.add(category);\n                            metaCategories[metatype] = categories;\n                        }\n                    }\n                }\n                break;\n        }\n        return isUnique;\n    };\n}\n/**\n *\n * @param headChildrenElements List of children of <Head>\n */ function reduceComponents(headChildrenElements, props) {\n    const { inAmpMode } = props;\n    return headChildrenElements.reduce(onlyReactElement, []).reverse().concat(defaultHead(inAmpMode).reverse()).filter(unique()).reverse().map((c, i)=>{\n        const key = c.key || i;\n        if (false) {}\n        if (true) {\n            // omit JSON-LD structured data snippets from the warning\n            if (c.type === 'script' && c.props['type'] !== 'application/ld+json') {\n                const srcMessage = c.props['src'] ? '<script> tag with src=\"' + c.props['src'] + '\"' : \"inline <script>\";\n                (0, _warnonce.warnOnce)(\"Do not add <script> tags using next/head (see \" + srcMessage + \"). Use next/script instead. \\nSee more info here: https://nextjs.org/docs/messages/no-script-tags-in-head-component\");\n            } else if (c.type === 'link' && c.props['rel'] === 'stylesheet') {\n                (0, _warnonce.warnOnce)('Do not add stylesheets using next/head (see <link rel=\"stylesheet\"> tag with href=\"' + c.props['href'] + '\"). Use Document instead. \\nSee more info here: https://nextjs.org/docs/messages/no-stylesheets-in-head-component');\n            }\n        }\n        return /*#__PURE__*/ _react.default.cloneElement(c, {\n            key\n        });\n    });\n}\n/**\n * This component injects elements to `<head>` of your page.\n * To avoid duplicated `tags` in `<head>` you can use the `key` property, which will make sure every tag is only rendered once.\n */ function Head(param) {\n    let { children } = param;\n    const ampState = (0, _react.useContext)(_ampcontextsharedruntime.AmpStateContext);\n    const headManager = (0, _react.useContext)(_headmanagercontextsharedruntime.HeadManagerContext);\n    return /*#__PURE__*/ (0, _jsxruntime.jsx)(_sideeffect.default, {\n        reduceComponentsToState: reduceComponents,\n        headManager: headManager,\n        inAmpMode: (0, _ampmode.isInAmpMode)(ampState),\n        children: children\n    });\n}\n_c = Head;\nconst _default = Head;\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=head.js.map\nvar _c;\n$RefreshReg$(_c, \"Head\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9oZWFkLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztJQXVNQSxPQUFtQjtlQUFuQjs7SUExTGdCQSxXQUFXO2VBQVhBOzs7Ozs7NkVBWDRCO2lGQUN6QjtxREFDYTs2REFDRztxQ0FDUDtzQ0FDSDtBQU1sQixTQUFTQSxZQUFZQyxTQUFpQjtJQUFqQkEsSUFBQUEsY0FBQUEsS0FBQUEsR0FBQUEsWUFBWTtJQUN0QyxNQUFNQyxPQUFPO3NCQUFDLHFCQUFDQyxRQUFBQTtZQUFLQyxTQUFRO1dBQVk7S0FBYTtJQUNyRCxJQUFJLENBQUNILFdBQVc7UUFDZEMsS0FBS0csSUFBSSxlQUNQLHFCQUFDRixRQUFBQTtZQUFLRyxNQUFLO1lBQVdDLFNBQVE7V0FBeUI7SUFFM0Q7SUFDQSxPQUFPTDtBQUNUO0FBRUEsU0FBU00saUJBQ1BDLElBQW9DLEVBQ3BDQyxLQUEyQztJQUUzQyw4RkFBOEY7SUFDOUYsSUFBSSxPQUFPQSxVQUFVLFlBQVksT0FBT0EsVUFBVSxVQUFVO1FBQzFELE9BQU9EO0lBQ1Q7SUFDQSxrQ0FBa0M7SUFDbEMsSUFBSUMsTUFBTUMsSUFBSSxLQUFLQyxPQUFBQSxPQUFLLENBQUNDLFFBQVEsRUFBRTtRQUNqQyxPQUFPSixLQUFLSyxNQUFNLENBQ2hCLE9BQ0FGLE9BQUssQ0FBQ0csUUFBUSxDQUFDQyxPQUFPLENBQUNOLE1BQU1PLEtBQUssQ0FBQ0MsUUFBUSxFQUFFQyxNQUFNLENBQ2pELENBRUVDLGNBQ0FDO1lBRUEsSUFDRSxPQUFPQSxrQkFBa0IsWUFDekIsT0FBT0Esa0JBQWtCLFVBQ3pCO2dCQUNBLE9BQU9EO1lBQ1Q7WUFDQSxPQUFPQSxhQUFhTixNQUFNLENBQUNPO1FBQzdCLEdBQ0EsRUFBRTtJQUdSO0lBQ0EsT0FBT1osS0FBS0ssTUFBTSxDQUFDSjtBQUNyQjtBQUVBLE1BQU1ZLFlBQVk7SUFBQztJQUFRO0lBQWE7SUFBVztDQUFX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LENBQUMsTUFBTSxLQUFLLGNBQWM7Z0JBQy9ENEMsQ0FBQUEsR0FBQUEsVUFBQUEsUUFBQUEsRUFDRyx3RkFBcUZaLEVBQUVoQyxLQUFLLENBQUMsT0FBTyxHQUFDO1lBRTFHO1FBQ0Y7UUFDQSxxQkFBT0wsT0FBQUEsT0FBSyxDQUFDK0MsWUFBWSxDQUFDVixHQUFHO1lBQUVqQjtRQUFJO0lBQ3JDO0FBQ0o7QUFFQTs7O0NBR0MsR0FDRCxjQUFjLEtBQTJDO0lBQTNDLE1BQUVkLFFBQVEsRUFBaUMsR0FBM0M7SUFDWixNQUFNNkMsV0FBV0MsQ0FBQUEsR0FBQUEsT0FBQUEsVUFBQUEsRUFBV0MseUJBQUFBLGVBQWU7SUFDM0MsTUFBTUMsY0FBY0YsQ0FBQUEsR0FBQUEsT0FBQUEsVUFBQUEsRUFBV0csaUNBQUFBLGtCQUFrQjtJQUNqRCxxQkFDRSxxQkFBQ0MsWUFBQUEsT0FBTTtRQUNMQyx5QkFBeUJ6QjtRQUN6QnNCLGFBQWFBO1FBQ2JqRSxXQUFXcUUsQ0FBQUEsR0FBQUEsU0FBQUEsV0FBQUEsRUFBWVA7a0JBRXRCN0M7O0FBR1A7S0FaUzRDO01BY1QsV0FBZUEiLCJzb3VyY2VzIjpbIi9Vc2Vycy9qb25hdGhhbnZpbmNlbnRpdXMvRG9jdW1lbnRzL3NyYy9zaGFyZWQvbGliL2hlYWQudHN4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50J1xuXG5pbXBvcnQgUmVhY3QsIHsgdXNlQ29udGV4dCwgdHlwZSBKU1ggfSBmcm9tICdyZWFjdCdcbmltcG9ydCBFZmZlY3QgZnJvbSAnLi9zaWRlLWVmZmVjdCdcbmltcG9ydCB7IEFtcFN0YXRlQ29udGV4dCB9IGZyb20gJy4vYW1wLWNvbnRleHQuc2hhcmVkLXJ1bnRpbWUnXG5pbXBvcnQgeyBIZWFkTWFuYWdlckNvbnRleHQgfSBmcm9tICcuL2hlYWQtbWFuYWdlci1jb250ZXh0LnNoYXJlZC1ydW50aW1lJ1xuaW1wb3J0IHsgaXNJbkFtcE1vZGUgfSBmcm9tICcuL2FtcC1tb2RlJ1xuaW1wb3J0IHsgd2Fybk9uY2UgfSBmcm9tICcuL3V0aWxzL3dhcm4tb25jZSdcblxudHlwZSBXaXRoSW5BbXBNb2RlID0ge1xuICBpbkFtcE1vZGU/OiBib29sZWFuXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0SGVhZChpbkFtcE1vZGUgPSBmYWxzZSk6IEpTWC5FbGVtZW50W10ge1xuICBjb25zdCBoZWFkID0gWzxtZXRhIGNoYXJTZXQ9XCJ1dGYtOFwiIGtleT1cImNoYXJzZXRcIiAvPl1cbiAgaWYgKCFpbkFtcE1vZGUpIHtcbiAgICBoZWFkLnB1c2goXG4gICAgICA8bWV0YSBuYW1lPVwidmlld3BvcnRcIiBjb250ZW50PVwid2lkdGg9ZGV2aWNlLXdpZHRoXCIga2V5PVwidmlld3BvcnRcIiAvPlxuICAgIClcbiAgfVxuICByZXR1cm4gaGVhZFxufVxuXG5mdW5jdGlvbiBvbmx5UmVhY3RFbGVtZW50KFxuICBsaXN0OiBBcnJheTxSZWFjdC5SZWFjdEVsZW1lbnQ8YW55Pj4sXG4gIGNoaWxkOiBSZWFjdC5SZWFjdEVsZW1lbnQgfCBudW1iZXIgfCBzdHJpbmdcbik6IEFycmF5PFJlYWN0LlJlYWN0RWxlbWVudDxhbnk+PiB7XG4gIC8vIFJlYWN0IGNoaWxkcmVuIGNhbiBiZSBcInN0cmluZ1wiIG9yIFwibnVtYmVyXCIgaW4gdGhpcyBjYXNlIHdlIGlnbm9yZSB0aGVtIGZvciBiYWNrd2FyZHMgY29tcGF0XG4gIGlmICh0eXBlb2YgY2hpbGQgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBjaGlsZCA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gbGlzdFxuICB9XG4gIC8vIEFkZHMgc3VwcG9ydCBmb3IgUmVhY3QuRnJhZ21lbnRcbiAgaWYgKGNoaWxkLnR5cGUgPT09IFJlYWN0LkZyYWdtZW50KSB7XG4gICAgcmV0dXJuIGxpc3QuY29uY2F0KFxuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBAdHlwZXMvcmVhY3QgZG9lcyBub3QgcmVtb3ZlIGZyYWdtZW50cyBidXQgdGhpcyBjb3VsZCBhbHNvIHJldHVybiBSZWFjdFBvcnRhbFtdXG4gICAgICBSZWFjdC5DaGlsZHJlbi50b0FycmF5KGNoaWxkLnByb3BzLmNoaWxkcmVuKS5yZWR1Y2UoXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgQHR5cGVzL3JlYWN0IGRvZXMgbm90IHJlbW92ZSBmcmFnbWVudHMgYnV0IHRoaXMgY291bGQgYWxzbyByZXR1cm4gUmVhY3RQb3J0YWxbXVxuICAgICAgICAoXG4gICAgICAgICAgZnJhZ21lbnRMaXN0OiBBcnJheTxSZWFjdC5SZWFjdEVsZW1lbnQ8YW55Pj4sXG4gICAgICAgICAgZnJhZ21lbnRDaGlsZDogUmVhY3QuUmVhY3RFbGVtZW50IHwgbnVtYmVyIHwgc3RyaW5nXG4gICAgICAgICk6IEFycmF5PFJlYWN0LlJlYWN0RWxlbWVudDxhbnk+PiA9PiB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgdHlwZW9mIGZyYWdtZW50Q2hpbGQgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgICAgICB0eXBlb2YgZnJhZ21lbnRDaGlsZCA9PT0gJ251bWJlcidcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiBmcmFnbWVudExpc3RcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZyYWdtZW50TGlzdC5jb25jYXQoZnJhZ21lbnRDaGlsZClcbiAgICAgICAgfSxcbiAgICAgICAgW11cbiAgICAgIClcbiAgICApXG4gIH1cbiAgcmV0dXJuIGxpc3QuY29uY2F0KGNoaWxkKVxufVxuXG5jb25zdCBNRVRBVFlQRVMgPSBbJ25hbWUnLCAnaHR0cEVxdWl2JywgJ2NoYXJTZXQnLCAnaXRlbVByb3AnXVxuXG4vKlxuIHJldHVybnMgYSBmdW5jdGlvbiBmb3IgZmlsdGVyaW5nIGhlYWQgY2hpbGQgZWxlbWVudHNcbiB3aGljaCBzaG91bGRuJ3QgYmUgZHVwbGljYXRlZCwgbGlrZSA8dGl0bGUvPlxuIEFsc28gYWRkcyBzdXBwb3J0IGZvciBkZWR1cGxpY2F0ZWQgYGtleWAgcHJvcGVydGllc1xuKi9cbmZ1bmN0aW9uIHVuaXF1ZSgpIHtcbiAgY29uc3Qga2V5cyA9IG5ldyBTZXQoKVxuICBjb25zdCB0YWdzID0gbmV3IFNldCgpXG4gIGNvbnN0IG1ldGFUeXBlcyA9IG5ldyBTZXQoKVxuICBjb25zdCBtZXRhQ2F0ZWdvcmllczogeyBbbWV0YXR5cGU6IHN0cmluZ106IFNldDxzdHJpbmc+IH0gPSB7fVxuXG4gIHJldHVybiAoaDogUmVhY3QuUmVhY3RFbGVtZW50PGFueT4pID0+IHtcbiAgICBsZXQgaXNVbmlxdWUgPSB0cnVlXG4gICAgbGV0IGhhc0tleSA9IGZhbHNlXG5cbiAgICBpZiAoaC5rZXkgJiYgdHlwZW9mIGgua2V5ICE9PSAnbnVtYmVyJyAmJiBoLmtleS5pbmRleE9mKCckJykgPiAwKSB7XG4gICAgICBoYXNLZXkgPSB0cnVlXG4gICAgICBjb25zdCBrZXkgPSBoLmtleS5zbGljZShoLmtleS5pbmRleE9mKCckJykgKyAxKVxuICAgICAgaWYgKGtleXMuaGFzKGtleSkpIHtcbiAgICAgICAgaXNVbmlxdWUgPSBmYWxzZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAga2V5cy5hZGQoa2V5KVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkZWZhdWx0LWNhc2VcbiAgICBzd2l0Y2ggKGgudHlwZSkge1xuICAgICAgY2FzZSAndGl0bGUnOlxuICAgICAgY2FzZSAnYmFzZSc6XG4gICAgICAgIGlmICh0YWdzLmhhcyhoLnR5cGUpKSB7XG4gICAgICAgICAgaXNVbmlxdWUgPSBmYWxzZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRhZ3MuYWRkKGgudHlwZSlcbiAgICAgICAgfVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAnbWV0YSc6XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBNRVRBVFlQRVMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBtZXRhdHlwZSA9IE1FVEFUWVBFU1tpXVxuICAgICAgICAgIGlmICghaC5wcm9wcy5oYXNPd25Qcm9wZXJ0eShtZXRhdHlwZSkpIGNvbnRpbnVlXG5cbiAgICAgICAgICBpZiAobWV0YXR5cGUgPT09ICdjaGFyU2V0Jykge1xuICAgICAgICAgICAgaWYgKG1ldGFUeXBlcy5oYXMobWV0YXR5cGUpKSB7XG4gICAgICAgICAgICAgIGlzVW5pcXVlID0gZmFsc2VcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG1ldGFUeXBlcy5hZGQobWV0YXR5cGUpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGNhdGVnb3J5ID0gaC5wcm9wc1ttZXRhdHlwZV1cbiAgICAgICAgICAgIGNvbnN0IGNhdGVnb3JpZXMgPSBtZXRhQ2F0ZWdvcmllc1ttZXRhdHlwZV0gfHwgbmV3IFNldCgpXG4gICAgICAgICAgICBpZiAoKG1ldGF0eXBlICE9PSAnbmFtZScgfHwgIWhhc0tleSkgJiYgY2F0ZWdvcmllcy5oYXMoY2F0ZWdvcnkpKSB7XG4gICAgICAgICAgICAgIGlzVW5pcXVlID0gZmFsc2VcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNhdGVnb3JpZXMuYWRkKGNhdGVnb3J5KVxuICAgICAgICAgICAgICBtZXRhQ2F0ZWdvcmllc1ttZXRhdHlwZV0gPSBjYXRlZ29yaWVzXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrXG4gICAgfVxuXG4gICAgcmV0dXJuIGlzVW5pcXVlXG4gIH1cbn1cblxuLyoqXG4gKlxuICogQHBhcmFtIGhlYWRDaGlsZHJlbkVsZW1lbnRzIExpc3Qgb2YgY2hpbGRyZW4gb2YgPEhlYWQ+XG4gKi9cbmZ1bmN0aW9uIHJlZHVjZUNvbXBvbmVudHM8VCBleHRlbmRzIHt9ICYgV2l0aEluQW1wTW9kZT4oXG4gIGhlYWRDaGlsZHJlbkVsZW1lbnRzOiBBcnJheTxSZWFjdC5SZWFjdEVsZW1lbnQ8YW55Pj4sXG4gIHByb3BzOiBUXG4pIHtcbiAgY29uc3QgeyBpbkFtcE1vZGUgfSA9IHByb3BzXG4gIHJldHVybiBoZWFkQ2hpbGRyZW5FbGVtZW50c1xuICAgIC5yZWR1Y2Uob25seVJlYWN0RWxlbWVudCwgW10pXG4gICAgLnJldmVyc2UoKVxuICAgIC5jb25jYXQoZGVmYXVsdEhlYWQoaW5BbXBNb2RlKS5yZXZlcnNlKCkpXG4gICAgLmZpbHRlcih1bmlxdWUoKSlcbiAgICAucmV2ZXJzZSgpXG4gICAgLm1hcCgoYzogUmVhY3QuUmVhY3RFbGVtZW50PGFueT4sIGk6IG51bWJlcikgPT4ge1xuICAgICAgY29uc3Qga2V5ID0gYy5rZXkgfHwgaVxuICAgICAgaWYgKFxuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ2RldmVsb3BtZW50JyAmJlxuICAgICAgICBwcm9jZXNzLmVudi5fX05FWFRfT1BUSU1JWkVfRk9OVFMgJiZcbiAgICAgICAgIWluQW1wTW9kZVxuICAgICAgKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBjLnR5cGUgPT09ICdsaW5rJyAmJlxuICAgICAgICAgIGMucHJvcHNbJ2hyZWYnXSAmJlxuICAgICAgICAgIC8vIFRPRE8ocHJhdGVla2JoQCk6IFJlcGxhY2UgdGhpcyB3aXRoIGNvbnN0IGZyb20gYGNvbnN0YW50c2Agd2hlbiB0aGUgdHJlZSBzaGFraW5nIHdvcmtzLlxuICAgICAgICAgIFsnaHR0cHM6Ly9mb250cy5nb29nbGVhcGlzLmNvbS9jc3MnLCAnaHR0cHM6Ly91c2UudHlwZWtpdC5uZXQvJ10uc29tZShcbiAgICAgICAgICAgICh1cmwpID0+IGMucHJvcHNbJ2hyZWYnXS5zdGFydHNXaXRoKHVybClcbiAgICAgICAgICApXG4gICAgICAgICkge1xuICAgICAgICAgIGNvbnN0IG5ld1Byb3BzID0geyAuLi4oYy5wcm9wcyB8fCB7fSkgfVxuICAgICAgICAgIG5ld1Byb3BzWydkYXRhLWhyZWYnXSA9IG5ld1Byb3BzWydocmVmJ11cbiAgICAgICAgICBuZXdQcm9wc1snaHJlZiddID0gdW5kZWZpbmVkXG5cbiAgICAgICAgICAvLyBBZGQgdGhpcyBhdHRyaWJ1dGUgdG8gbWFrZSBpdCBlYXN5IHRvIGlkZW50aWZ5IG9wdGltaXplZCB0YWdzXG4gICAgICAgICAgbmV3UHJvcHNbJ2RhdGEtb3B0aW1pemVkLWZvbnRzJ10gPSB0cnVlXG5cbiAgICAgICAgICByZXR1cm4gUmVhY3QuY2xvbmVFbGVtZW50KGMsIG5ld1Byb3BzKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgICAgLy8gb21pdCBKU09OLUxEIHN0cnVjdHVyZWQgZGF0YSBzbmlwcGV0cyBmcm9tIHRoZSB3YXJuaW5nXG4gICAgICAgIGlmIChjLnR5cGUgPT09ICdzY3JpcHQnICYmIGMucHJvcHNbJ3R5cGUnXSAhPT0gJ2FwcGxpY2F0aW9uL2xkK2pzb24nKSB7XG4gICAgICAgICAgY29uc3Qgc3JjTWVzc2FnZSA9IGMucHJvcHNbJ3NyYyddXG4gICAgICAgICAgICA/IGA8c2NyaXB0PiB0YWcgd2l0aCBzcmM9XCIke2MucHJvcHNbJ3NyYyddfVwiYFxuICAgICAgICAgICAgOiBgaW5saW5lIDxzY3JpcHQ+YFxuICAgICAgICAgIHdhcm5PbmNlKFxuICAgICAgICAgICAgYERvIG5vdCBhZGQgPHNjcmlwdD4gdGFncyB1c2luZyBuZXh0L2hlYWQgKHNlZSAke3NyY01lc3NhZ2V9KS4gVXNlIG5leHQvc2NyaXB0IGluc3RlYWQuIFxcblNlZSBtb3JlIGluZm8gaGVyZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvbm8tc2NyaXB0LXRhZ3MtaW4taGVhZC1jb21wb25lbnRgXG4gICAgICAgICAgKVxuICAgICAgICB9IGVsc2UgaWYgKGMudHlwZSA9PT0gJ2xpbmsnICYmIGMucHJvcHNbJ3JlbCddID09PSAnc3R5bGVzaGVldCcpIHtcbiAgICAgICAgICB3YXJuT25jZShcbiAgICAgICAgICAgIGBEbyBub3QgYWRkIHN0eWxlc2hlZXRzIHVzaW5nIG5leHQvaGVhZCAoc2VlIDxsaW5rIHJlbD1cInN0eWxlc2hlZXRcIj4gdGFnIHdpdGggaHJlZj1cIiR7Yy5wcm9wc1snaHJlZiddfVwiKS4gVXNlIERvY3VtZW50IGluc3RlYWQuIFxcblNlZSBtb3JlIGluZm8gaGVyZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvbm8tc3R5bGVzaGVldHMtaW4taGVhZC1jb21wb25lbnRgXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gUmVhY3QuY2xvbmVFbGVtZW50KGMsIHsga2V5IH0pXG4gICAgfSlcbn1cblxuLyoqXG4gKiBUaGlzIGNvbXBvbmVudCBpbmplY3RzIGVsZW1lbnRzIHRvIGA8aGVhZD5gIG9mIHlvdXIgcGFnZS5cbiAqIFRvIGF2b2lkIGR1cGxpY2F0ZWQgYHRhZ3NgIGluIGA8aGVhZD5gIHlvdSBjYW4gdXNlIHRoZSBga2V5YCBwcm9wZXJ0eSwgd2hpY2ggd2lsbCBtYWtlIHN1cmUgZXZlcnkgdGFnIGlzIG9ubHkgcmVuZGVyZWQgb25jZS5cbiAqL1xuZnVuY3Rpb24gSGVhZCh7IGNoaWxkcmVuIH06IHsgY2hpbGRyZW46IFJlYWN0LlJlYWN0Tm9kZSB9KSB7XG4gIGNvbnN0IGFtcFN0YXRlID0gdXNlQ29udGV4dChBbXBTdGF0ZUNvbnRleHQpXG4gIGNvbnN0IGhlYWRNYW5hZ2VyID0gdXNlQ29udGV4dChIZWFkTWFuYWdlckNvbnRleHQpXG4gIHJldHVybiAoXG4gICAgPEVmZmVjdFxuICAgICAgcmVkdWNlQ29tcG9uZW50c1RvU3RhdGU9e3JlZHVjZUNvbXBvbmVudHN9XG4gICAgICBoZWFkTWFuYWdlcj17aGVhZE1hbmFnZXJ9XG4gICAgICBpbkFtcE1vZGU9e2lzSW5BbXBNb2RlKGFtcFN0YXRlKX1cbiAgICA+XG4gICAgICB7Y2hpbGRyZW59XG4gICAgPC9FZmZlY3Q+XG4gIClcbn1cblxuZXhwb3J0IGRlZmF1bHQgSGVhZFxuIl0sIm5hbWVzIjpbImRlZmF1bHRIZWFkIiwiaW5BbXBNb2RlIiwiaGVhZCIsIm1ldGEiLCJjaGFyU2V0IiwicHVzaCIsIm5hbWUiLCJjb250ZW50Iiwib25seVJlYWN0RWxlbWVudCIsImxpc3QiLCJjaGlsZCIsInR5cGUiLCJSZWFjdCIsIkZyYWdtZW50IiwiY29uY2F0IiwiQ2hpbGRyZW4iLCJ0b0FycmF5IiwicHJvcHMiLCJjaGlsZHJlbiIsInJlZHVjZSIsImZyYWdtZW50TGlzdCIsImZyYWdtZW50Q2hpbGQiLCJNRVRBVFlQRVMiLCJ1bmlxdWUiLCJrZXlzIiwiU2V0IiwidGFncyIsIm1ldGFUeXBlcyIsIm1ldGFDYXRlZ29yaWVzIiwiaCIsImlzVW5pcXVlIiwiaGFzS2V5Iiwia2V5IiwiaW5kZXhPZiIsInNsaWNlIiwiaGFzIiwiYWRkIiwiaSIsImxlbiIsImxlbmd0aCIsIm1ldGF0eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYXRlZ29yeSIsImNhdGVnb3JpZXMiLCJyZWR1Y2VDb21wb25lbnRzIiwiaGVhZENoaWxkcmVuRWxlbWVudHMiLCJyZXZlcnNlIiwiZmlsdGVyIiwibWFwIiwiYyIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsIl9fTkVYVF9PUFRJTUlaRV9GT05UUyIsInNvbWUiLCJ1cmwiLCJzdGFydHNXaXRoIiwibmV3UHJvcHMiLCJ1bmRlZmluZWQiLCJjbG9uZUVsZW1lbnQiLCJzcmNNZXNzYWdlIiwid2Fybk9uY2UiLCJIZWFkIiwiYW1wU3RhdGUiLCJ1c2VDb250ZXh0IiwiQW1wU3RhdGVDb250ZXh0IiwiaGVhZE1hbmFnZXIiLCJIZWFkTWFuYWdlckNvbnRleHQiLCJFZmZlY3QiLCJyZWR1Y2VDb21wb25lbnRzVG9TdGF0ZSIsImlzSW5BbXBNb2RlIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/head.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/image-blur-svg.js":
/*!*************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/image-blur-svg.js ***!
  \*************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/**\n * A shared function, used on both client and server, to generate a SVG blur placeholder.\n */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"getImageBlurSvg\", ({\n    enumerable: true,\n    get: function() {\n        return getImageBlurSvg;\n    }\n}));\nfunction getImageBlurSvg(param) {\n    let { widthInt, heightInt, blurWidth, blurHeight, blurDataURL, objectFit } = param;\n    const std = 20;\n    const svgWidth = blurWidth ? blurWidth * 40 : widthInt;\n    const svgHeight = blurHeight ? blurHeight * 40 : heightInt;\n    const viewBox = svgWidth && svgHeight ? \"viewBox='0 0 \" + svgWidth + \" \" + svgHeight + \"'\" : '';\n    const preserveAspectRatio = viewBox ? 'none' : objectFit === 'contain' ? 'xMidYMid' : objectFit === 'cover' ? 'xMidYMid slice' : 'none';\n    return \"%3Csvg xmlns='http://www.w3.org/2000/svg' \" + viewBox + \"%3E%3Cfilter id='b' color-interpolation-filters='sRGB'%3E%3CfeGaussianBlur stdDeviation='\" + std + \"'/%3E%3CfeColorMatrix values='1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 100 -1' result='s'/%3E%3CfeFlood x='0' y='0' width='100%25' height='100%25'/%3E%3CfeComposite operator='out' in='s'/%3E%3CfeComposite in2='SourceGraphic'/%3E%3CfeGaussianBlur stdDeviation='\" + std + \"'/%3E%3C/filter%3E%3Cimage width='100%25' height='100%25' x='0' y='0' preserveAspectRatio='\" + preserveAspectRatio + \"' style='filter: url(%23b);' href='\" + blurDataURL + \"'/%3E%3C/svg%3E\";\n} //# sourceMappingURL=image-blur-svg.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9pbWFnZS1ibHVyLXN2Zy5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Q0FFQzs7OzttREFDZUE7OztlQUFBQTs7O0FBQVQsU0FBU0EsZ0JBQWdCLEtBYy9CO0lBZCtCLE1BQzlCQyxRQUFRLEVBQ1JDLFNBQVMsRUFDVEMsU0FBUyxFQUNUQyxVQUFVLEVBQ1ZDLFdBQVcsRUFDWEMsU0FBUyxFQVFWLEdBZCtCO0lBZTlCLE1BQU1DLE1BQU07SUFDWixNQUFNQyxXQUFXTCxZQUFZQSxZQUFZLEtBQUtGO0lBQzlDLE1BQU1RLFlBQVlMLGFBQWFBLGFBQWEsS0FBS0Y7SUFFakQsTUFBTVEsVUFDSkYsWUFBWUMsWUFBYSxrQkFBZUQsV0FBUyxNQUFHQyxZQUFVLE1BQUs7SUFDckUsTUFBTUUsc0JBQXNCRCxVQUN4QixTQUNBSixjQUFjLFlBQ1osYUFDQUEsY0FBYyxVQUNaLG1CQUNBO0lBRVIsT0FBUSwrQ0FBNENJLFVBQVEsOEZBQTJGSCxNQUFJLG9RQUFpUUEsTUFBSSxnR0FBNkZJLHNCQUFvQix3Q0FBcUNOLGNBQVk7QUFDcGtCIiwic291cmNlcyI6WyIvVXNlcnMvam9uYXRoYW52aW5jZW50aXVzL0RvY3VtZW50cy9zcmMvc2hhcmVkL2xpYi9pbWFnZS1ibHVyLXN2Zy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEEgc2hhcmVkIGZ1bmN0aW9uLCB1c2VkIG9uIGJvdGggY2xpZW50IGFuZCBzZXJ2ZXIsIHRvIGdlbmVyYXRlIGEgU1ZHIGJsdXIgcGxhY2Vob2xkZXIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRJbWFnZUJsdXJTdmcoe1xuICB3aWR0aEludCxcbiAgaGVpZ2h0SW50LFxuICBibHVyV2lkdGgsXG4gIGJsdXJIZWlnaHQsXG4gIGJsdXJEYXRhVVJMLFxuICBvYmplY3RGaXQsXG59OiB7XG4gIHdpZHRoSW50PzogbnVtYmVyXG4gIGhlaWdodEludD86IG51bWJlclxuICBibHVyV2lkdGg/OiBudW1iZXJcbiAgYmx1ckhlaWdodD86IG51bWJlclxuICBibHVyRGF0YVVSTDogc3RyaW5nXG4gIG9iamVjdEZpdD86IHN0cmluZ1xufSk6IHN0cmluZyB7XG4gIGNvbnN0IHN0ZCA9IDIwXG4gIGNvbnN0IHN2Z1dpZHRoID0gYmx1cldpZHRoID8gYmx1cldpZHRoICogNDAgOiB3aWR0aEludFxuICBjb25zdCBzdmdIZWlnaHQgPSBibHVySGVpZ2h0ID8gYmx1ckhlaWdodCAqIDQwIDogaGVpZ2h0SW50XG5cbiAgY29uc3Qgdmlld0JveCA9XG4gICAgc3ZnV2lkdGggJiYgc3ZnSGVpZ2h0ID8gYHZpZXdCb3g9JzAgMCAke3N2Z1dpZHRofSAke3N2Z0hlaWdodH0nYCA6ICcnXG4gIGNvbnN0IHByZXNlcnZlQXNwZWN0UmF0aW8gPSB2aWV3Qm94XG4gICAgPyAnbm9uZSdcbiAgICA6IG9iamVjdEZpdCA9PT0gJ2NvbnRhaW4nXG4gICAgICA/ICd4TWlkWU1pZCdcbiAgICAgIDogb2JqZWN0Rml0ID09PSAnY292ZXInXG4gICAgICAgID8gJ3hNaWRZTWlkIHNsaWNlJ1xuICAgICAgICA6ICdub25lJ1xuXG4gIHJldHVybiBgJTNDc3ZnIHhtbG5zPSdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycgJHt2aWV3Qm94fSUzRSUzQ2ZpbHRlciBpZD0nYicgY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzPSdzUkdCJyUzRSUzQ2ZlR2F1c3NpYW5CbHVyIHN0ZERldmlhdGlvbj0nJHtzdGR9Jy8lM0UlM0NmZUNvbG9yTWF0cml4IHZhbHVlcz0nMSAwIDAgMCAwIDAgMSAwIDAgMCAwIDAgMSAwIDAgMCAwIDAgMTAwIC0xJyByZXN1bHQ9J3MnLyUzRSUzQ2ZlRmxvb2QgeD0nMCcgeT0nMCcgd2lkdGg9JzEwMCUyNScgaGVpZ2h0PScxMDAlMjUnLyUzRSUzQ2ZlQ29tcG9zaXRlIG9wZXJhdG9yPSdvdXQnIGluPSdzJy8lM0UlM0NmZUNvbXBvc2l0ZSBpbjI9J1NvdXJjZUdyYXBoaWMnLyUzRSUzQ2ZlR2F1c3NpYW5CbHVyIHN0ZERldmlhdGlvbj0nJHtzdGR9Jy8lM0UlM0MvZmlsdGVyJTNFJTNDaW1hZ2Ugd2lkdGg9JzEwMCUyNScgaGVpZ2h0PScxMDAlMjUnIHg9JzAnIHk9JzAnIHByZXNlcnZlQXNwZWN0UmF0aW89JyR7cHJlc2VydmVBc3BlY3RSYXRpb30nIHN0eWxlPSdmaWx0ZXI6IHVybCglMjNiKTsnIGhyZWY9JyR7Ymx1ckRhdGFVUkx9Jy8lM0UlM0Mvc3ZnJTNFYFxufVxuIl0sIm5hbWVzIjpbImdldEltYWdlQmx1clN2ZyIsIndpZHRoSW50IiwiaGVpZ2h0SW50IiwiYmx1cldpZHRoIiwiYmx1ckhlaWdodCIsImJsdXJEYXRhVVJMIiwib2JqZWN0Rml0Iiwic3RkIiwic3ZnV2lkdGgiLCJzdmdIZWlnaHQiLCJ2aWV3Qm94IiwicHJlc2VydmVBc3BlY3RSYXRpbyJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/image-blur-svg.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/image-config-context.shared-runtime.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/image-config-context.shared-runtime.js ***!
  \**********************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"ImageConfigContext\", ({\n    enumerable: true,\n    get: function() {\n        return ImageConfigContext;\n    }\n}));\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _react = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nconst _imageconfig = __webpack_require__(/*! ./image-config */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/image-config.js\");\nconst ImageConfigContext = _react.default.createContext(_imageconfig.imageConfigDefault);\nif (true) {\n    ImageConfigContext.displayName = 'ImageConfigContext';\n} //# sourceMappingURL=image-config-context.shared-runtime.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9pbWFnZS1jb25maWctY29udGV4dC5zaGFyZWQtcnVudGltZS5qcyIsIm1hcHBpbmdzIjoiOzs7O3NEQUlhQTs7O2VBQUFBOzs7OzRFQUpLO3lDQUVpQjtBQUU1QixNQUFNQSxxQkFDWEMsT0FBQUEsT0FBSyxDQUFDQyxhQUFhLENBQXNCQyxhQUFBQSxrQkFBa0I7QUFFN0QsSUFBSUMsSUFBb0IsRUFBbUI7SUFDekNKLG1CQUFtQk8sV0FBVyxHQUFHO0FBQ25DIiwic291cmNlcyI6WyIvVXNlcnMvam9uYXRoYW52aW5jZW50aXVzL0RvY3VtZW50cy9zcmMvc2hhcmVkL2xpYi9pbWFnZS1jb25maWctY29udGV4dC5zaGFyZWQtcnVudGltZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnXG5pbXBvcnQgdHlwZSB7IEltYWdlQ29uZmlnQ29tcGxldGUgfSBmcm9tICcuL2ltYWdlLWNvbmZpZydcbmltcG9ydCB7IGltYWdlQ29uZmlnRGVmYXVsdCB9IGZyb20gJy4vaW1hZ2UtY29uZmlnJ1xuXG5leHBvcnQgY29uc3QgSW1hZ2VDb25maWdDb250ZXh0ID1cbiAgUmVhY3QuY3JlYXRlQ29udGV4dDxJbWFnZUNvbmZpZ0NvbXBsZXRlPihpbWFnZUNvbmZpZ0RlZmF1bHQpXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIEltYWdlQ29uZmlnQ29udGV4dC5kaXNwbGF5TmFtZSA9ICdJbWFnZUNvbmZpZ0NvbnRleHQnXG59XG4iXSwibmFtZXMiOlsiSW1hZ2VDb25maWdDb250ZXh0IiwiUmVhY3QiLCJjcmVhdGVDb250ZXh0IiwiaW1hZ2VDb25maWdEZWZhdWx0IiwicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIiwiZGlzcGxheU5hbWUiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/image-config-context.shared-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/image-config.js":
/*!***********************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/image-config.js ***!
  \***********************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    VALID_LOADERS: function() {\n        return VALID_LOADERS;\n    },\n    imageConfigDefault: function() {\n        return imageConfigDefault;\n    }\n});\nconst VALID_LOADERS = [\n    'default',\n    'imgix',\n    'cloudinary',\n    'akamai',\n    'custom'\n];\nconst imageConfigDefault = {\n    deviceSizes: [\n        640,\n        750,\n        828,\n        1080,\n        1200,\n        1920,\n        2048,\n        3840\n    ],\n    imageSizes: [\n        16,\n        32,\n        48,\n        64,\n        96,\n        128,\n        256,\n        384\n    ],\n    path: '/_next/image',\n    loader: 'default',\n    loaderFile: '',\n    domains: [],\n    disableStaticImages: false,\n    minimumCacheTTL: 60,\n    formats: [\n        'image/webp'\n    ],\n    dangerouslyAllowSVG: false,\n    contentSecurityPolicy: \"script-src 'none'; frame-src 'none'; sandbox;\",\n    contentDispositionType: 'attachment',\n    localPatterns: undefined,\n    remotePatterns: [],\n    qualities: undefined,\n    unoptimized: false\n}; //# sourceMappingURL=image-config.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9pbWFnZS1jb25maWcuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0lBQWFBLGFBQWE7ZUFBYkE7O0lBaUlBQyxrQkFBa0I7ZUFBbEJBOzs7QUFqSU4sTUFBTUQsZ0JBQWdCO0lBQzNCO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7Q0FDRDtBQTJITSxNQUFNQyxxQkFBMEM7SUFDckRDLGFBQWE7UUFBQztRQUFLO1FBQUs7UUFBSztRQUFNO1FBQU07UUFBTTtRQUFNO0tBQUs7SUFDMURDLFlBQVk7UUFBQztRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSztRQUFLO0tBQUk7SUFDL0NDLE1BQU07SUFDTkMsUUFBUTtJQUNSQyxZQUFZO0lBQ1pDLFNBQVMsRUFBRTtJQUNYQyxxQkFBcUI7SUFDckJDLGlCQUFpQjtJQUNqQkMsU0FBUztRQUFDO0tBQWE7SUFDdkJDLHFCQUFxQjtJQUNyQkMsdUJBQXdCO0lBQ3hCQyx3QkFBd0I7SUFDeEJDLGVBQWVDO0lBQ2ZDLGdCQUFnQixFQUFFO0lBQ2xCQyxXQUFXRjtJQUNYRyxhQUFhO0FBQ2YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9qb25hdGhhbnZpbmNlbnRpdXMvRG9jdW1lbnRzL3NyYy9zaGFyZWQvbGliL2ltYWdlLWNvbmZpZy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgVkFMSURfTE9BREVSUyA9IFtcbiAgJ2RlZmF1bHQnLFxuICAnaW1naXgnLFxuICAnY2xvdWRpbmFyeScsXG4gICdha2FtYWknLFxuICAnY3VzdG9tJyxcbl0gYXMgY29uc3RcblxuZXhwb3J0IHR5cGUgTG9hZGVyVmFsdWUgPSAodHlwZW9mIFZBTElEX0xPQURFUlMpW251bWJlcl1cblxuZXhwb3J0IHR5cGUgSW1hZ2VMb2FkZXJQcm9wcyA9IHtcbiAgc3JjOiBzdHJpbmdcbiAgd2lkdGg6IG51bWJlclxuICBxdWFsaXR5PzogbnVtYmVyXG59XG5cbmV4cG9ydCB0eXBlIEltYWdlTG9hZGVyUHJvcHNXaXRoQ29uZmlnID0gSW1hZ2VMb2FkZXJQcm9wcyAmIHtcbiAgY29uZmlnOiBSZWFkb25seTxJbWFnZUNvbmZpZz5cbn1cblxuZXhwb3J0IHR5cGUgTG9jYWxQYXR0ZXJuID0ge1xuICAvKipcbiAgICogQ2FuIGJlIGxpdGVyYWwgb3Igd2lsZGNhcmQuXG4gICAqIFNpbmdsZSBgKmAgbWF0Y2hlcyBhIHNpbmdsZSBwYXRoIHNlZ21lbnQuXG4gICAqIERvdWJsZSBgKipgIG1hdGNoZXMgYW55IG51bWJlciBvZiBwYXRoIHNlZ21lbnRzLlxuICAgKi9cbiAgcGF0aG5hbWU/OiBzdHJpbmdcblxuICAvKipcbiAgICogQ2FuIGJlIGxpdGVyYWwgcXVlcnkgc3RyaW5nIHN1Y2ggYXMgYD92PTFgIG9yXG4gICAqIGVtcHR5IHN0cmluZyBtZWFuaW5nIG5vIHF1ZXJ5IHN0cmluZy5cbiAgICovXG4gIHNlYXJjaD86IHN0cmluZ1xufVxuXG5leHBvcnQgdHlwZSBSZW1vdGVQYXR0ZXJuID0ge1xuICAvKipcbiAgICogTXVzdCBiZSBgaHR0cGAgb3IgYGh0dHBzYC5cbiAgICovXG4gIHByb3RvY29sPzogJ2h0dHAnIHwgJ2h0dHBzJ1xuXG4gIC8qKlxuICAgKiBDYW4gYmUgbGl0ZXJhbCBvciB3aWxkY2FyZC5cbiAgICogU2luZ2xlIGAqYCBtYXRjaGVzIGEgc2luZ2xlIHN1YmRvbWFpbi5cbiAgICogRG91YmxlIGAqKmAgbWF0Y2hlcyBhbnkgbnVtYmVyIG9mIHN1YmRvbWFpbnMuXG4gICAqL1xuICBob3N0bmFtZTogc3RyaW5nXG5cbiAgLyoqXG4gICAqIENhbiBiZSBsaXRlcmFsIHBvcnQgc3VjaCBhcyBgODA4MGAgb3IgZW1wdHkgc3RyaW5nXG4gICAqIG1lYW5pbmcgbm8gcG9ydC5cbiAgICovXG4gIHBvcnQ/OiBzdHJpbmdcblxuICAvKipcbiAgICogQ2FuIGJlIGxpdGVyYWwgb3Igd2lsZGNhcmQuXG4gICAqIFNpbmdsZSBgKmAgbWF0Y2hlcyBhIHNpbmdsZSBwYXRoIHNlZ21lbnQuXG4gICAqIERvdWJsZSBgKipgIG1hdGNoZXMgYW55IG51bWJlciBvZiBwYXRoIHNlZ21lbnRzLlxuICAgKi9cbiAgcGF0aG5hbWU/OiBzdHJpbmdcblxuICAvKipcbiAgICogQ2FuIGJlIGxpdGVyYWwgcXVlcnkgc3RyaW5nIHN1Y2ggYXMgYD92PTFgIG9yXG4gICAqIGVtcHR5IHN0cmluZyBtZWFuaW5nIG5vIHF1ZXJ5IHN0cmluZy5cbiAgICovXG4gIHNlYXJjaD86IHN0cmluZ1xufVxuXG50eXBlIEltYWdlRm9ybWF0ID0gJ2ltYWdlL2F2aWYnIHwgJ2ltYWdlL3dlYnAnXG5cbi8qKlxuICogSW1hZ2UgY29uZmlndXJhdGlvbnNcbiAqXG4gKiBAc2VlIFtJbWFnZSBjb25maWd1cmF0aW9uIG9wdGlvbnNdKGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwaS1yZWZlcmVuY2UvbmV4dC9pbWFnZSNjb25maWd1cmF0aW9uLW9wdGlvbnMpXG4gKi9cbmV4cG9ydCB0eXBlIEltYWdlQ29uZmlnQ29tcGxldGUgPSB7XG4gIC8qKiBAc2VlIFtEZXZpY2Ugc2l6ZXMgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBpLXJlZmVyZW5jZS9uZXh0L2ltYWdlI2RldmljZS1zaXplcykgKi9cbiAgZGV2aWNlU2l6ZXM6IG51bWJlcltdXG5cbiAgLyoqIEBzZWUgW0ltYWdlIHNpemluZyBkb2N1bWVudGF0aW9uXShodHRwczovL25leHRqcy5vcmcvZG9jcy9hcHAvYnVpbGRpbmcteW91ci1hcHBsaWNhdGlvbi9vcHRpbWl6aW5nL2ltYWdlcyNpbWFnZS1zaXppbmcpICovXG4gIGltYWdlU2l6ZXM6IG51bWJlcltdXG5cbiAgLyoqIEBzZWUgW0ltYWdlIGxvYWRlcnMgY29uZmlndXJhdGlvbl0oaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBpLXJlZmVyZW5jZS9uZXh0L2xlZ2FjeS9pbWFnZSNsb2FkZXIpICovXG4gIGxvYWRlcjogTG9hZGVyVmFsdWVcblxuICAvKiogQHNlZSBbSW1hZ2UgbG9hZGVyIGNvbmZpZ3VyYXRpb25dKGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwaS1yZWZlcmVuY2UvbmV4dC9sZWdhY3kvaW1hZ2UjbG9hZGVyLWNvbmZpZ3VyYXRpb24pICovXG4gIHBhdGg6IHN0cmluZ1xuXG4gIC8qKiBAc2VlIFtJbWFnZSBsb2FkZXIgY29uZmlndXJhdGlvbl0oaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBpLXJlZmVyZW5jZS9uZXh0L2ltYWdlI2xvYWRlci1jb25maWd1cmF0aW9uKSAqL1xuICBsb2FkZXJGaWxlOiBzdHJpbmdcblxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGByZW1vdGVQYXR0ZXJuc2AgaW5zdGVhZC5cbiAgICovXG4gIGRvbWFpbnM6IHN0cmluZ1tdXG5cbiAgLyoqIEBzZWUgW0Rpc2FibGUgc3RhdGljIGltYWdlIGltcG9ydCBjb25maWd1cmF0aW9uXShodHRwczovL25leHRqcy5vcmcvZG9jcy9hcGktcmVmZXJlbmNlL25leHQvaW1hZ2UjZGlzYWJsZS1zdGF0aWMtaW1wb3J0cykgKi9cbiAgZGlzYWJsZVN0YXRpY0ltYWdlczogYm9vbGVhblxuXG4gIC8qKiBAc2VlIFtDYWNoZSBiZWhhdmlvcl0oaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBpLXJlZmVyZW5jZS9uZXh0L2ltYWdlI2NhY2hpbmctYmVoYXZpb3IpICovXG4gIG1pbmltdW1DYWNoZVRUTDogbnVtYmVyXG5cbiAgLyoqIEBzZWUgW0FjY2VwdGFibGUgZm9ybWF0c10oaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBpLXJlZmVyZW5jZS9uZXh0L2ltYWdlI2FjY2VwdGFibGUtZm9ybWF0cykgKi9cbiAgZm9ybWF0czogSW1hZ2VGb3JtYXRbXVxuXG4gIC8qKiBAc2VlIFtEYW5nZXJvdXNseSBBbGxvdyBTVkddKGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwaS1yZWZlcmVuY2UvbmV4dC9pbWFnZSNkYW5nZXJvdXNseS1hbGxvdy1zdmcpICovXG4gIGRhbmdlcm91c2x5QWxsb3dTVkc6IGJvb2xlYW5cblxuICAvKiogQHNlZSBbRGFuZ2Vyb3VzbHkgQWxsb3cgU1ZHXShodHRwczovL25leHRqcy5vcmcvZG9jcy9hcGktcmVmZXJlbmNlL25leHQvaW1hZ2UjZGFuZ2Vyb3VzbHktYWxsb3ctc3ZnKSAqL1xuICBjb250ZW50U2VjdXJpdHlQb2xpY3k6IHN0cmluZ1xuXG4gIC8qKiBAc2VlIFtEYW5nZXJvdXNseSBBbGxvdyBTVkddKGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwaS1yZWZlcmVuY2UvbmV4dC9pbWFnZSNkYW5nZXJvdXNseS1hbGxvdy1zdmcpICovXG4gIGNvbnRlbnREaXNwb3NpdGlvblR5cGU6ICdpbmxpbmUnIHwgJ2F0dGFjaG1lbnQnXG5cbiAgLyoqIEBzZWUgW1JlbW90ZSBQYXR0ZXJuc10oaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBpLXJlZmVyZW5jZS9uZXh0L2ltYWdlI3JlbW90ZXBhdHRlcm5zKSAqL1xuICByZW1vdGVQYXR0ZXJuczogUmVtb3RlUGF0dGVybltdXG5cbiAgLyoqIEBzZWUgW1JlbW90ZSBQYXR0ZXJuc10oaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBpLXJlZmVyZW5jZS9uZXh0L2ltYWdlI2xvY2FsUGF0dGVybnMpICovXG4gIGxvY2FsUGF0dGVybnM6IExvY2FsUGF0dGVybltdIHwgdW5kZWZpbmVkXG5cbiAgLyoqIEBzZWUgW1F1YWxpdGllc10oaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBpLXJlZmVyZW5jZS9uZXh0L2ltYWdlI3F1YWxpdGllcykgKi9cbiAgcXVhbGl0aWVzOiBudW1iZXJbXSB8IHVuZGVmaW5lZFxuXG4gIC8qKiBAc2VlIFtVbm9wdGltaXplZF0oaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBpLXJlZmVyZW5jZS9uZXh0L2ltYWdlI3Vub3B0aW1pemVkKSAqL1xuICB1bm9wdGltaXplZDogYm9vbGVhblxufVxuXG5leHBvcnQgdHlwZSBJbWFnZUNvbmZpZyA9IFBhcnRpYWw8SW1hZ2VDb25maWdDb21wbGV0ZT5cblxuZXhwb3J0IGNvbnN0IGltYWdlQ29uZmlnRGVmYXVsdDogSW1hZ2VDb25maWdDb21wbGV0ZSA9IHtcbiAgZGV2aWNlU2l6ZXM6IFs2NDAsIDc1MCwgODI4LCAxMDgwLCAxMjAwLCAxOTIwLCAyMDQ4LCAzODQwXSxcbiAgaW1hZ2VTaXplczogWzE2LCAzMiwgNDgsIDY0LCA5NiwgMTI4LCAyNTYsIDM4NF0sXG4gIHBhdGg6ICcvX25leHQvaW1hZ2UnLFxuICBsb2FkZXI6ICdkZWZhdWx0JyxcbiAgbG9hZGVyRmlsZTogJycsXG4gIGRvbWFpbnM6IFtdLFxuICBkaXNhYmxlU3RhdGljSW1hZ2VzOiBmYWxzZSxcbiAgbWluaW11bUNhY2hlVFRMOiA2MCxcbiAgZm9ybWF0czogWydpbWFnZS93ZWJwJ10sXG4gIGRhbmdlcm91c2x5QWxsb3dTVkc6IGZhbHNlLFxuICBjb250ZW50U2VjdXJpdHlQb2xpY3k6IGBzY3JpcHQtc3JjICdub25lJzsgZnJhbWUtc3JjICdub25lJzsgc2FuZGJveDtgLFxuICBjb250ZW50RGlzcG9zaXRpb25UeXBlOiAnYXR0YWNobWVudCcsXG4gIGxvY2FsUGF0dGVybnM6IHVuZGVmaW5lZCwgLy8gZGVmYXVsdDogYWxsb3cgYWxsIGxvY2FsIGltYWdlc1xuICByZW1vdGVQYXR0ZXJuczogW10sIC8vIGRlZmF1bHQ6IGFsbG93IG5vIHJlbW90ZSBpbWFnZXNcbiAgcXVhbGl0aWVzOiB1bmRlZmluZWQsIC8vIGRlZmF1bHQ6IGFsbG93IGFsbCBxdWFsaXRpZXNcbiAgdW5vcHRpbWl6ZWQ6IGZhbHNlLFxufVxuIl0sIm5hbWVzIjpbIlZBTElEX0xPQURFUlMiLCJpbWFnZUNvbmZpZ0RlZmF1bHQiLCJkZXZpY2VTaXplcyIsImltYWdlU2l6ZXMiLCJwYXRoIiwibG9hZGVyIiwibG9hZGVyRmlsZSIsImRvbWFpbnMiLCJkaXNhYmxlU3RhdGljSW1hZ2VzIiwibWluaW11bUNhY2hlVFRMIiwiZm9ybWF0cyIsImRhbmdlcm91c2x5QWxsb3dTVkciLCJjb250ZW50U2VjdXJpdHlQb2xpY3kiLCJjb250ZW50RGlzcG9zaXRpb25UeXBlIiwibG9jYWxQYXR0ZXJucyIsInVuZGVmaW5lZCIsInJlbW90ZVBhdHRlcm5zIiwicXVhbGl0aWVzIiwidW5vcHRpbWl6ZWQiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/image-config.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/image-external.js":
/*!*************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/image-external.js ***!
  \*************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    default: function() {\n        return _default;\n    },\n    getImageProps: function() {\n        return getImageProps;\n    }\n});\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _getimgprops = __webpack_require__(/*! ./get-img-props */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/get-img-props.js\");\nconst _imagecomponent = __webpack_require__(/*! ../../client/image-component */ \"(app-pages-browser)/./node_modules/next/dist/client/image-component.js\");\nconst _imageloader = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! next/dist/shared/lib/image-loader */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/image-loader.js\"));\nfunction getImageProps(imgProps) {\n    const { props } = (0, _getimgprops.getImgProps)(imgProps, {\n        defaultLoader: _imageloader.default,\n        // This is replaced by webpack define plugin\n        imgConf: {\"deviceSizes\":[640,750,828,1080,1200,1920,2048,3840],\"imageSizes\":[16,32,48,64,96,128,256,384],\"path\":\"/_next/image\",\"loader\":\"default\",\"dangerouslyAllowSVG\":false,\"unoptimized\":true,\"domains\":[],\"remotePatterns\":[]}\n    });\n    // Normally we don't care about undefined props because we pass to JSX,\n    // but this exported function could be used by the end user for anything\n    // so we delete undefined props to clean it up a little.\n    for (const [key, value] of Object.entries(props)){\n        if (value === undefined) {\n            delete props[key];\n        }\n    }\n    return {\n        props\n    };\n}\nconst _default = _imagecomponent.Image; //# sourceMappingURL=image-external.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9pbWFnZS1leHRlcm5hbC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7SUFpQ0EsT0FBb0I7ZUFBcEI7O0lBakJnQkEsYUFBYTtlQUFiQTs7Ozt5Q0FiWTs0Q0FDTjtrRkFHSTtBQVNuQixTQUFTQSxjQUFjQyxRQUFvQjtJQUNoRCxNQUFNLEVBQUVDLEtBQUssRUFBRSxHQUFHQyxDQUFBQSxHQUFBQSxhQUFBQSxXQUFBQSxFQUFZRixVQUFVO1FBQ3RDRyxlQUFBQSxhQUFBQSxPQUFhO1FBQ2IsNENBQTRDO1FBQzVDQyxTQUFTQyx5TkFBNkI7SUFDeEM7SUFDQSx1RUFBdUU7SUFDdkUsd0VBQXdFO0lBQ3hFLHdEQUF3RDtJQUN4RCxLQUFLLE1BQU0sQ0FBQ0csS0FBS0MsTUFBTSxJQUFJQyxPQUFPQyxPQUFPLENBQUNWLE9BQVE7UUFDaEQsSUFBSVEsVUFBVUcsV0FBVztZQUN2QixPQUFPWCxLQUFLLENBQUNPLElBQTBCO1FBQ3pDO0lBQ0Y7SUFDQSxPQUFPO1FBQUVQO0lBQU07QUFDakI7TUFFQSxXQUFlWSxnQkFBQUEsS0FBSyIsInNvdXJjZXMiOlsiL1VzZXJzL2pvbmF0aGFudmluY2VudGl1cy9Eb2N1bWVudHMvc3JjL3NoYXJlZC9saWIvaW1hZ2UtZXh0ZXJuYWwudHN4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgSW1hZ2VDb25maWdDb21wbGV0ZSwgSW1hZ2VMb2FkZXJQcm9wcyB9IGZyb20gJy4vaW1hZ2UtY29uZmlnJ1xuaW1wb3J0IHR5cGUgeyBJbWFnZVByb3BzLCBJbWFnZUxvYWRlciwgU3RhdGljSW1hZ2VEYXRhIH0gZnJvbSAnLi9nZXQtaW1nLXByb3BzJ1xuXG5pbXBvcnQgeyBnZXRJbWdQcm9wcyB9IGZyb20gJy4vZ2V0LWltZy1wcm9wcydcbmltcG9ydCB7IEltYWdlIH0gZnJvbSAnLi4vLi4vY2xpZW50L2ltYWdlLWNvbXBvbmVudCdcblxuLy8gQHRzLWlnbm9yZSAtIFRoaXMgaXMgcmVwbGFjZWQgYnkgd2VicGFjayBhbGlhc1xuaW1wb3J0IGRlZmF1bHRMb2FkZXIgZnJvbSAnbmV4dC9kaXN0L3NoYXJlZC9saWIvaW1hZ2UtbG9hZGVyJ1xuXG4vKipcbiAqIEZvciBtb3JlIGFkdmFuY2VkIHVzZSBjYXNlcywgeW91IGNhbiBjYWxsIGBnZXRJbWFnZVByb3BzKClgXG4gKiB0byBnZXQgdGhlIHByb3BzIHRoYXQgd291bGQgYmUgcGFzc2VkIHRvIHRoZSB1bmRlcmx5aW5nIGA8aW1nPmAgZWxlbWVudCxcbiAqIGFuZCBpbnN0ZWFkIHBhc3MgdG8gdGhlbSB0byBhbm90aGVyIGNvbXBvbmVudCwgc3R5bGUsIGNhbnZhcywgZXRjLlxuICpcbiAqIFJlYWQgbW9yZTogW05leHQuanMgZG9jczogYGdldEltYWdlUHJvcHNgXShodHRwczovL25leHRqcy5vcmcvZG9jcy9hcHAvYXBpLXJlZmVyZW5jZS9jb21wb25lbnRzL2ltYWdlI2dldGltYWdlcHJvcHMpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRJbWFnZVByb3BzKGltZ1Byb3BzOiBJbWFnZVByb3BzKSB7XG4gIGNvbnN0IHsgcHJvcHMgfSA9IGdldEltZ1Byb3BzKGltZ1Byb3BzLCB7XG4gICAgZGVmYXVsdExvYWRlcixcbiAgICAvLyBUaGlzIGlzIHJlcGxhY2VkIGJ5IHdlYnBhY2sgZGVmaW5lIHBsdWdpblxuICAgIGltZ0NvbmY6IHByb2Nlc3MuZW52Ll9fTkVYVF9JTUFHRV9PUFRTIGFzIGFueSBhcyBJbWFnZUNvbmZpZ0NvbXBsZXRlLFxuICB9KVxuICAvLyBOb3JtYWxseSB3ZSBkb24ndCBjYXJlIGFib3V0IHVuZGVmaW5lZCBwcm9wcyBiZWNhdXNlIHdlIHBhc3MgdG8gSlNYLFxuICAvLyBidXQgdGhpcyBleHBvcnRlZCBmdW5jdGlvbiBjb3VsZCBiZSB1c2VkIGJ5IHRoZSBlbmQgdXNlciBmb3IgYW55dGhpbmdcbiAgLy8gc28gd2UgZGVsZXRlIHVuZGVmaW5lZCBwcm9wcyB0byBjbGVhbiBpdCB1cCBhIGxpdHRsZS5cbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocHJvcHMpKSB7XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGRlbGV0ZSBwcm9wc1trZXkgYXMga2V5b2YgdHlwZW9mIHByb3BzXVxuICAgIH1cbiAgfVxuICByZXR1cm4geyBwcm9wcyB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEltYWdlXG5cbmV4cG9ydCB0eXBlIHsgSW1hZ2VQcm9wcywgSW1hZ2VMb2FkZXJQcm9wcywgSW1hZ2VMb2FkZXIsIFN0YXRpY0ltYWdlRGF0YSB9XG4iXSwibmFtZXMiOlsiZ2V0SW1hZ2VQcm9wcyIsImltZ1Byb3BzIiwicHJvcHMiLCJnZXRJbWdQcm9wcyIsImRlZmF1bHRMb2FkZXIiLCJpbWdDb25mIiwicHJvY2VzcyIsImVudiIsIl9fTkVYVF9JTUFHRV9PUFRTIiwia2V5IiwidmFsdWUiLCJPYmplY3QiLCJlbnRyaWVzIiwidW5kZWZpbmVkIiwiSW1hZ2UiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/image-external.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/image-loader.js":
/*!***********************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/image-loader.js ***!
  \***********************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: function() {\n        return _default;\n    }\n}));\nconst DEFAULT_Q = 75;\nfunction defaultLoader(param) {\n    let { config, src, width, quality } = param;\n    var _config_qualities;\n    if (true) {\n        const missingValues = [];\n        // these should always be provided but make sure they are\n        if (!src) missingValues.push('src');\n        if (!width) missingValues.push('width');\n        if (missingValues.length > 0) {\n            throw new Error(\"Next Image Optimization requires \" + missingValues.join(', ') + \" to be provided. Make sure you pass them as props to the `next/image` component. Received: \" + JSON.stringify({\n                src,\n                width,\n                quality\n            }));\n        }\n        if (src.startsWith('//')) {\n            throw new Error('Failed to parse src \"' + src + '\" on `next/image`, protocol-relative URL (//) must be changed to an absolute URL (http:// or https://)');\n        }\n        if (src.startsWith('/') && config.localPatterns) {\n            if (true) {\n                // We use dynamic require because this should only error in development\n                const { hasLocalMatch } = __webpack_require__(/*! ./match-local-pattern */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/match-local-pattern.js\");\n                if (!hasLocalMatch(config.localPatterns, src)) {\n                    throw new Error(\"Invalid src prop (\" + src + \") on `next/image` does not match `images.localPatterns` configured in your `next.config.js`\\n\" + \"See more info: https://nextjs.org/docs/messages/next-image-unconfigured-localpatterns\");\n                }\n            }\n        }\n        if (!src.startsWith('/') && (config.domains || config.remotePatterns)) {\n            let parsedSrc;\n            try {\n                parsedSrc = new URL(src);\n            } catch (err) {\n                console.error(err);\n                throw new Error('Failed to parse src \"' + src + '\" on `next/image`, if using relative image it must start with a leading slash \"/\" or be an absolute URL (http:// or https://)');\n            }\n            if (true) {\n                // We use dynamic require because this should only error in development\n                const { hasRemoteMatch } = __webpack_require__(/*! ./match-remote-pattern */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/match-remote-pattern.js\");\n                if (!hasRemoteMatch(config.domains, config.remotePatterns, parsedSrc)) {\n                    throw new Error(\"Invalid src prop (\" + src + ') on `next/image`, hostname \"' + parsedSrc.hostname + '\" is not configured under images in your `next.config.js`\\n' + \"See more info: https://nextjs.org/docs/messages/next-image-unconfigured-host\");\n                }\n            }\n        }\n        if (quality && config.qualities && !config.qualities.includes(quality)) {\n            throw new Error(\"Invalid quality prop (\" + quality + \") on `next/image` does not match `images.qualities` configured in your `next.config.js`\\n\" + \"See more info: https://nextjs.org/docs/messages/next-image-unconfigured-qualities\");\n        }\n    }\n    const q = quality || ((_config_qualities = config.qualities) == null ? void 0 : _config_qualities.reduce((prev, cur)=>Math.abs(cur - DEFAULT_Q) < Math.abs(prev - DEFAULT_Q) ? cur : prev)) || DEFAULT_Q;\n    return config.path + \"?url=\" + encodeURIComponent(src) + \"&w=\" + width + \"&q=\" + q + (src.startsWith('/_next/static/media/') && false ? 0 : '');\n}\n// We use this to determine if the import is the default loader\n// or a custom loader defined by the user in next.config.js\ndefaultLoader.__next_img_default = true;\nconst _default = defaultLoader; //# sourceMappingURL=image-loader.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9pbWFnZS1sb2FkZXIuanMiLCJtYXBwaW5ncyI6Ijs7OzsyQ0F1R0E7OztlQUFBOzs7QUFyR0EsTUFBTUEsWUFBWTtBQUVsQixTQUFTQyxjQUFjLEtBS007SUFMTixNQUNyQkMsTUFBTSxFQUNOQyxHQUFHLEVBQ0hDLEtBQUssRUFDTEMsT0FBTyxFQUNvQixHQUxOO1FBbUZuQkg7SUE3RUYsSUFBSUksSUFBb0IsRUFBbUI7UUFDekMsTUFBTUcsZ0JBQWdCLEVBQUU7UUFFeEIseURBQXlEO1FBQ3pELElBQUksQ0FBQ04sS0FBS00sY0FBY0MsSUFBSSxDQUFDO1FBQzdCLElBQUksQ0FBQ04sT0FBT0ssY0FBY0MsSUFBSSxDQUFDO1FBRS9CLElBQUlELGNBQWNFLE1BQU0sR0FBRyxHQUFHO1lBQzVCLE1BQU0sSUFBSUMsTUFDUCxzQ0FBbUNILGNBQWNJLElBQUksQ0FDcEQsUUFDQSxnR0FBK0ZDLEtBQUtDLFNBQVMsQ0FDN0c7Z0JBQUVaO2dCQUFLQztnQkFBT0M7WUFBUTtRQUc1QjtRQUVBLElBQUlGLElBQUlhLFVBQVUsQ0FBQyxPQUFPO1lBQ3hCLE1BQU0sSUFBSUosTUFDUCwwQkFBdUJULE1BQUk7UUFFaEM7UUFFQSxJQUFJQSxJQUFJYSxVQUFVLENBQUMsUUFBUWQsT0FBT2UsYUFBYSxFQUFFO1lBQy9DLElBQ0VYLElBRW1DLEVBQ25DO2dCQUNBLHVFQUF1RTtnQkFDdkUsTUFBTSxFQUFFYSxhQUFhLEVBQUUsR0FBR0MsbUJBQU9BLENBQUMsNkdBQXVCO2dCQUN6RCxJQUFJLENBQUNELGNBQWNqQixPQUFPZSxhQUFhLEVBQUVkLE1BQU07b0JBQzdDLE1BQU0sSUFBSVMsTUFDUCx1QkFBb0JULE1BQUksa0dBQ3RCO2dCQUVQO1lBQ0Y7UUFDRjtRQUVBLElBQUksQ0FBQ0EsSUFBSWEsVUFBVSxDQUFDLFFBQVNkLENBQUFBLE9BQU9tQixPQUFPLElBQUluQixPQUFPb0IsY0FBQUEsR0FBaUI7WUFDckUsSUFBSUM7WUFDSixJQUFJO2dCQUNGQSxZQUFZLElBQUlDLElBQUlyQjtZQUN0QixFQUFFLE9BQU9zQixLQUFLO2dCQUNaQyxRQUFRQyxLQUFLLENBQUNGO2dCQUNkLE1BQU0sSUFBSWIsTUFDUCwwQkFBdUJULE1BQUk7WUFFaEM7WUFFQSxJQUNFRyxJQUVtQyxFQUNuQztnQkFDQSx1RUFBdUU7Z0JBQ3ZFLE1BQU0sRUFBRXNCLGNBQWMsRUFBRSxHQUFHUixtQkFBT0EsQ0FBQywrR0FBd0I7Z0JBQzNELElBQUksQ0FBQ1EsZUFBZTFCLE9BQU9tQixPQUFPLEVBQUVuQixPQUFPb0IsY0FBYyxFQUFFQyxZQUFZO29CQUNyRSxNQUFNLElBQUlYLE1BQ1AsdUJBQW9CVCxNQUFJLGtDQUFpQ29CLFVBQVVNLFFBQVEsR0FBQyxnRUFDMUU7Z0JBRVA7WUFDRjtRQUNGO1FBRUEsSUFBSXhCLFdBQVdILE9BQU80QixTQUFTLElBQUksQ0FBQzVCLE9BQU80QixTQUFTLENBQUNDLFFBQVEsQ0FBQzFCLFVBQVU7WUFDdEUsTUFBTSxJQUFJTyxNQUNQLDJCQUF3QlAsVUFBUSw4RkFDOUI7UUFFUDtJQUNGO0lBRUEsTUFBTTJCLElBQ0ozQixXQUFBQSxDQUFBQSxDQUNBSCxvQkFBQUEsT0FBTzRCLFNBQVMscUJBQWhCNUIsa0JBQWtCK0IsTUFBTSxDQUFDLENBQUNDLE1BQU1DLE1BQzlCQyxLQUFLQyxHQUFHLENBQUNGLE1BQU1uQyxhQUFhb0MsS0FBS0MsR0FBRyxDQUFDSCxPQUFPbEMsYUFBYW1DLE1BQU1ELEtBQUFBLEtBRWpFbEM7SUFFRixPQUFVRSxPQUFPb0MsSUFBSSxHQUFDLFVBQU9DLG1CQUFtQnBDLE9BQUssUUFBS0MsUUFBTSxRQUFLNEIsSUFDbkU3QixDQUFBQSxJQUFJYSxVQUFVLENBQUMsMkJBQTJCVixLQUE4QixHQUNuRSxDQUFxQyxHQUN0QyxHQUFDO0FBRVQ7QUFFQSwrREFBK0Q7QUFDL0QsMkRBQTJEO0FBQzNETCxjQUFjd0Msa0JBQWtCLEdBQUc7TUFFbkMsV0FBZXhDIiwic291cmNlcyI6WyIvVXNlcnMvam9uYXRoYW52aW5jZW50aXVzL0RvY3VtZW50cy9zcmMvc2hhcmVkL2xpYi9pbWFnZS1sb2FkZXIudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBJbWFnZUxvYWRlclByb3BzV2l0aENvbmZpZyB9IGZyb20gJy4vaW1hZ2UtY29uZmlnJ1xuXG5jb25zdCBERUZBVUxUX1EgPSA3NVxuXG5mdW5jdGlvbiBkZWZhdWx0TG9hZGVyKHtcbiAgY29uZmlnLFxuICBzcmMsXG4gIHdpZHRoLFxuICBxdWFsaXR5LFxufTogSW1hZ2VMb2FkZXJQcm9wc1dpdGhDb25maWcpOiBzdHJpbmcge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGNvbnN0IG1pc3NpbmdWYWx1ZXMgPSBbXVxuXG4gICAgLy8gdGhlc2Ugc2hvdWxkIGFsd2F5cyBiZSBwcm92aWRlZCBidXQgbWFrZSBzdXJlIHRoZXkgYXJlXG4gICAgaWYgKCFzcmMpIG1pc3NpbmdWYWx1ZXMucHVzaCgnc3JjJylcbiAgICBpZiAoIXdpZHRoKSBtaXNzaW5nVmFsdWVzLnB1c2goJ3dpZHRoJylcblxuICAgIGlmIChtaXNzaW5nVmFsdWVzLmxlbmd0aCA+IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYE5leHQgSW1hZ2UgT3B0aW1pemF0aW9uIHJlcXVpcmVzICR7bWlzc2luZ1ZhbHVlcy5qb2luKFxuICAgICAgICAgICcsICdcbiAgICAgICAgKX0gdG8gYmUgcHJvdmlkZWQuIE1ha2Ugc3VyZSB5b3UgcGFzcyB0aGVtIGFzIHByb3BzIHRvIHRoZSBcXGBuZXh0L2ltYWdlXFxgIGNvbXBvbmVudC4gUmVjZWl2ZWQ6ICR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgeyBzcmMsIHdpZHRoLCBxdWFsaXR5IH1cbiAgICAgICAgKX1gXG4gICAgICApXG4gICAgfVxuXG4gICAgaWYgKHNyYy5zdGFydHNXaXRoKCcvLycpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBGYWlsZWQgdG8gcGFyc2Ugc3JjIFwiJHtzcmN9XCIgb24gXFxgbmV4dC9pbWFnZVxcYCwgcHJvdG9jb2wtcmVsYXRpdmUgVVJMICgvLykgbXVzdCBiZSBjaGFuZ2VkIHRvIGFuIGFic29sdXRlIFVSTCAoaHR0cDovLyBvciBodHRwczovLylgXG4gICAgICApXG4gICAgfVxuXG4gICAgaWYgKHNyYy5zdGFydHNXaXRoKCcvJykgJiYgY29uZmlnLmxvY2FsUGF0dGVybnMpIHtcbiAgICAgIGlmIChcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICd0ZXN0JyAmJlxuICAgICAgICAvLyBtaWNyb21hdGNoIGlzbid0IGNvbXBhdGlibGUgd2l0aCBlZGdlIHJ1bnRpbWVcbiAgICAgICAgcHJvY2Vzcy5lbnYuTkVYVF9SVU5USU1FICE9PSAnZWRnZSdcbiAgICAgICkge1xuICAgICAgICAvLyBXZSB1c2UgZHluYW1pYyByZXF1aXJlIGJlY2F1c2UgdGhpcyBzaG91bGQgb25seSBlcnJvciBpbiBkZXZlbG9wbWVudFxuICAgICAgICBjb25zdCB7IGhhc0xvY2FsTWF0Y2ggfSA9IHJlcXVpcmUoJy4vbWF0Y2gtbG9jYWwtcGF0dGVybicpXG4gICAgICAgIGlmICghaGFzTG9jYWxNYXRjaChjb25maWcubG9jYWxQYXR0ZXJucywgc3JjKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBJbnZhbGlkIHNyYyBwcm9wICgke3NyY30pIG9uIFxcYG5leHQvaW1hZ2VcXGAgZG9lcyBub3QgbWF0Y2ggXFxgaW1hZ2VzLmxvY2FsUGF0dGVybnNcXGAgY29uZmlndXJlZCBpbiB5b3VyIFxcYG5leHQuY29uZmlnLmpzXFxgXFxuYCArXG4gICAgICAgICAgICAgIGBTZWUgbW9yZSBpbmZvOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9uZXh0LWltYWdlLXVuY29uZmlndXJlZC1sb2NhbHBhdHRlcm5zYFxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghc3JjLnN0YXJ0c1dpdGgoJy8nKSAmJiAoY29uZmlnLmRvbWFpbnMgfHwgY29uZmlnLnJlbW90ZVBhdHRlcm5zKSkge1xuICAgICAgbGV0IHBhcnNlZFNyYzogVVJMXG4gICAgICB0cnkge1xuICAgICAgICBwYXJzZWRTcmMgPSBuZXcgVVJMKHNyYylcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGVycilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBGYWlsZWQgdG8gcGFyc2Ugc3JjIFwiJHtzcmN9XCIgb24gXFxgbmV4dC9pbWFnZVxcYCwgaWYgdXNpbmcgcmVsYXRpdmUgaW1hZ2UgaXQgbXVzdCBzdGFydCB3aXRoIGEgbGVhZGluZyBzbGFzaCBcIi9cIiBvciBiZSBhbiBhYnNvbHV0ZSBVUkwgKGh0dHA6Ly8gb3IgaHR0cHM6Ly8pYFxuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIGlmIChcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICd0ZXN0JyAmJlxuICAgICAgICAvLyBtaWNyb21hdGNoIGlzbid0IGNvbXBhdGlibGUgd2l0aCBlZGdlIHJ1bnRpbWVcbiAgICAgICAgcHJvY2Vzcy5lbnYuTkVYVF9SVU5USU1FICE9PSAnZWRnZSdcbiAgICAgICkge1xuICAgICAgICAvLyBXZSB1c2UgZHluYW1pYyByZXF1aXJlIGJlY2F1c2UgdGhpcyBzaG91bGQgb25seSBlcnJvciBpbiBkZXZlbG9wbWVudFxuICAgICAgICBjb25zdCB7IGhhc1JlbW90ZU1hdGNoIH0gPSByZXF1aXJlKCcuL21hdGNoLXJlbW90ZS1wYXR0ZXJuJylcbiAgICAgICAgaWYgKCFoYXNSZW1vdGVNYXRjaChjb25maWcuZG9tYWlucywgY29uZmlnLnJlbW90ZVBhdHRlcm5zLCBwYXJzZWRTcmMpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYEludmFsaWQgc3JjIHByb3AgKCR7c3JjfSkgb24gXFxgbmV4dC9pbWFnZVxcYCwgaG9zdG5hbWUgXCIke3BhcnNlZFNyYy5ob3N0bmFtZX1cIiBpcyBub3QgY29uZmlndXJlZCB1bmRlciBpbWFnZXMgaW4geW91ciBcXGBuZXh0LmNvbmZpZy5qc1xcYFxcbmAgK1xuICAgICAgICAgICAgICBgU2VlIG1vcmUgaW5mbzogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvbmV4dC1pbWFnZS11bmNvbmZpZ3VyZWQtaG9zdGBcbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocXVhbGl0eSAmJiBjb25maWcucXVhbGl0aWVzICYmICFjb25maWcucXVhbGl0aWVzLmluY2x1ZGVzKHF1YWxpdHkpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBJbnZhbGlkIHF1YWxpdHkgcHJvcCAoJHtxdWFsaXR5fSkgb24gXFxgbmV4dC9pbWFnZVxcYCBkb2VzIG5vdCBtYXRjaCBcXGBpbWFnZXMucXVhbGl0aWVzXFxgIGNvbmZpZ3VyZWQgaW4geW91ciBcXGBuZXh0LmNvbmZpZy5qc1xcYFxcbmAgK1xuICAgICAgICAgIGBTZWUgbW9yZSBpbmZvOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9uZXh0LWltYWdlLXVuY29uZmlndXJlZC1xdWFsaXRpZXNgXG4gICAgICApXG4gICAgfVxuICB9XG5cbiAgY29uc3QgcSA9XG4gICAgcXVhbGl0eSB8fFxuICAgIGNvbmZpZy5xdWFsaXRpZXM/LnJlZHVjZSgocHJldiwgY3VyKSA9PlxuICAgICAgTWF0aC5hYnMoY3VyIC0gREVGQVVMVF9RKSA8IE1hdGguYWJzKHByZXYgLSBERUZBVUxUX1EpID8gY3VyIDogcHJldlxuICAgICkgfHxcbiAgICBERUZBVUxUX1FcblxuICByZXR1cm4gYCR7Y29uZmlnLnBhdGh9P3VybD0ke2VuY29kZVVSSUNvbXBvbmVudChzcmMpfSZ3PSR7d2lkdGh9JnE9JHtxfSR7XG4gICAgc3JjLnN0YXJ0c1dpdGgoJy9fbmV4dC9zdGF0aWMvbWVkaWEvJykgJiYgcHJvY2Vzcy5lbnYuTkVYVF9ERVBMT1lNRU5UX0lEXG4gICAgICA/IGAmZHBsPSR7cHJvY2Vzcy5lbnYuTkVYVF9ERVBMT1lNRU5UX0lEfWBcbiAgICAgIDogJydcbiAgfWBcbn1cblxuLy8gV2UgdXNlIHRoaXMgdG8gZGV0ZXJtaW5lIGlmIHRoZSBpbXBvcnQgaXMgdGhlIGRlZmF1bHQgbG9hZGVyXG4vLyBvciBhIGN1c3RvbSBsb2FkZXIgZGVmaW5lZCBieSB0aGUgdXNlciBpbiBuZXh0LmNvbmZpZy5qc1xuZGVmYXVsdExvYWRlci5fX25leHRfaW1nX2RlZmF1bHQgPSB0cnVlXG5cbmV4cG9ydCBkZWZhdWx0IGRlZmF1bHRMb2FkZXJcbiJdLCJuYW1lcyI6WyJERUZBVUxUX1EiLCJkZWZhdWx0TG9hZGVyIiwiY29uZmlnIiwic3JjIiwid2lkdGgiLCJxdWFsaXR5IiwicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIiwibWlzc2luZ1ZhbHVlcyIsInB1c2giLCJsZW5ndGgiLCJFcnJvciIsImpvaW4iLCJKU09OIiwic3RyaW5naWZ5Iiwic3RhcnRzV2l0aCIsImxvY2FsUGF0dGVybnMiLCJORVhUX1JVTlRJTUUiLCJoYXNMb2NhbE1hdGNoIiwicmVxdWlyZSIsImRvbWFpbnMiLCJyZW1vdGVQYXR0ZXJucyIsInBhcnNlZFNyYyIsIlVSTCIsImVyciIsImNvbnNvbGUiLCJlcnJvciIsImhhc1JlbW90ZU1hdGNoIiwiaG9zdG5hbWUiLCJxdWFsaXRpZXMiLCJpbmNsdWRlcyIsInEiLCJyZWR1Y2UiLCJwcmV2IiwiY3VyIiwiTWF0aCIsImFicyIsInBhdGgiLCJlbmNvZGVVUklDb21wb25lbnQiLCJORVhUX0RFUExPWU1FTlRfSUQiLCJfX25leHRfaW1nX2RlZmF1bHQiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/image-loader.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/match-local-pattern.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/match-local-pattern.js ***!
  \******************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    hasLocalMatch: function() {\n        return hasLocalMatch;\n    },\n    matchLocalPattern: function() {\n        return matchLocalPattern;\n    }\n});\nconst _picomatch = __webpack_require__(/*! next/dist/compiled/picomatch */ \"(app-pages-browser)/./node_modules/next/dist/compiled/picomatch/index.js\");\nfunction matchLocalPattern(pattern, url) {\n    if (pattern.search !== undefined) {\n        if (pattern.search !== url.search) {\n            return false;\n        }\n    }\n    var _pattern_pathname;\n    if (!(0, _picomatch.makeRe)((_pattern_pathname = pattern.pathname) != null ? _pattern_pathname : '**', {\n        dot: true\n    }).test(url.pathname)) {\n        return false;\n    }\n    return true;\n}\nfunction hasLocalMatch(localPatterns, urlPathAndQuery) {\n    if (!localPatterns) {\n        // if the user didn't define \"localPatterns\", we allow all local images\n        return true;\n    }\n    const url = new URL(urlPathAndQuery, 'http://n');\n    return localPatterns.some((p)=>matchLocalPattern(p, url));\n} //# sourceMappingURL=match-local-pattern.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9tYXRjaC1sb2NhbC1wYXR0ZXJuLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztJQWtCZ0JBLGFBQWE7ZUFBYkE7O0lBZEFDLGlCQUFpQjtlQUFqQkE7Ozt1Q0FITztBQUdoQixTQUFTQSxrQkFBa0JDLE9BQXFCLEVBQUVDLEdBQVE7SUFDL0QsSUFBSUQsUUFBUUUsTUFBTSxLQUFLQyxXQUFXO1FBQ2hDLElBQUlILFFBQVFFLE1BQU0sS0FBS0QsSUFBSUMsTUFBTSxFQUFFO1lBQ2pDLE9BQU87UUFDVDtJQUNGO1FBRVlGO0lBQVosSUFBSSxDQUFDSSxDQUFBQSxHQUFBQSxXQUFBQSxNQUFBQSxFQUFPSixDQUFBQSxvQkFBQUEsUUFBUUssUUFBQUEsS0FBUSxPQUFoQkwsb0JBQW9CLE1BQU07UUFBRU0sS0FBSztJQUFLLEdBQUdDLElBQUksQ0FBQ04sSUFBSUksUUFBUSxHQUFHO1FBQ3ZFLE9BQU87SUFDVDtJQUVBLE9BQU87QUFDVDtBQUVPLFNBQVNQLGNBQ2RVLGFBQXlDLEVBQ3pDQyxlQUF1QjtJQUV2QixJQUFJLENBQUNELGVBQWU7UUFDbEIsdUVBQXVFO1FBQ3ZFLE9BQU87SUFDVDtJQUNBLE1BQU1QLE1BQU0sSUFBSVMsSUFBSUQsaUJBQWlCO0lBQ3JDLE9BQU9ELGNBQWNHLElBQUksQ0FBQyxDQUFDQyxJQUFNYixrQkFBa0JhLEdBQUdYO0FBQ3hEIiwic291cmNlcyI6WyIvVXNlcnMvam9uYXRoYW52aW5jZW50aXVzL0RvY3VtZW50cy9zcmMvc2hhcmVkL2xpYi9tYXRjaC1sb2NhbC1wYXR0ZXJuLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgTG9jYWxQYXR0ZXJuIH0gZnJvbSAnLi9pbWFnZS1jb25maWcnXG5pbXBvcnQgeyBtYWtlUmUgfSBmcm9tICduZXh0L2Rpc3QvY29tcGlsZWQvcGljb21hdGNoJ1xuXG4vLyBNb2RpZnlpbmcgdGhpcyBmdW5jdGlvbiBzaG91bGQgYWxzbyBtb2RpZnkgd3JpdGVJbWFnZXNNYW5pZmVzdCgpXG5leHBvcnQgZnVuY3Rpb24gbWF0Y2hMb2NhbFBhdHRlcm4ocGF0dGVybjogTG9jYWxQYXR0ZXJuLCB1cmw6IFVSTCk6IGJvb2xlYW4ge1xuICBpZiAocGF0dGVybi5zZWFyY2ggIT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChwYXR0ZXJuLnNlYXJjaCAhPT0gdXJsLnNlYXJjaCkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG5cbiAgaWYgKCFtYWtlUmUocGF0dGVybi5wYXRobmFtZSA/PyAnKionLCB7IGRvdDogdHJ1ZSB9KS50ZXN0KHVybC5wYXRobmFtZSkpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoYXNMb2NhbE1hdGNoKFxuICBsb2NhbFBhdHRlcm5zOiBMb2NhbFBhdHRlcm5bXSB8IHVuZGVmaW5lZCxcbiAgdXJsUGF0aEFuZFF1ZXJ5OiBzdHJpbmdcbik6IGJvb2xlYW4ge1xuICBpZiAoIWxvY2FsUGF0dGVybnMpIHtcbiAgICAvLyBpZiB0aGUgdXNlciBkaWRuJ3QgZGVmaW5lIFwibG9jYWxQYXR0ZXJuc1wiLCB3ZSBhbGxvdyBhbGwgbG9jYWwgaW1hZ2VzXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICBjb25zdCB1cmwgPSBuZXcgVVJMKHVybFBhdGhBbmRRdWVyeSwgJ2h0dHA6Ly9uJylcbiAgcmV0dXJuIGxvY2FsUGF0dGVybnMuc29tZSgocCkgPT4gbWF0Y2hMb2NhbFBhdHRlcm4ocCwgdXJsKSlcbn1cbiJdLCJuYW1lcyI6WyJoYXNMb2NhbE1hdGNoIiwibWF0Y2hMb2NhbFBhdHRlcm4iLCJwYXR0ZXJuIiwidXJsIiwic2VhcmNoIiwidW5kZWZpbmVkIiwibWFrZVJlIiwicGF0aG5hbWUiLCJkb3QiLCJ0ZXN0IiwibG9jYWxQYXR0ZXJucyIsInVybFBhdGhBbmRRdWVyeSIsIlVSTCIsInNvbWUiLCJwIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/match-local-pattern.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/match-remote-pattern.js":
/*!*******************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/match-remote-pattern.js ***!
  \*******************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    hasRemoteMatch: function() {\n        return hasRemoteMatch;\n    },\n    matchRemotePattern: function() {\n        return matchRemotePattern;\n    }\n});\nconst _picomatch = __webpack_require__(/*! next/dist/compiled/picomatch */ \"(app-pages-browser)/./node_modules/next/dist/compiled/picomatch/index.js\");\nfunction matchRemotePattern(pattern, url) {\n    if (pattern.protocol !== undefined) {\n        const actualProto = url.protocol.slice(0, -1);\n        if (pattern.protocol !== actualProto) {\n            return false;\n        }\n    }\n    if (pattern.port !== undefined) {\n        if (pattern.port !== url.port) {\n            return false;\n        }\n    }\n    if (pattern.hostname === undefined) {\n        throw new Error(\"Pattern should define hostname but found\\n\" + JSON.stringify(pattern));\n    } else {\n        if (!(0, _picomatch.makeRe)(pattern.hostname).test(url.hostname)) {\n            return false;\n        }\n    }\n    if (pattern.search !== undefined) {\n        if (pattern.search !== url.search) {\n            return false;\n        }\n    }\n    var _pattern_pathname;\n    // Should be the same as writeImagesManifest()\n    if (!(0, _picomatch.makeRe)((_pattern_pathname = pattern.pathname) != null ? _pattern_pathname : '**', {\n        dot: true\n    }).test(url.pathname)) {\n        return false;\n    }\n    return true;\n}\nfunction hasRemoteMatch(domains, remotePatterns, url) {\n    return domains.some((domain)=>url.hostname === domain) || remotePatterns.some((p)=>matchRemotePattern(p, url));\n} //# sourceMappingURL=match-remote-pattern.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9tYXRjaC1yZW1vdGUtcGF0dGVybi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7SUF5Q2dCQSxjQUFjO2VBQWRBOztJQXJDQUMsa0JBQWtCO2VBQWxCQTs7O3VDQUhPO0FBR2hCLFNBQVNBLG1CQUFtQkMsT0FBc0IsRUFBRUMsR0FBUTtJQUNqRSxJQUFJRCxRQUFRRSxRQUFRLEtBQUtDLFdBQVc7UUFDbEMsTUFBTUMsY0FBY0gsSUFBSUMsUUFBUSxDQUFDRyxLQUFLLENBQUMsR0FBRyxDQUFDO1FBQzNDLElBQUlMLFFBQVFFLFFBQVEsS0FBS0UsYUFBYTtZQUNwQyxPQUFPO1FBQ1Q7SUFDRjtJQUNBLElBQUlKLFFBQVFNLElBQUksS0FBS0gsV0FBVztRQUM5QixJQUFJSCxRQUFRTSxJQUFJLEtBQUtMLElBQUlLLElBQUksRUFBRTtZQUM3QixPQUFPO1FBQ1Q7SUFDRjtJQUVBLElBQUlOLFFBQVFPLFFBQVEsS0FBS0osV0FBVztRQUNsQyxNQUFNLElBQUlLLE1BQ1AsK0NBQTRDQyxLQUFLQyxTQUFTLENBQUNWO0lBRWhFLE9BQU87UUFDTCxJQUFJLENBQUNXLENBQUFBLEdBQUFBLFdBQUFBLE1BQUFBLEVBQU9YLFFBQVFPLFFBQVEsRUFBRUssSUFBSSxDQUFDWCxJQUFJTSxRQUFRLEdBQUc7WUFDaEQsT0FBTztRQUNUO0lBQ0Y7SUFFQSxJQUFJUCxRQUFRYSxNQUFNLEtBQUtWLFdBQVc7UUFDaEMsSUFBSUgsUUFBUWEsTUFBTSxLQUFLWixJQUFJWSxNQUFNLEVBQUU7WUFDakMsT0FBTztRQUNUO0lBQ0Y7UUFHWWI7SUFEWiw4Q0FBOEM7SUFDOUMsSUFBSSxDQUFDVyxDQUFBQSxHQUFBQSxXQUFBQSxNQUFBQSxFQUFPWCxDQUFBQSxvQkFBQUEsUUFBUWMsUUFBQUEsS0FBUSxPQUFoQmQsb0JBQW9CLE1BQU07UUFBRWUsS0FBSztJQUFLLEdBQUdILElBQUksQ0FBQ1gsSUFBSWEsUUFBUSxHQUFHO1FBQ3ZFLE9BQU87SUFDVDtJQUVBLE9BQU87QUFDVDtBQUVPLFNBQVNoQixlQUNka0IsT0FBaUIsRUFDakJDLGNBQStCLEVBQy9CaEIsR0FBUTtJQUVSLE9BQ0VlLFFBQVFFLElBQUksQ0FBQyxDQUFDQyxTQUFXbEIsSUFBSU0sUUFBUSxLQUFLWSxXQUMxQ0YsZUFBZUMsSUFBSSxDQUFDLENBQUNFLElBQU1yQixtQkFBbUJxQixHQUFHbkI7QUFFckQiLCJzb3VyY2VzIjpbIi9Vc2Vycy9qb25hdGhhbnZpbmNlbnRpdXMvRG9jdW1lbnRzL3NyYy9zaGFyZWQvbGliL21hdGNoLXJlbW90ZS1wYXR0ZXJuLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgUmVtb3RlUGF0dGVybiB9IGZyb20gJy4vaW1hZ2UtY29uZmlnJ1xuaW1wb3J0IHsgbWFrZVJlIH0gZnJvbSAnbmV4dC9kaXN0L2NvbXBpbGVkL3BpY29tYXRjaCdcblxuLy8gTW9kaWZ5aW5nIHRoaXMgZnVuY3Rpb24gc2hvdWxkIGFsc28gbW9kaWZ5IHdyaXRlSW1hZ2VzTWFuaWZlc3QoKVxuZXhwb3J0IGZ1bmN0aW9uIG1hdGNoUmVtb3RlUGF0dGVybihwYXR0ZXJuOiBSZW1vdGVQYXR0ZXJuLCB1cmw6IFVSTCk6IGJvb2xlYW4ge1xuICBpZiAocGF0dGVybi5wcm90b2NvbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29uc3QgYWN0dWFsUHJvdG8gPSB1cmwucHJvdG9jb2wuc2xpY2UoMCwgLTEpXG4gICAgaWYgKHBhdHRlcm4ucHJvdG9jb2wgIT09IGFjdHVhbFByb3RvKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cbiAgaWYgKHBhdHRlcm4ucG9ydCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHBhdHRlcm4ucG9ydCAhPT0gdXJsLnBvcnQpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuXG4gIGlmIChwYXR0ZXJuLmhvc3RuYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgUGF0dGVybiBzaG91bGQgZGVmaW5lIGhvc3RuYW1lIGJ1dCBmb3VuZFxcbiR7SlNPTi5zdHJpbmdpZnkocGF0dGVybil9YFxuICAgIClcbiAgfSBlbHNlIHtcbiAgICBpZiAoIW1ha2VSZShwYXR0ZXJuLmhvc3RuYW1lKS50ZXN0KHVybC5ob3N0bmFtZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuXG4gIGlmIChwYXR0ZXJuLnNlYXJjaCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHBhdHRlcm4uc2VhcmNoICE9PSB1cmwuc2VhcmNoKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cblxuICAvLyBTaG91bGQgYmUgdGhlIHNhbWUgYXMgd3JpdGVJbWFnZXNNYW5pZmVzdCgpXG4gIGlmICghbWFrZVJlKHBhdHRlcm4ucGF0aG5hbWUgPz8gJyoqJywgeyBkb3Q6IHRydWUgfSkudGVzdCh1cmwucGF0aG5hbWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICByZXR1cm4gdHJ1ZVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaGFzUmVtb3RlTWF0Y2goXG4gIGRvbWFpbnM6IHN0cmluZ1tdLFxuICByZW1vdGVQYXR0ZXJuczogUmVtb3RlUGF0dGVybltdLFxuICB1cmw6IFVSTFxuKTogYm9vbGVhbiB7XG4gIHJldHVybiAoXG4gICAgZG9tYWlucy5zb21lKChkb21haW4pID0+IHVybC5ob3N0bmFtZSA9PT0gZG9tYWluKSB8fFxuICAgIHJlbW90ZVBhdHRlcm5zLnNvbWUoKHApID0+IG1hdGNoUmVtb3RlUGF0dGVybihwLCB1cmwpKVxuICApXG59XG4iXSwibmFtZXMiOlsiaGFzUmVtb3RlTWF0Y2giLCJtYXRjaFJlbW90ZVBhdHRlcm4iLCJwYXR0ZXJuIiwidXJsIiwicHJvdG9jb2wiLCJ1bmRlZmluZWQiLCJhY3R1YWxQcm90byIsInNsaWNlIiwicG9ydCIsImhvc3RuYW1lIiwiRXJyb3IiLCJKU09OIiwic3RyaW5naWZ5IiwibWFrZVJlIiwidGVzdCIsInNlYXJjaCIsInBhdGhuYW1lIiwiZG90IiwiZG9tYWlucyIsInJlbW90ZVBhdHRlcm5zIiwic29tZSIsImRvbWFpbiIsInAiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/match-remote-pattern.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/router-context.shared-runtime.js":
/*!****************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router-context.shared-runtime.js ***!
  \****************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"RouterContext\", ({\n    enumerable: true,\n    get: function() {\n        return RouterContext;\n    }\n}));\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _react = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nconst RouterContext = _react.default.createContext(null);\nif (true) {\n    RouterContext.displayName = 'RouterContext';\n} //# sourceMappingURL=router-context.shared-runtime.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXItY29udGV4dC5zaGFyZWQtcnVudGltZS5qcyIsIm1hcHBpbmdzIjoiOzs7O2lEQUdhQTs7O2VBQUFBOzs7OzRFQUhLO0FBR1gsTUFBTUEsZ0JBQWdCQyxPQUFBQSxPQUFLLENBQUNDLGFBQWEsQ0FBb0I7QUFFcEUsSUFBSUMsSUFBb0IsRUFBbUI7SUFDekNILGNBQWNNLFdBQVcsR0FBRztBQUM5QiIsInNvdXJjZXMiOlsiL1VzZXJzL2pvbmF0aGFudmluY2VudGl1cy9Eb2N1bWVudHMvc3JjL3NoYXJlZC9saWIvcm91dGVyLWNvbnRleHQuc2hhcmVkLXJ1bnRpbWUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHR5cGUgeyBOZXh0Um91dGVyIH0gZnJvbSAnLi9yb3V0ZXIvcm91dGVyJ1xuXG5leHBvcnQgY29uc3QgUm91dGVyQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQ8TmV4dFJvdXRlciB8IG51bGw+KG51bGwpXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIFJvdXRlckNvbnRleHQuZGlzcGxheU5hbWUgPSAnUm91dGVyQ29udGV4dCdcbn1cbiJdLCJuYW1lcyI6WyJSb3V0ZXJDb250ZXh0IiwiUmVhY3QiLCJjcmVhdGVDb250ZXh0IiwicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIiwiZGlzcGxheU5hbWUiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/router-context.shared-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/side-effect.js":
/*!**********************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/side-effect.js ***!
  \**********************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nvar _s = $RefreshSig$();\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: function() {\n        return SideEffect;\n    }\n}));\nconst _react = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\nconst isServer = typeof window === 'undefined';\nconst useClientOnlyLayoutEffect = isServer ? ()=>{} : _react.useLayoutEffect;\nconst useClientOnlyEffect = isServer ? ()=>{} : _react.useEffect;\nfunction SideEffect(props) {\n    _s();\n    const { headManager, reduceComponentsToState } = props;\n    function emitChange() {\n        if (headManager && headManager.mountedInstances) {\n            const headElements = _react.Children.toArray(Array.from(headManager.mountedInstances).filter(Boolean));\n            headManager.updateHead(reduceComponentsToState(headElements, props));\n        }\n    }\n    if (isServer) {\n        var _headManager_mountedInstances;\n        headManager == null ? void 0 : (_headManager_mountedInstances = headManager.mountedInstances) == null ? void 0 : _headManager_mountedInstances.add(props.children);\n        emitChange();\n    }\n    useClientOnlyLayoutEffect({\n        \"SideEffect.useClientOnlyLayoutEffect\": ()=>{\n            var _headManager_mountedInstances;\n            headManager == null ? void 0 : (_headManager_mountedInstances = headManager.mountedInstances) == null ? void 0 : _headManager_mountedInstances.add(props.children);\n            return ({\n                \"SideEffect.useClientOnlyLayoutEffect\": ()=>{\n                    var _headManager_mountedInstances;\n                    headManager == null ? void 0 : (_headManager_mountedInstances = headManager.mountedInstances) == null ? void 0 : _headManager_mountedInstances.delete(props.children);\n                }\n            })[\"SideEffect.useClientOnlyLayoutEffect\"];\n        }\n    }[\"SideEffect.useClientOnlyLayoutEffect\"]);\n    // We need to call `updateHead` method whenever the `SideEffect` is trigger in all\n    // life-cycles: mount, update, unmount. However, if there are multiple `SideEffect`s\n    // being rendered, we only trigger the method from the last one.\n    // This is ensured by keeping the last unflushed `updateHead` in the `_pendingUpdate`\n    // singleton in the layout effect pass, and actually trigger it in the effect pass.\n    useClientOnlyLayoutEffect({\n        \"SideEffect.useClientOnlyLayoutEffect\": ()=>{\n            if (headManager) {\n                headManager._pendingUpdate = emitChange;\n            }\n            return ({\n                \"SideEffect.useClientOnlyLayoutEffect\": ()=>{\n                    if (headManager) {\n                        headManager._pendingUpdate = emitChange;\n                    }\n                }\n            })[\"SideEffect.useClientOnlyLayoutEffect\"];\n        }\n    }[\"SideEffect.useClientOnlyLayoutEffect\"]);\n    useClientOnlyEffect({\n        \"SideEffect.useClientOnlyEffect\": ()=>{\n            if (headManager && headManager._pendingUpdate) {\n                headManager._pendingUpdate();\n                headManager._pendingUpdate = null;\n            }\n            return ({\n                \"SideEffect.useClientOnlyEffect\": ()=>{\n                    if (headManager && headManager._pendingUpdate) {\n                        headManager._pendingUpdate();\n                        headManager._pendingUpdate = null;\n                    }\n                }\n            })[\"SideEffect.useClientOnlyEffect\"];\n        }\n    }[\"SideEffect.useClientOnlyEffect\"]);\n    return null;\n} //# sourceMappingURL=side-effect.js.map\n_s(SideEffect, \"gHVkikNHNxjVdD11eJBzaqkCiPY=\", false, function() {\n    return [\n        useClientOnlyLayoutEffect,\n        useClientOnlyLayoutEffect,\n        useClientOnlyEffect\n    ];\n});\n_c = SideEffect;\nvar _c;\n$RefreshReg$(_c, \"SideEffect\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9zaWRlLWVmZmVjdC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7MkNBb0JBOzs7ZUFBd0JBOzs7bUNBbkJ1QztBQWUvRCxNQUFNQyxXQUFXLE9BQU9DLFdBQVc7QUFDbkMsTUFBTUMsNEJBQTRCRixXQUFXLEtBQU8sSUFBSUcsT0FBQUEsZUFBZTtBQUN2RSxNQUFNQyxzQkFBc0JKLFdBQVcsS0FBTyxJQUFJSyxPQUFBQSxTQUFTO0FBRTVDLG9CQUFvQkMsS0FBc0I7O0lBQ3ZELE1BQU0sRUFBRUMsV0FBVyxFQUFFQyx1QkFBdUIsRUFBRSxHQUFHRjtJQUVqRCxTQUFTRztRQUNQLElBQUlGLGVBQWVBLFlBQVlHLGdCQUFnQixFQUFFO1lBQy9DLE1BQU1DLGVBQWVDLE9BQUFBLFFBQVEsQ0FBQ0MsT0FBTyxDQUNuQ0MsTUFBTUMsSUFBSSxDQUFDUixZQUFZRyxnQkFBZ0IsRUFBMEJNLE1BQU0sQ0FDckVDO1lBR0pWLFlBQVlXLFVBQVUsQ0FBQ1Ysd0JBQXdCRyxjQUFjTDtRQUMvRDtJQUNGO0lBRUEsSUFBSU4sVUFBVTtZQUNaTztRQUFBQSxlQUFBQSxPQUFBQSxLQUFBQSxJQUFBQSxDQUFBQSxnQ0FBQUEsWUFBYUcsZ0JBQUFBLEtBQWdCLGdCQUE3QkgsOEJBQStCWSxHQUFHLENBQUNiLE1BQU1jLFFBQVE7UUFDakRYO0lBQ0Y7O2dEQUUwQjtnQkFDeEJGO1lBQUFBLGVBQUFBLE9BQUFBLEtBQUFBLElBQUFBLENBQUFBLGdDQUFBQSxZQUFhRyxnQkFBQUEsS0FBZ0IsZ0JBQTdCSCw4QkFBK0JZLEdBQUcsQ0FBQ2IsTUFBTWMsUUFBUTtZQUNqRDt3REFBTzt3QkFDTGI7b0JBQUFBLGVBQUFBLE9BQUFBLEtBQUFBLElBQUFBLENBQUFBLGdDQUFBQSxZQUFhRyxnQkFBQUEsS0FBZ0IsZ0JBQTdCSCw4QkFBK0JjLE1BQU0sQ0FBQ2YsTUFBTWMsUUFBUTtnQkFDdEQ7O1FBQ0Y7O0lBRUEsa0ZBQWtGO0lBQ2xGLG9GQUFvRjtJQUNwRixnRUFBZ0U7SUFDaEUscUZBQXFGO0lBQ3JGLG1GQUFtRjs7Z0RBQ3pEO1lBQ3hCLElBQUliLGFBQWE7Z0JBQ2ZBLFlBQVllLGNBQWMsR0FBR2I7WUFDL0I7WUFDQTt3REFBTztvQkFDTCxJQUFJRixhQUFhO3dCQUNmQSxZQUFZZSxjQUFjLEdBQUdiO29CQUMvQjtnQkFDRjs7UUFDRjs7OzBDQUVvQjtZQUNsQixJQUFJRixlQUFlQSxZQUFZZSxjQUFjLEVBQUU7Z0JBQzdDZixZQUFZZSxjQUFjO2dCQUMxQmYsWUFBWWUsY0FBYyxHQUFHO1lBQy9CO1lBQ0E7a0RBQU87b0JBQ0wsSUFBSWYsZUFBZUEsWUFBWWUsY0FBYyxFQUFFO3dCQUM3Q2YsWUFBWWUsY0FBYzt3QkFDMUJmLFlBQVllLGNBQWMsR0FBRztvQkFDL0I7Z0JBQ0Y7O1FBQ0Y7O0lBRUEsT0FBTztBQUNUOzs7UUFyQ0VwQjtRQVlBQTtRQVdBRTs7O0tBMUNzQkwiLCJzb3VyY2VzIjpbIi9Vc2Vycy9qb25hdGhhbnZpbmNlbnRpdXMvRG9jdW1lbnRzL3NyYy9zaGFyZWQvbGliL3NpZGUtZWZmZWN0LnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSBSZWFjdCBmcm9tICdyZWFjdCdcbmltcG9ydCB7IENoaWxkcmVuLCB1c2VFZmZlY3QsIHVzZUxheW91dEVmZmVjdCwgdHlwZSBKU1ggfSBmcm9tICdyZWFjdCdcblxudHlwZSBTdGF0ZSA9IEpTWC5FbGVtZW50W10gfCB1bmRlZmluZWRcblxuZXhwb3J0IHR5cGUgU2lkZUVmZmVjdFByb3BzID0ge1xuICByZWR1Y2VDb21wb25lbnRzVG9TdGF0ZTogPFQgZXh0ZW5kcyB7fT4oXG4gICAgY29tcG9uZW50czogQXJyYXk8UmVhY3QuUmVhY3RFbGVtZW50PGFueT4+LFxuICAgIHByb3BzOiBUXG4gICkgPT4gU3RhdGVcbiAgaGFuZGxlU3RhdGVDaGFuZ2U/OiAoc3RhdGU6IFN0YXRlKSA9PiB2b2lkXG4gIGhlYWRNYW5hZ2VyOiBhbnlcbiAgaW5BbXBNb2RlPzogYm9vbGVhblxuICBjaGlsZHJlbjogUmVhY3QuUmVhY3ROb2RlXG59XG5cbmNvbnN0IGlzU2VydmVyID0gdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCdcbmNvbnN0IHVzZUNsaWVudE9ubHlMYXlvdXRFZmZlY3QgPSBpc1NlcnZlciA/ICgpID0+IHt9IDogdXNlTGF5b3V0RWZmZWN0XG5jb25zdCB1c2VDbGllbnRPbmx5RWZmZWN0ID0gaXNTZXJ2ZXIgPyAoKSA9PiB7fSA6IHVzZUVmZmVjdFxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBTaWRlRWZmZWN0KHByb3BzOiBTaWRlRWZmZWN0UHJvcHMpIHtcbiAgY29uc3QgeyBoZWFkTWFuYWdlciwgcmVkdWNlQ29tcG9uZW50c1RvU3RhdGUgfSA9IHByb3BzXG5cbiAgZnVuY3Rpb24gZW1pdENoYW5nZSgpIHtcbiAgICBpZiAoaGVhZE1hbmFnZXIgJiYgaGVhZE1hbmFnZXIubW91bnRlZEluc3RhbmNlcykge1xuICAgICAgY29uc3QgaGVhZEVsZW1lbnRzID0gQ2hpbGRyZW4udG9BcnJheShcbiAgICAgICAgQXJyYXkuZnJvbShoZWFkTWFuYWdlci5tb3VudGVkSW5zdGFuY2VzIGFzIFNldDxSZWFjdC5SZWFjdE5vZGU+KS5maWx0ZXIoXG4gICAgICAgICAgQm9vbGVhblxuICAgICAgICApXG4gICAgICApIGFzIFJlYWN0LlJlYWN0RWxlbWVudFtdXG4gICAgICBoZWFkTWFuYWdlci51cGRhdGVIZWFkKHJlZHVjZUNvbXBvbmVudHNUb1N0YXRlKGhlYWRFbGVtZW50cywgcHJvcHMpKVxuICAgIH1cbiAgfVxuXG4gIGlmIChpc1NlcnZlcikge1xuICAgIGhlYWRNYW5hZ2VyPy5tb3VudGVkSW5zdGFuY2VzPy5hZGQocHJvcHMuY2hpbGRyZW4pXG4gICAgZW1pdENoYW5nZSgpXG4gIH1cblxuICB1c2VDbGllbnRPbmx5TGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBoZWFkTWFuYWdlcj8ubW91bnRlZEluc3RhbmNlcz8uYWRkKHByb3BzLmNoaWxkcmVuKVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBoZWFkTWFuYWdlcj8ubW91bnRlZEluc3RhbmNlcz8uZGVsZXRlKHByb3BzLmNoaWxkcmVuKVxuICAgIH1cbiAgfSlcblxuICAvLyBXZSBuZWVkIHRvIGNhbGwgYHVwZGF0ZUhlYWRgIG1ldGhvZCB3aGVuZXZlciB0aGUgYFNpZGVFZmZlY3RgIGlzIHRyaWdnZXIgaW4gYWxsXG4gIC8vIGxpZmUtY3ljbGVzOiBtb3VudCwgdXBkYXRlLCB1bm1vdW50LiBIb3dldmVyLCBpZiB0aGVyZSBhcmUgbXVsdGlwbGUgYFNpZGVFZmZlY3Rgc1xuICAvLyBiZWluZyByZW5kZXJlZCwgd2Ugb25seSB0cmlnZ2VyIHRoZSBtZXRob2QgZnJvbSB0aGUgbGFzdCBvbmUuXG4gIC8vIFRoaXMgaXMgZW5zdXJlZCBieSBrZWVwaW5nIHRoZSBsYXN0IHVuZmx1c2hlZCBgdXBkYXRlSGVhZGAgaW4gdGhlIGBfcGVuZGluZ1VwZGF0ZWBcbiAgLy8gc2luZ2xldG9uIGluIHRoZSBsYXlvdXQgZWZmZWN0IHBhc3MsIGFuZCBhY3R1YWxseSB0cmlnZ2VyIGl0IGluIHRoZSBlZmZlY3QgcGFzcy5cbiAgdXNlQ2xpZW50T25seUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGhlYWRNYW5hZ2VyKSB7XG4gICAgICBoZWFkTWFuYWdlci5fcGVuZGluZ1VwZGF0ZSA9IGVtaXRDaGFuZ2VcbiAgICB9XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlmIChoZWFkTWFuYWdlcikge1xuICAgICAgICBoZWFkTWFuYWdlci5fcGVuZGluZ1VwZGF0ZSA9IGVtaXRDaGFuZ2VcbiAgICAgIH1cbiAgICB9XG4gIH0pXG5cbiAgdXNlQ2xpZW50T25seUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGhlYWRNYW5hZ2VyICYmIGhlYWRNYW5hZ2VyLl9wZW5kaW5nVXBkYXRlKSB7XG4gICAgICBoZWFkTWFuYWdlci5fcGVuZGluZ1VwZGF0ZSgpXG4gICAgICBoZWFkTWFuYWdlci5fcGVuZGluZ1VwZGF0ZSA9IG51bGxcbiAgICB9XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlmIChoZWFkTWFuYWdlciAmJiBoZWFkTWFuYWdlci5fcGVuZGluZ1VwZGF0ZSkge1xuICAgICAgICBoZWFkTWFuYWdlci5fcGVuZGluZ1VwZGF0ZSgpXG4gICAgICAgIGhlYWRNYW5hZ2VyLl9wZW5kaW5nVXBkYXRlID0gbnVsbFxuICAgICAgfVxuICAgIH1cbiAgfSlcblxuICByZXR1cm4gbnVsbFxufVxuIl0sIm5hbWVzIjpbIlNpZGVFZmZlY3QiLCJpc1NlcnZlciIsIndpbmRvdyIsInVzZUNsaWVudE9ubHlMYXlvdXRFZmZlY3QiLCJ1c2VMYXlvdXRFZmZlY3QiLCJ1c2VDbGllbnRPbmx5RWZmZWN0IiwidXNlRWZmZWN0IiwicHJvcHMiLCJoZWFkTWFuYWdlciIsInJlZHVjZUNvbXBvbmVudHNUb1N0YXRlIiwiZW1pdENoYW5nZSIsIm1vdW50ZWRJbnN0YW5jZXMiLCJoZWFkRWxlbWVudHMiLCJDaGlsZHJlbiIsInRvQXJyYXkiLCJBcnJheSIsImZyb20iLCJmaWx0ZXIiLCJCb29sZWFuIiwidXBkYXRlSGVhZCIsImFkZCIsImNoaWxkcmVuIiwiZGVsZXRlIiwiX3BlbmRpbmdVcGRhdGUiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/side-effect.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/app/multi/page.tsx":
/*!********************************!*\
  !*** ./src/app/multi/page.tsx ***!
  \********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ MultiPage)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var next_navigation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/navigation */ \"(app-pages-browser)/./node_modules/next/dist/api/navigation.js\");\n/* harmony import */ var next_image__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! next/image */ \"(app-pages-browser)/./node_modules/next/dist/api/image.js\");\n/* harmony import */ var _services_AI__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/services/AI */ \"(app-pages-browser)/./src/services/AI.ts\");\n/* harmony import */ var _components_TypewriterTextWrapper__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @/components/TypewriterTextWrapper */ \"(app-pages-browser)/./src/components/TypewriterTextWrapper.tsx\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\n\n\nfunction MultiPage() {\n    _s();\n    const router = (0,next_navigation__WEBPACK_IMPORTED_MODULE_2__.useRouter)();\n    // State management\n    const [messages, setMessages] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [completedMessageIds, setCompletedMessageIds] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [scratchboardContent, setScratchboardContent] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"\");\n    const [input, setInput] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"\");\n    const [finalAnswer, setFinalAnswer] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"\");\n    const [nextMessageId, setNextMessageId] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(3);\n    const [typingMessageIds, setTypingMessageIds] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [isQuestioningEnabled, setIsQuestioningEnabled] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    const [evaluationComplete, setEvaluationComplete] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [botThinking, setBotThinking] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [userHasScrolled, setUserHasScrolled] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const chatContainerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const [currentModel] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(_services_AI__WEBPACK_IMPORTED_MODULE_4__.AI_MODELS.CLAUDE_HAIKU.id);\n    const [lastUserActivityTime, setLastUserActivityTime] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(Date.now());\n    // Questions from JSON\n    const [allQuestions, setAllQuestions] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [loadedQuestions, setLoadedQuestions] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    // Timer state\n    const [timeLeft, setTimeLeft] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(120);\n    const roundEndedRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n    // Question tracking\n    const [currentQuestionIndex, setCurrentQuestionIndex] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);\n    const [usedQuestionIndices, setUsedQuestionIndices] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [currentQuestion, setCurrentQuestion] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    // Define the AI agents - only Logic Bot and Pattern Bot\n    const agents = [\n        {\n            id: 'bob',\n            name: 'Bob',\n            avatar: 'bob_avatar.svg',\n            systemPrompt: \"You are Bob, an experienced and encouraging math teacher guiding a classroom discussion.\\nWhen introducing problems, provide clear context and relevant background concepts.\\nGuide discussions without giving away solutions.\\nBe concise and direct in your responses.\\nYour goal is to facilitate learning through guided discovery.\"\n        },\n        {\n            id: 'logic',\n            name: 'Logic Bot',\n            avatar: 'logic_avatar.png',\n            systemPrompt: \"You are Logic Bot, a student who excels at logical thinking and step-by-step problem solving.\\nAsk at most ONE clarifying question per problem.\\nKeep your responses brief and focused on the key logical steps.\\nYou struggle with pattern recognition and need help with those aspects.\"\n        },\n        {\n            id: 'pattern',\n            name: 'Pattern Bot',\n            avatar: 'pattern_avatar.png',\n            systemPrompt: \"You are Pattern Bot, a student who excels at recognizing patterns and making connections.\\nAsk at most ONE question per problem, focusing on patterns or relationships.\\nKeep your responses concise and to the point.\\nYou struggle with formal logic and step-by-step problem solving.\"\n        }\n    ];\n    // Add a tracker for bot questions\n    const [botQuestionCounts, setBotQuestionCounts] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        logic: 0,\n        pattern: 0\n    });\n    // Load questions from JSON file\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"MultiPage.useEffect\": ()=>{\n            const fetchQuestions = {\n                \"MultiPage.useEffect.fetchQuestions\": async ()=>{\n                    try {\n                        const response = await fetch('/questions.json');\n                        if (!response.ok) {\n                            throw new Error('Failed to fetch questions');\n                        }\n                        const data = await response.json();\n                        // Flatten all categories into a single array of questions\n                        const questions = Object.values(data).flat();\n                        setAllQuestions(questions);\n                        setLoadedQuestions(true);\n                        console.log(\"Loaded questions:\", questions);\n                    } catch (error) {\n                        console.error(\"Error loading questions:\", error);\n                        // Use fallback questions if we can't load from JSON\n                        setAllQuestions([\n                            \"In how many ways can four couples be seated at a round table if the men and women want to sit alternately?\",\n                            \"In how many different ways can five people be seated at a circular table?\",\n                            \"A shopping mall has a straight row of 5 flagpoles at its main entrance plaza. It has 3 identical green flags and 2 identical yellow flags. How many distinct arrangements of flags on the flagpoles are possible?\"\n                        ]);\n                        setLoadedQuestions(true);\n                    }\n                }\n            }[\"MultiPage.useEffect.fetchQuestions\"];\n            fetchQuestions();\n        }\n    }[\"MultiPage.useEffect\"], []);\n    // Add this at the top of your component with other state declarations\n    const nextMessageIdRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(3); // Start at 3 to match your initial state\n    // Replace your existing getUniqueMessageId function with this:\n    const getUniqueMessageId = ()=>{\n        const id = nextMessageIdRef.current;\n        nextMessageIdRef.current += 1;\n        // Keep the state in sync for display purposes only (not for generating IDs)\n        setNextMessageId(nextMessageIdRef.current);\n        return id;\n    };\n    // Add this helper function to use throughout your code\n    const ensureNoTypingInProgress = function(callback) {\n        let maxDelay = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 10000;\n        const startTime = Date.now();\n        const tryCallback = ()=>{\n            // Safety timeout to prevent infinite waiting\n            if (Date.now() - startTime > maxDelay) {\n                console.warn('Timeout waiting for typing to complete, proceeding anyway');\n                callback();\n                return;\n            }\n            if (typingMessageIds.length > 0) {\n                console.log(\"Messages still typing: \".concat(typingMessageIds.join(', '), \", delaying action\"));\n                setTimeout(tryCallback, 800);\n                return;\n            }\n            // No typing in progress, safe to proceed\n            console.log('No typing in progress, proceeding with action');\n            callback();\n        };\n        tryCallback();\n    };\n    // Add a new ref to track manual scroll state for the current message\n    const currentMessageScrollOverrideRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n    // Add a ref to track the last manual scroll time\n    const lastManualScrollTimeRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(0);\n    // Add a ref to track if we should force scroll on next render\n    const forceScrollToBottomRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n    // Add a ref to specifically track manual scroll override during generation\n    const manualScrollOverrideRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n    // Improve the scrollToBottom function to respect manual override\n    const scrollToBottom = function() {\n        let force = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;\n        const chatContainer = chatContainerRef.current;\n        if (!chatContainer) return;\n        // Never scroll if manual override is active, except for forced user messages\n        if (manualScrollOverrideRef.current && !force) {\n            return;\n        }\n        // Always scroll if force is true (used for user messages) or auto-scroll is active\n        if (force || forceScrollToBottomRef.current || !userHasScrolled) {\n            chatContainer.scrollTop = chatContainer.scrollHeight;\n            // Reset force flag after using it\n            forceScrollToBottomRef.current = false;\n        }\n    };\n    // Update the scroll handler to immediately set manual override\n    const handleScroll = ()=>{\n        const chatContainer = chatContainerRef.current;\n        if (!chatContainer) return;\n        // Check if this is a programmatic scroll (very recent auto-scroll)\n        const isProgrammaticScroll = Date.now() - lastManualScrollTimeRef.current < 50;\n        if (isProgrammaticScroll) {\n            // Ignore programmatic scrolls\n            return;\n        }\n        // More generous threshold - user only needs to scroll a small amount\n        const isNearBottom = Math.abs(chatContainer.scrollHeight - chatContainer.scrollTop - chatContainer.clientHeight) < 150;\n        // If user scrolls up even slightly, set manual override\n        if (!isNearBottom) {\n            // Update regular scroll state\n            setUserHasScrolled(true);\n            // Set manual override that persists during generation\n            manualScrollOverrideRef.current = true;\n            console.log(\"Manual scroll detected - autoscroll disabled\");\n        } else {\n            // If user scrolls back to bottom, they want to follow the conversation again\n            setUserHasScrolled(false);\n            manualScrollOverrideRef.current = false;\n        }\n    };\n    // Update the message change effect to reset manual override only for new messages\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"MultiPage.useEffect\": ()=>{\n            // Only reset manual override if the new message is from user\n            // This way, generated text won't reset the override\n            const latestMessage = messages[messages.length - 1];\n            if (latestMessage && latestMessage.sender === 'user') {\n                // User sent a new message, reset the override\n                manualScrollOverrideRef.current = false;\n                // Record the time of auto-scroll to avoid false detection\n                const scrollTime = Date.now();\n                lastManualScrollTimeRef.current = scrollTime;\n                // Force scroll to bottom for user messages\n                setTimeout({\n                    \"MultiPage.useEffect\": ()=>{\n                        scrollToBottom(true);\n                    }\n                }[\"MultiPage.useEffect\"], 50);\n            }\n        }\n    }[\"MultiPage.useEffect\"], [\n        messages.length\n    ]);\n    // Helper for formatting time\n    const formatTime = (seconds)=>{\n        const mins = Math.floor(seconds / 60);\n        const secs = seconds % 60;\n        return \"\".concat(mins, \":\").concat(secs < 10 ? '0' : '').concat(secs);\n    };\n    // Check if a specific bot is mentioned in the message\n    const checkForBotMention = (message)=>{\n        const bobMentioned = message.includes('bob') || message.includes('teacher');\n        const logicMentioned = message.includes('logic') || message.includes('logic bot');\n        const patternMentioned = message.includes('pattern') || message.includes('pattern bot');\n        if (bobMentioned) return 'bob';\n        if (logicMentioned) return 'logic';\n        if (patternMentioned) return 'pattern';\n        return null;\n    };\n    // Update the autoSubmitTimeoutAnswer function to include showing the official solution\n    const autoSubmitTimeoutAnswer = ()=>{\n        console.log(\"Auto-submitting answer due to timeout\");\n        // Disable further questioning\n        setIsQuestioningEnabled(false);\n        roundEndedRef.current = true;\n        // Only auto-submit if user has written something in the scratchboard\n        const submissionText = finalAnswer.trim() || \"No answer.\";\n        ensureNoTypingInProgress(()=>{\n            const userFinalAnswer = {\n                id: getUniqueMessageId(),\n                sender: 'user',\n                text: \"My final answer is: \".concat(submissionText, \"\\n\\nMy reasoning:\\n\").concat(scratchboardContent),\n                timestamp: new Date().toISOString()\n            };\n            setMessages((prev)=>[\n                    ...prev,\n                    userFinalAnswer\n                ]);\n            setFinalAnswer('');\n            // Generate evaluation\n            generateEvaluation(userFinalAnswer.text || \"\", currentQuestion);\n        });\n    };\n    // Add a new function to generate and display the official solution\n    const generateOfficialSolution = async (question)=>{\n        console.log(\"Generating official solution\");\n        // Add system message about time expiring\n        const timeoutMessageId = getUniqueMessageId();\n        setMessages((prev)=>[\n                ...prev,\n                {\n                    id: timeoutMessageId,\n                    sender: 'system',\n                    text: 'Time has expired. Here is the official solution:',\n                    timestamp: new Date().toISOString()\n                }\n            ]);\n        // Add a typing indicator for the solution\n        const solutionMessageId = getUniqueMessageId();\n        setMessages((prev)=>[\n                ...prev,\n                {\n                    id: solutionMessageId,\n                    sender: 'system',\n                    text: '...',\n                    timestamp: new Date().toISOString()\n                }\n            ]);\n        // Add to typing state\n        setTypingMessageIds((prev)=>[\n                ...prev,\n                solutionMessageId\n            ]);\n        try {\n            // Generate solution using AI\n            const solutionPrompt = \"You are an expert math teacher providing the official solution to a problem.\";\n            const response = await _services_AI__WEBPACK_IMPORTED_MODULE_4__.aiService.generateResponse([\n                {\n                    id: 1,\n                    sender: 'user',\n                    text: \"Problem: \".concat(question, \"\\n\\nPlease provide:\\n1. A clear, step-by-step solution\\n2. The final correct answer\\n3. Key concepts and techniques used in solving this problem\\n\\nFormat your response in a structured way that shows the complete solution process.\")\n                }\n            ], {\n                systemPrompt: solutionPrompt,\n                model: currentModel\n            });\n            // Replace typing indicator with actual solution\n            setMessages((prev)=>prev.map((msg)=>msg.id === solutionMessageId ? {\n                        ...msg,\n                        text: response,\n                        timestamp: new Date().toISOString()\n                    } : msg));\n            // Add to typing state for animation\n            setTypingMessageIds((prev)=>[\n                    ...prev,\n                    solutionMessageId\n                ]);\n            // Set evaluation as complete to enable the \"Next Question\" button\n            setEvaluationComplete(true);\n        } catch (error) {\n            console.error(\"Error generating official solution:\", error);\n            // Provide a fallback message\n            setMessages((prev)=>prev.map((msg)=>msg.id === solutionMessageId ? {\n                        ...msg,\n                        text: \"Sorry, I couldn't generate the official solution. Please proceed to the next question.\",\n                        timestamp: new Date().toISOString()\n                    } : msg));\n            setEvaluationComplete(true);\n        }\n    };\n    // Modify the timer useEffect to trigger the auto-submit\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"MultiPage.useEffect\": ()=>{\n            if (timeLeft <= 0) {\n                // Time's up logic\n                if (isQuestioningEnabled) {\n                    // Only auto-submit if questioning is still enabled (hasn't been submitted yet)\n                    autoSubmitTimeoutAnswer();\n                }\n                return;\n            }\n            if (roundEndedRef.current) {\n                return;\n            }\n            const timerId = setTimeout({\n                \"MultiPage.useEffect.timerId\": ()=>{\n                    setTimeLeft({\n                        \"MultiPage.useEffect.timerId\": (prevTime)=>prevTime - 1\n                    }[\"MultiPage.useEffect.timerId\"]);\n                }\n            }[\"MultiPage.useEffect.timerId\"], 1000);\n            return ({\n                \"MultiPage.useEffect\": ()=>clearTimeout(timerId)\n            })[\"MultiPage.useEffect\"];\n        }\n    }[\"MultiPage.useEffect\"], [\n        timeLeft\n    ]);\n    // Auto-scroll when messages change\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"MultiPage.useEffect\": ()=>{\n            // Set a short timeout to ensure the DOM has updated\n            setTimeout(scrollToBottom, 50);\n            // Reset the userHasScrolled flag when a new message is added\n            setUserHasScrolled(false);\n        }\n    }[\"MultiPage.useEffect\"], [\n        messages.length\n    ]);\n    // Handler for user question\n    const handleUserQuestion = ()=>{\n        if (!input.trim() || typingMessageIds.length > 0) return;\n        // Record user activity\n        setLastUserActivityTime(Date.now());\n        const userMessage = {\n            id: getUniqueMessageId(),\n            sender: 'user',\n            text: input,\n            timestamp: new Date().toISOString()\n        };\n        setMessages((prev)=>[\n                ...prev,\n                userMessage\n            ]);\n        setInput('');\n        // Force scroll to bottom when user sends a message\n        forceScrollToBottomRef.current = true;\n        setTimeout(()=>scrollToBottom(true), 50);\n        // Check if a specific bot was mentioned\n        const mentionedBot = checkForBotMention(userMessage.text || \"\");\n        // Generate AI responses based on which bot was mentioned\n        generateAIResponse(userMessage.text || \"\", mentionedBot);\n    };\n    // Handle submit/evaluation\n    const handleSend = ()=>{\n        if (!finalAnswer.trim() || !scratchboardContent.trim() || typingMessageIds.length > 0) return;\n        // Record user activity\n        setLastUserActivityTime(Date.now());\n        ensureNoTypingInProgress(()=>{\n            const userFinalAnswer = {\n                id: getUniqueMessageId(),\n                sender: 'user',\n                text: \"My final answer is: \".concat(finalAnswer, \"\\n\\nMy reasoning:\\n\").concat(scratchboardContent),\n                timestamp: new Date().toISOString()\n            };\n            setMessages((prev)=>[\n                    ...prev,\n                    userFinalAnswer\n                ]);\n            setFinalAnswer('');\n            // Force scroll to bottom when user submits final answer\n            forceScrollToBottomRef.current = true;\n            setTimeout(()=>scrollToBottom(true), 50);\n            // Don't clear scratchboard to allow review\n            // Disable further questioning\n            setIsQuestioningEnabled(false);\n            roundEndedRef.current = true;\n            // Generate evaluation\n            generateEvaluation(userFinalAnswer.text || \"\", currentQuestion);\n        });\n    };\n    // AI response generation\n    const generateAIResponse = async (userMessage, mentionedBot)=>{\n        // Don't generate responses if time's up\n        if (roundEndedRef.current) return;\n        // Determine which bot(s) should respond\n        let selectedAgentIndex;\n        if (mentionedBot === 'bob') {\n            // Teacher Bob should respond\n            selectedAgentIndex = 0; // Assuming Bob is the first agent now\n        } else if (mentionedBot === 'logic') {\n            // Only Logic Bot should respond\n            selectedAgentIndex = 1; // Logic Bot is now second\n        } else if (mentionedBot === 'pattern') {\n            // Only Pattern Bot should respond\n            selectedAgentIndex = 2; // Pattern Bot is now third\n        } else {\n            // Default to Bob if no specific mention\n            selectedAgentIndex = 0;\n        }\n        const selectedAgent = agents[selectedAgentIndex];\n        console.log(\"Generating response from \".concat(selectedAgent.name));\n        setBotThinking(true);\n        try {\n            // Show typing indicator temporarily\n            const tempMessageId = getUniqueMessageId();\n            setMessages((prev)=>[\n                    ...prev,\n                    {\n                        id: tempMessageId,\n                        sender: 'ai',\n                        text: '...',\n                        agentId: selectedAgent.id,\n                        timestamp: new Date().toISOString()\n                    }\n                ]);\n            // Generate AI response using the correct API call\n            const response = await _services_AI__WEBPACK_IMPORTED_MODULE_4__.aiService.generateResponse([\n                {\n                    id: 1,\n                    sender: 'user',\n                    text: \"The current problem is: \".concat(currentQuestion)\n                },\n                {\n                    id: 2,\n                    sender: 'user',\n                    text: \"The student asked: \".concat(userMessage)\n                }\n            ], {\n                systemPrompt: selectedAgent.systemPrompt,\n                model: currentModel\n            });\n            // Replace typing indicator with actual message\n            setMessages((prev)=>prev.map((msg)=>msg.id === tempMessageId ? {\n                        ...msg,\n                        text: response,\n                        timestamp: new Date().toISOString()\n                    } : msg));\n            // Add to typing state\n            setTypingMessageIds((prev)=>[\n                    ...prev,\n                    tempMessageId\n                ]);\n            // Check if the other agent should also respond\n            // Only if both bots were mentioned or no specific bot was mentioned\n            if ((mentionedBot === 'both' || mentionedBot === null) && Math.random() < 0.3) {\n                const otherAgentIndex = 1 - selectedAgentIndex;\n                const otherAgent = agents[otherAgentIndex];\n                // Wait a bit before second agent responds\n                setTimeout(()=>{\n                    generateFollowUpResponse(otherAgent, userMessage, response);\n                }, 1000);\n            }\n        } catch (error) {\n            console.error(\"Error generating AI response:\", error);\n            setMessages((prev)=>prev.filter((msg)=>msg.text !== '...'));\n        } finally{\n            setBotThinking(false);\n        }\n    };\n    // Follow-up response generation\n    const generateFollowUpResponse = async (agent, userMessage, firstAgentResponse)=>{\n        // Don't generate responses if time's up\n        if (roundEndedRef.current) return;\n        console.log(\"Generating follow-up from \".concat(agent.name));\n        setBotThinking(true);\n        try {\n            // Show typing indicator temporarily\n            const tempMessageId = getUniqueMessageId();\n            setMessages((prev)=>[\n                    ...prev,\n                    {\n                        id: tempMessageId,\n                        sender: 'ai',\n                        text: '...',\n                        agentId: agent.id,\n                        timestamp: new Date().toISOString()\n                    }\n                ]);\n            // Generate AI response using the correct API call\n            const response = await _services_AI__WEBPACK_IMPORTED_MODULE_4__.aiService.generateResponse([\n                {\n                    id: 1,\n                    sender: 'user',\n                    text: \"The current problem is: \".concat(currentQuestion)\n                },\n                {\n                    id: 2,\n                    sender: 'user',\n                    text: \"The student asked: \".concat(userMessage)\n                },\n                {\n                    id: 3,\n                    sender: 'user',\n                    text: \"The other AI student responded: \".concat(firstAgentResponse)\n                },\n                {\n                    id: 4,\n                    sender: 'user',\n                    text: 'Provide your perspective on this problem, possibly building on what the other student said or offering an alternative approach. Keep it conversational and helpful.'\n                }\n            ], {\n                systemPrompt: agent.systemPrompt,\n                model: currentModel\n            });\n            // Replace typing indicator with actual message\n            setMessages((prev)=>prev.map((msg)=>msg.id === tempMessageId ? {\n                        ...msg,\n                        text: response,\n                        timestamp: new Date().toISOString()\n                    } : msg));\n            // Add to typing state\n            setTypingMessageIds((prev)=>[\n                    ...prev,\n                    tempMessageId\n                ]);\n        } catch (error) {\n            console.error(\"Error generating follow-up response:\", error);\n            setMessages((prev)=>prev.filter((msg)=>msg.text !== '...'));\n        } finally{\n            setBotThinking(false);\n        }\n    };\n    // Update generateAIStudentFinalAnswers to return the answers\n    const generateAIStudentFinalAnswers = async (question)=>{\n        // Return the final answers for later use\n        return new Promise(async (resolve)=>{\n            // Generate Logic Bot's final answer first\n            const logicMessageId = getUniqueMessageId();\n            // Add Logic Bot's message with typing indicator\n            setMessages((prev)=>[\n                    ...prev,\n                    {\n                        id: logicMessageId,\n                        sender: \"ai\",\n                        text: \"I'm working on my final answer...\",\n                        agentId: \"logic\",\n                        timestamp: new Date().toISOString()\n                    }\n                ]);\n            try {\n                // Generate Logic Bot's final answer with a clear prompt\n                const logicResponse = await _services_AI__WEBPACK_IMPORTED_MODULE_4__.aiService.generateResponse([\n                    {\n                        id: 1,\n                        sender: \"user\",\n                        text: \"Problem: \".concat(question, '\\n\\nThe teacher has asked for final answers. As Logic Bot, provide your FINAL ANSWER to this problem. Include your solution approach and reasoning. Start with \"My final answer is:\" followed by your solution. This is NOT a question or comment.')\n                    }\n                ], {\n                    systemPrompt: agents[1].systemPrompt,\n                    model: currentModel\n                });\n                // Make sure the response starts with \"My final answer is:\"\n                const formattedLogicResponse = logicResponse.startsWith(\"My final answer is:\") ? logicResponse : \"My final answer is:\\n\\n\".concat(logicResponse);\n                // Store logic answer for return value\n                const logicFinalAnswer = formattedLogicResponse;\n                // Update message with response\n                setMessages((prev)=>prev.map((msg)=>msg.id === logicMessageId ? {\n                            ...msg,\n                            text: formattedLogicResponse,\n                            timestamp: new Date().toISOString(),\n                            onComplete: ()=>{\n                                console.log(\"Logic Bot's final answer typed completely\");\n                                // Create a timeout to show Pattern Bot's message after Logic Bot finishes\n                                setTimeout(async ()=>{\n                                    // Generate Pattern Bot's final answer\n                                    const patternMessageId = getUniqueMessageId();\n                                    // Add Pattern Bot's message with typing indicator\n                                    setMessages((prev)=>[\n                                            ...prev,\n                                            {\n                                                id: patternMessageId,\n                                                sender: \"ai\",\n                                                text: \"I'm finalizing my solution...\",\n                                                agentId: \"pattern\",\n                                                timestamp: new Date().toISOString()\n                                            }\n                                        ]);\n                                    try {\n                                        // Generate Pattern Bot's answer with a clear prompt\n                                        const patternResponse = await _services_AI__WEBPACK_IMPORTED_MODULE_4__.aiService.generateResponse([\n                                            {\n                                                id: 1,\n                                                sender: \"user\",\n                                                text: \"Problem: \".concat(question, '\\n\\nThe teacher has asked for final answers. As Pattern Bot, provide your FINAL ANSWER to this problem. Include your solution approach and reasoning. Start with \"My final answer is:\" followed by your solution. This is NOT a question or comment.')\n                                            }\n                                        ], {\n                                            systemPrompt: agents[2].systemPrompt,\n                                            model: currentModel\n                                        });\n                                        // Make sure the response starts with \"My final answer is:\"\n                                        const formattedPatternResponse = patternResponse.startsWith(\"My final answer is:\") ? patternResponse : \"My final answer is:\\n\\n\".concat(patternResponse);\n                                        // Store pattern answer for return value\n                                        const patternFinalAnswer = formattedPatternResponse;\n                                        // Update message with response\n                                        setMessages((prev)=>prev.map((msg)=>msg.id === patternMessageId ? {\n                                                    ...msg,\n                                                    text: formattedPatternResponse,\n                                                    timestamp: new Date().toISOString(),\n                                                    onComplete: ()=>{\n                                                        console.log(\"Pattern Bot's final answer typed completely\");\n                                                        // All done, resolve the promise with both answers\n                                                        setTimeout(()=>{\n                                                            resolve({\n                                                                logicAnswer: logicFinalAnswer,\n                                                                patternAnswer: patternFinalAnswer\n                                                            });\n                                                        }, 1000);\n                                                    }\n                                                } : msg));\n                                        // Add to typing state for typewriter effect\n                                        setTypingMessageIds((prev)=>[\n                                                ...prev,\n                                                patternMessageId\n                                            ]);\n                                    } catch (error) {\n                                        console.error(\"Error generating Pattern Bot final answer:\", error);\n                                        resolve({\n                                            logicAnswer: logicFinalAnswer,\n                                            patternAnswer: \"Pattern Bot was unable to provide a final answer.\"\n                                        });\n                                    }\n                                }, 2000); // Wait 2 seconds after Logic Bot finishes\n                            }\n                        } : msg));\n                // Add to typing state for typewriter effect\n                setTypingMessageIds((prev)=>[\n                        ...prev,\n                        logicMessageId\n                    ]);\n            } catch (error) {\n                console.error(\"Error generating Logic Bot final answer:\", error);\n                resolve({\n                    logicAnswer: \"Logic Bot was unable to provide a final answer.\",\n                    patternAnswer: \"Pattern Bot was unable to provide a final answer.\"\n                });\n            }\n        });\n    };\n    // Update generateEvaluation to use the returned answers directly\n    const generateEvaluation = async (finalAnswer, question)=>{\n        console.log(\"Generating evaluation\");\n        setBotThinking(true);\n        try {\n            // Add system message about evaluation\n            const tempMessageId = getUniqueMessageId();\n            setMessages((prev)=>[\n                    ...prev,\n                    {\n                        id: tempMessageId,\n                        sender: 'system',\n                        text: 'Bob is asking students for their final answers...',\n                        timestamp: new Date().toISOString()\n                    }\n                ]);\n            // Get AI students' final answers and WAIT for them to complete\n            // Now we directly get the answers from the function\n            const { logicAnswer, patternAnswer } = await generateAIStudentFinalAnswers(question);\n            console.log(\"Got final answers:\", {\n                logicAnswer,\n                patternAnswer\n            });\n            // Update the system message\n            setMessages((prev)=>prev.map((msg)=>msg.id === tempMessageId ? {\n                        ...msg,\n                        text: 'Bob is evaluating all the answers...',\n                        timestamp: new Date().toISOString()\n                    } : msg));\n            // Once AI students have submitted answers, generate Bob's evaluation\n            const bobMessageId = getUniqueMessageId();\n            setMessages((prev)=>[\n                    ...prev,\n                    {\n                        id: bobMessageId,\n                        sender: \"ai\",\n                        text: \"...\",\n                        agentId: \"bob\",\n                        timestamp: new Date().toISOString()\n                    }\n                ]);\n            // Generate Bob's evaluation of all answers - using the answers we got directly\n            const response = await _services_AI__WEBPACK_IMPORTED_MODULE_4__.aiService.generateResponse([\n                {\n                    id: 1,\n                    sender: \"user\",\n                    text: \"Problem: \".concat(question, \"\\n                        \\nStudent's final answer: \").concat(finalAnswer, \"\\n\\nLogic Bot's final answer: \").concat(logicAnswer, \"\\n\\nPattern Bot's final answer: \").concat(patternAnswer, \"\\n\\nAs Bob the teacher, provide:\\n1. The correct solution to this problem\\n2. An evaluation of all three answers, highlighting strengths and areas for improvement in each\\n3. Key learning points from this problem\\n\\nFormat your response in a clear, encouraging way as a teacher would.\")\n                }\n            ], {\n                systemPrompt: agents[0].systemPrompt,\n                model: currentModel\n            });\n            // Remove the system message\n            setMessages((prev)=>prev.filter((msg)=>msg.id !== tempMessageId));\n            // Update Bob's evaluation message\n            setMessages((prev)=>prev.map((msg)=>msg.id === bobMessageId ? {\n                        ...msg,\n                        text: response,\n                        timestamp: new Date().toISOString()\n                    } : msg));\n            // Add to typing state for typewriter effect\n            setTypingMessageIds((prev)=>[\n                    ...prev,\n                    bobMessageId\n                ]);\n            setEvaluationComplete(true);\n        } catch (error) {\n            console.error(\"Error generating evaluation:\", error);\n        // Handle error\n        } finally{\n            setBotThinking(false);\n        }\n    };\n    // Add a new state to track which bot spoke last\n    const [lastSpeakingBot, setLastSpeakingBot] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    // Add a global reference to track pending bot interactions\n    const pendingBotInteractionsRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)([]);\n    // Update startNewRound to use the completedMessageIds for sequencing\n    const startNewRound = async ()=>{\n        // Reset tracking of who spoke last\n        setLastSpeakingBot(null);\n        // Wait for questions to load if they haven't yet\n        if (!loadedQuestions) {\n            console.log(\"Waiting for questions to load...\");\n            setTimeout(startNewRound, 500);\n            return;\n        }\n        // Check if we've used all questions and should go to the test screen\n        if (usedQuestionIndices.length >= allQuestions.length) {\n            console.log(\"All questions used, redirecting to test screen\");\n            router.push('/break');\n            return;\n        }\n        // Reset state for new round\n        console.log(\"Starting new round\");\n        setMessages([]);\n        setCompletedMessageIds([]);\n        setTypingMessageIds([]);\n        setEvaluationComplete(false);\n        setScratchboardContent(\"\");\n        setInput(\"\");\n        setFinalAnswer(\"\");\n        setUserHasScrolled(false);\n        try {\n            // Find an unused question\n            let newIndex = currentQuestionIndex;\n            while(usedQuestionIndices.includes(newIndex) && usedQuestionIndices.length < allQuestions.length){\n                newIndex = Math.floor(Math.random() * allQuestions.length);\n            }\n            setCurrentQuestionIndex(newIndex);\n            setUsedQuestionIndices((prev)=>[\n                    ...prev,\n                    newIndex\n                ]);\n            const selectedQuestion = allQuestions[newIndex];\n            setCurrentQuestion(selectedQuestion);\n            // Clear any pending interactions from previous round\n            pendingBotInteractionsRef.current = [];\n            // Set up messages for the new round with Bob introducing the problem\n            const bobIntroId = getUniqueMessageId();\n            // Create a message object with an onComplete callback\n            const bobIntroMessage = {\n                id: bobIntroId,\n                sender: \"ai\",\n                text: \"Today we'll be working on an interesting problem. Take your time to understand it and think about your approach:\\n\\n\".concat(selectedQuestion, \"\\n\\nConsider what concepts might apply here. Feel free to ask questions as you work.\"),\n                agentId: \"bob\",\n                timestamp: new Date().toISOString(),\n                onComplete: ()=>{\n                    console.log(\"Bob's intro completed, triggering Logic Bot\");\n                    // When Bob's intro is done typing, trigger Logic Bot\n                    setTimeout(()=>{\n                        generateAIStudentComment(\"logic\", selectedQuestion);\n                    }, 2000); // Short pause after typing completes\n                }\n            };\n            setMessages([\n                bobIntroMessage\n            ]);\n            setTypingMessageIds((prev)=>[\n                    ...prev,\n                    bobIntroId\n                ]);\n            // Reset timer and other state\n            setTimeLeft(120);\n            setIsQuestioningEnabled(true);\n            roundEndedRef.current = false;\n            // After Bob introduces the problem, set him as the last speaker\n            setLastSpeakingBot(\"bob\");\n            // Reset bot question counts\n            setBotQuestionCounts({\n                logic: 0,\n                pattern: 0\n            });\n        } catch (error) {\n            console.error(\"Error starting new round:\", error);\n            // Use a fallback question\n            const fallbackQuestion = \"In how many ways can 5 distinct books be distributed to 3 distinct students such that each student gets at least one book?\";\n            setCurrentQuestion(fallbackQuestion);\n            setMessages([\n                {\n                    id: 1,\n                    sender: \"ai\",\n                    text: \"There was an issue loading questions from the server, but I have a combinatorics problem for us to work on.\",\n                    agentId: \"logic\"\n                },\n                {\n                    id: 2,\n                    sender: \"ai\",\n                    text: fallbackQuestion,\n                    agentId: \"logic\"\n                }\n            ]);\n            // Continue with the fallback question\n            setTimeLeft(120);\n            setIsQuestioningEnabled(true);\n            roundEndedRef.current = false;\n        }\n    };\n    // Initialize with first question once questions are loaded\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"MultiPage.useEffect\": ()=>{\n            if (loadedQuestions) {\n                startNewRound();\n            }\n        }\n    }[\"MultiPage.useEffect\"], [\n        loadedQuestions\n    ]);\n    // Handle next question button\n    const handleNextQuestion = ()=>{\n        setEvaluationComplete(false);\n        startNewRound();\n    };\n    // Update generateAIStudentComment to fix the issue with Bob not responding\n    const generateAIStudentComment = async (agentId, question)=>{\n        // Don't generate if student already asked enough questions\n        if (agentId === 'logic' && botQuestionCounts.logic >= 1 || agentId === 'pattern' && botQuestionCounts.pattern >= 1) {\n            return;\n        }\n        const agent = agents.find((a)=>a.id === agentId);\n        if (!agent) return;\n        const messageId = getUniqueMessageId();\n        // Add typing indicator first\n        setMessages((prev)=>[\n                ...prev,\n                {\n                    id: messageId,\n                    sender: \"ai\",\n                    text: \"...\",\n                    agentId: agentId,\n                    timestamp: new Date().toISOString()\n                }\n            ]);\n        try {\n            // Generate a brief question or comment about the problem\n            const response = await _services_AI__WEBPACK_IMPORTED_MODULE_4__.aiService.generateResponse([\n                {\n                    id: 1,\n                    sender: \"user\",\n                    text: \"The teacher just presented this problem: \".concat(question, \"\\n\\nAs a student, provide a brief question or observation about this problem. Keep it concise (1-3 sentences) and don't solve it. Ask something insightful or make an observation that shows you're thinking about the problem.\")\n                }\n            ], {\n                systemPrompt: agent.systemPrompt + \"\\nKeep your response under 3 sentences. Be very concise.\",\n                model: currentModel\n            });\n            // Store the response for later use\n            const studentResponseText = response;\n            // Update message with response and add onComplete callback\n            setMessages((prev)=>prev.map((msg)=>msg.id === messageId ? {\n                        ...msg,\n                        text: studentResponseText,\n                        timestamp: new Date().toISOString(),\n                        onComplete: ()=>{\n                            console.log(\"\".concat(agentId, \"'s comment completed, triggering teacher response\"));\n                            // When student's message is done typing, trigger Bob's response\n                            setTimeout(()=>{\n                                generateTeacherResponse(question, studentResponseText, agentId);\n                            }, 2000); // Short pause after typing completes\n                        }\n                    } : msg));\n            // Add to typing state AFTER setting the text\n            setTypingMessageIds((prev)=>[\n                    ...prev,\n                    messageId\n                ]);\n            // Update question count after generating response\n            if (agentId === 'logic') {\n                setBotQuestionCounts((prev)=>({\n                        ...prev,\n                        logic: prev.logic + 1\n                    }));\n            } else if (agentId === 'pattern') {\n                setBotQuestionCounts((prev)=>({\n                        ...prev,\n                        pattern: prev.pattern + 1\n                    }));\n            }\n        } catch (error) {\n            console.error(\"Error generating student comment:\", error);\n        // Handle error\n        }\n    };\n    // Update generateTeacherResponse to ensure proper sequencing\n    const generateTeacherResponse = async (question, studentMessage, studentId)=>{\n        // Don't generate if round ended\n        if (roundEndedRef.current) return;\n        const messageId = getUniqueMessageId();\n        // Add typing indicator with onComplete callback\n        const teacherMessage = {\n            id: messageId,\n            sender: \"ai\",\n            text: \"...\",\n            agentId: \"bob\",\n            timestamp: new Date().toISOString(),\n            onComplete: ()=>{\n                console.log(\"Bob's response completed, maybe triggering next student\");\n                // When Bob's response is done typing, maybe trigger the other student\n                setTimeout(()=>{\n                    // Only continue the conversation 70% of the time\n                    if (Math.random() < 0.7 && !roundEndedRef.current) {\n                        // Choose the other student to respond\n                        const otherStudentId = studentId === \"logic\" ? \"pattern\" : \"logic\";\n                        // Generate a follow-up comment from the other student\n                        generateAIStudentComment(otherStudentId, question);\n                    }\n                }, 2000); // Short pause after typing completes\n            }\n        };\n        setMessages((prev)=>[\n                ...prev,\n                teacherMessage\n            ]);\n        try {\n            var _agents_find, _agents_find1;\n            const studentName = ((_agents_find = agents.find((a)=>a.id === studentId)) === null || _agents_find === void 0 ? void 0 : _agents_find.name) || studentId;\n            // Generate Bob's response to the student\n            const response = await _services_AI__WEBPACK_IMPORTED_MODULE_4__.aiService.generateResponse([\n                {\n                    id: 1,\n                    sender: \"user\",\n                    text: \"Problem: \".concat(question, \"\\n\\n\").concat(studentName, ' asked/commented: \"').concat(studentMessage, '\"\\n\\nAs the teacher, provide a thoughtful but brief response that guides without giving away the solution. Acknowledge good insights or gently redirect if needed.')\n                }\n            ], {\n                systemPrompt: (_agents_find1 = agents.find((a)=>a.id === \"bob\")) === null || _agents_find1 === void 0 ? void 0 : _agents_find1.systemPrompt,\n                model: currentModel\n            });\n            // Update message with response\n            setMessages((prev)=>prev.map((msg)=>msg.id === messageId ? {\n                        ...msg,\n                        text: response,\n                        timestamp: new Date().toISOString()\n                    } : msg));\n            // Add to typing state AFTER setting the text\n            setTypingMessageIds((prev)=>[\n                    ...prev,\n                    messageId\n                ]);\n        } catch (error) {\n            console.error(\"Error generating teacher response:\", error);\n        // Handle error\n        }\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"h-screen bg-gradient-to-b from-[#2D0278] to-[#0A001D] p-4 flex flex-row overflow-hidden\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"w-1/2 pr-2 flex flex-col h-full overflow-hidden\",\n                children: [\n                    currentQuestion && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"bg-white bg-opacity-20 p-4 rounded-md mb-4 border-2 border-purple-400\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"flex justify-between items-start mb-2\",\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                                        className: \"text-xl text-white font-semibold\",\n                                        children: \"Problem:\"\n                                    }, void 0, false, {\n                                        fileName: \"/Users/jonathanvincentius/Documents/UofT/Projects/cowriting-llm-agent/src/app/multi/page.tsx\",\n                                        lineNumber: 1122,\n                                        columnNumber: 29\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        className: \"p-2 rounded-lg \".concat(timeLeft > 20 ? 'bg-green-700' : timeLeft > 10 ? 'bg-yellow-600 animate-pulse' : 'bg-red-700 animate-pulse', \" ml-4\"),\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                className: \"text-xl font-mono text-white\",\n                                                children: formatTime(timeLeft)\n                                            }, void 0, false, {\n                                                fileName: \"/Users/jonathanvincentius/Documents/UofT/Projects/cowriting-llm-agent/src/app/multi/page.tsx\",\n                                                lineNumber: 1129,\n                                                columnNumber: 33\n                                            }, this),\n                                            timeLeft <= 20 && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                className: \"text-xs text-white text-center\",\n                                                children: timeLeft <= 10 ? \"Time almost up!\" : \"Finish soon!\"\n                                            }, void 0, false, {\n                                                fileName: \"/Users/jonathanvincentius/Documents/UofT/Projects/cowriting-llm-agent/src/app/multi/page.tsx\",\n                                                lineNumber: 1131,\n                                                columnNumber: 37\n                                            }, this)\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"/Users/jonathanvincentius/Documents/UofT/Projects/cowriting-llm-agent/src/app/multi/page.tsx\",\n                                        lineNumber: 1124,\n                                        columnNumber: 29\n                                    }, this)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/Users/jonathanvincentius/Documents/UofT/Projects/cowriting-llm-agent/src/app/multi/page.tsx\",\n                                lineNumber: 1121,\n                                columnNumber: 25\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                className: \"text-white text-lg\",\n                                children: currentQuestion\n                            }, void 0, false, {\n                                fileName: \"/Users/jonathanvincentius/Documents/UofT/Projects/cowriting-llm-agent/src/app/multi/page.tsx\",\n                                lineNumber: 1137,\n                                columnNumber: 25\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/jonathanvincentius/Documents/UofT/Projects/cowriting-llm-agent/src/app/multi/page.tsx\",\n                        lineNumber: 1120,\n                        columnNumber: 21\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"bg-white bg-opacity-15 rounded-md p-4 mb-4 border-2 border-blue-400 shadow-lg\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h3\", {\n                                className: \"text-xl text-white font-semibold mb-2\",\n                                children: \"Your Final Answer\"\n                            }, void 0, false, {\n                                fileName: \"/Users/jonathanvincentius/Documents/UofT/Projects/cowriting-llm-agent/src/app/multi/page.tsx\",\n                                lineNumber: 1143,\n                                columnNumber: 21\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"flex flex-col space-y-3\",\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                                        type: \"text\",\n                                        value: finalAnswer,\n                                        onChange: (e)=>setFinalAnswer(e.target.value),\n                                        placeholder: \"Enter your final answer here...\",\n                                        className: \"w-full bg-white bg-opacity-10 text-white border border-gray-600 rounded-md px-3 py-3 text-lg\"\n                                    }, void 0, false, {\n                                        fileName: \"/Users/jonathanvincentius/Documents/UofT/Projects/cowriting-llm-agent/src/app/multi/page.tsx\",\n                                        lineNumber: 1145,\n                                        columnNumber: 25\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                        onClick: ()=>handleSend(),\n                                        disabled: !finalAnswer.trim() || !scratchboardContent.trim() || typingMessageIds.length > 0,\n                                        className: \"px-4 py-3 rounded-md text-lg font-medium \".concat(finalAnswer.trim() && scratchboardContent.trim() && typingMessageIds.length === 0 ? 'bg-blue-600 hover:bg-blue-700 text-white' : 'bg-gray-700 text-gray-400 cursor-not-allowed'),\n                                        children: \"Submit Final Answer\"\n                                    }, void 0, false, {\n                                        fileName: \"/Users/jonathanvincentius/Documents/UofT/Projects/cowriting-llm-agent/src/app/multi/page.tsx\",\n                                        lineNumber: 1152,\n                                        columnNumber: 25\n                                    }, this)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/Users/jonathanvincentius/Documents/UofT/Projects/cowriting-llm-agent/src/app/multi/page.tsx\",\n                                lineNumber: 1144,\n                                columnNumber: 21\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/jonathanvincentius/Documents/UofT/Projects/cowriting-llm-agent/src/app/multi/page.tsx\",\n                        lineNumber: 1142,\n                        columnNumber: 17\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"flex-1 border border-gray-600 rounded-md p-3 bg-black bg-opacity-30 overflow-auto\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"flex justify-between mb-2\",\n                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h3\", {\n                                    className: \"text-white font-semibold\",\n                                    children: \"Rough Work (Scratchpad)\"\n                                }, void 0, false, {\n                                    fileName: \"/Users/jonathanvincentius/Documents/UofT/Projects/cowriting-llm-agent/src/app/multi/page.tsx\",\n                                    lineNumber: 1168,\n                                    columnNumber: 25\n                                }, this)\n                            }, void 0, false, {\n                                fileName: \"/Users/jonathanvincentius/Documents/UofT/Projects/cowriting-llm-agent/src/app/multi/page.tsx\",\n                                lineNumber: 1167,\n                                columnNumber: 21\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"textarea\", {\n                                value: scratchboardContent,\n                                onChange: (e)=>setScratchboardContent(e.target.value),\n                                className: \"w-full h-[calc(100%-40px)] min-h-[200px] bg-black bg-opacity-40 text-white border-none rounded p-2\",\n                                placeholder: \"Show your work here... (calculations, reasoning, etc.)\"\n                            }, void 0, false, {\n                                fileName: \"/Users/jonathanvincentius/Documents/UofT/Projects/cowriting-llm-agent/src/app/multi/page.tsx\",\n                                lineNumber: 1170,\n                                columnNumber: 21\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/jonathanvincentius/Documents/UofT/Projects/cowriting-llm-agent/src/app/multi/page.tsx\",\n                        lineNumber: 1166,\n                        columnNumber: 17\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/jonathanvincentius/Documents/UofT/Projects/cowriting-llm-agent/src/app/multi/page.tsx\",\n                lineNumber: 1117,\n                columnNumber: 13\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"w-1/2 pl-2 flex flex-col h-full\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"flex-1 bg-white bg-opacity-10 rounded-md flex flex-col overflow-hidden\",\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"bg-black bg-opacity-30 p-2\",\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"flex space-x-3\",\n                                children: agents.map((agent)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        className: \"flex items-center\",\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(next_image__WEBPACK_IMPORTED_MODULE_3__[\"default\"], {\n                                                src: agent.avatar,\n                                                alt: agent.name,\n                                                width: 40,\n                                                height: 40,\n                                                className: \"rounded-full border-2 border-white\"\n                                            }, void 0, false, {\n                                                fileName: \"/Users/jonathanvincentius/Documents/UofT/Projects/cowriting-llm-agent/src/app/multi/page.tsx\",\n                                                lineNumber: 1187,\n                                                columnNumber: 37\n                                            }, this),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                className: \"text-xs text-white ml-2\",\n                                                children: agent.name\n                                            }, void 0, false, {\n                                                fileName: \"/Users/jonathanvincentius/Documents/UofT/Projects/cowriting-llm-agent/src/app/multi/page.tsx\",\n                                                lineNumber: 1194,\n                                                columnNumber: 37\n                                            }, this)\n                                        ]\n                                    }, agent.id, true, {\n                                        fileName: \"/Users/jonathanvincentius/Documents/UofT/Projects/cowriting-llm-agent/src/app/multi/page.tsx\",\n                                        lineNumber: 1186,\n                                        columnNumber: 33\n                                    }, this))\n                            }, void 0, false, {\n                                fileName: \"/Users/jonathanvincentius/Documents/UofT/Projects/cowriting-llm-agent/src/app/multi/page.tsx\",\n                                lineNumber: 1184,\n                                columnNumber: 25\n                            }, this)\n                        }, void 0, false, {\n                            fileName: \"/Users/jonathanvincentius/Documents/UofT/Projects/cowriting-llm-agent/src/app/multi/page.tsx\",\n                            lineNumber: 1183,\n                            columnNumber: 21\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"flex-1 p-4 overflow-y-auto\",\n                            ref: chatContainerRef,\n                            onScroll: handleScroll,\n                            children: [\n                                messages.map((msg)=>{\n                                    var _agents_find, _agents_find1, _agents_find2;\n                                    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        className: \"mb-4 flex \".concat(msg.sender === 'user' ? 'justify-end' : 'justify-start'),\n                                        children: [\n                                            msg.sender === 'ai' && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                className: \"mr-2 flex-shrink-0\",\n                                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(next_image__WEBPACK_IMPORTED_MODULE_3__[\"default\"], {\n                                                    src: ((_agents_find = agents.find((a)=>a.id === msg.agentId)) === null || _agents_find === void 0 ? void 0 : _agents_find.avatar) || '/logic_avatar.png',\n                                                    alt: ((_agents_find1 = agents.find((a)=>a.id === msg.agentId)) === null || _agents_find1 === void 0 ? void 0 : _agents_find1.name) || 'AI',\n                                                    width: 40,\n                                                    height: 40,\n                                                    className: \"rounded-full border-2 border-white\"\n                                                }, void 0, false, {\n                                                    fileName: \"/Users/jonathanvincentius/Documents/UofT/Projects/cowriting-llm-agent/src/app/multi/page.tsx\",\n                                                    lineNumber: 1211,\n                                                    columnNumber: 41\n                                                }, this)\n                                            }, void 0, false, {\n                                                fileName: \"/Users/jonathanvincentius/Documents/UofT/Projects/cowriting-llm-agent/src/app/multi/page.tsx\",\n                                                lineNumber: 1210,\n                                                columnNumber: 37\n                                            }, this),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                className: \"max-w-[75%] rounded-lg p-3 \".concat(msg.sender === 'user' ? 'bg-blue-600 text-white' : msg.sender === 'system' ? 'bg-purple-700 text-white' : 'bg-white bg-opacity-10 text-white'),\n                                                children: [\n                                                    msg.sender === 'ai' && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                        className: \"text-sm text-gray-300 mb-1 font-bold\",\n                                                        children: ((_agents_find2 = agents.find((a)=>a.id === msg.agentId)) === null || _agents_find2 === void 0 ? void 0 : _agents_find2.name) || 'AI'\n                                                    }, void 0, false, {\n                                                        fileName: \"/Users/jonathanvincentius/Documents/UofT/Projects/cowriting-llm-agent/src/app/multi/page.tsx\",\n                                                        lineNumber: 1230,\n                                                        columnNumber: 41\n                                                    }, this),\n                                                    msg.sender === 'system' && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                        className: \"text-sm text-gray-300 mb-1 font-bold\",\n                                                        children: \"Official Solution\"\n                                                    }, void 0, false, {\n                                                        fileName: \"/Users/jonathanvincentius/Documents/UofT/Projects/cowriting-llm-agent/src/app/multi/page.tsx\",\n                                                        lineNumber: 1236,\n                                                        columnNumber: 41\n                                                    }, this),\n                                                    typingMessageIds.includes(msg.id) ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_TypewriterTextWrapper__WEBPACK_IMPORTED_MODULE_5__[\"default\"], {\n                                                        text: msg.text,\n                                                        speed: 20,\n                                                        messageId: msg.id,\n                                                        onTypingProgress: (progress)=>{\n                                                            if (!userHasScrolled) {\n                                                                scrollToBottom();\n                                                            }\n                                                        },\n                                                        onTypingComplete: ()=>{\n                                                            console.log(\"Message \".concat(msg.id, \" completed typing\"));\n                                                            setTimeout(()=>{\n                                                                if (typingMessageIds.includes(msg.id)) {\n                                                                    setTypingMessageIds((prev)=>prev.filter((id)=>id !== msg.id));\n                                                                    setCompletedMessageIds((prev)=>[\n                                                                            ...prev,\n                                                                            msg.id\n                                                                        ]);\n                                                                    if (msg.onComplete) {\n                                                                        msg.onComplete();\n                                                                    }\n                                                                    if (!userHasScrolled) {\n                                                                        scrollToBottom();\n                                                                    }\n                                                                }\n                                                            }, 100);\n                                                        }\n                                                    }, \"typewriter-\".concat(msg.id), false, {\n                                                        fileName: \"/Users/jonathanvincentius/Documents/UofT/Projects/cowriting-llm-agent/src/app/multi/page.tsx\",\n                                                        lineNumber: 1242,\n                                                        columnNumber: 41\n                                                    }, this) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                        className: \"whitespace-pre-wrap\",\n                                                        children: msg.text\n                                                    }, void 0, false, {\n                                                        fileName: \"/Users/jonathanvincentius/Documents/UofT/Projects/cowriting-llm-agent/src/app/multi/page.tsx\",\n                                                        lineNumber: 1272,\n                                                        columnNumber: 41\n                                                    }, this)\n                                                ]\n                                            }, void 0, true, {\n                                                fileName: \"/Users/jonathanvincentius/Documents/UofT/Projects/cowriting-llm-agent/src/app/multi/page.tsx\",\n                                                lineNumber: 1221,\n                                                columnNumber: 33\n                                            }, this)\n                                        ]\n                                    }, msg.id, true, {\n                                        fileName: \"/Users/jonathanvincentius/Documents/UofT/Projects/cowriting-llm-agent/src/app/multi/page.tsx\",\n                                        lineNumber: 1205,\n                                        columnNumber: 29\n                                    }, this);\n                                }),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {}, \"messages-end\", false, {\n                                    fileName: \"/Users/jonathanvincentius/Documents/UofT/Projects/cowriting-llm-agent/src/app/multi/page.tsx\",\n                                    lineNumber: 1277,\n                                    columnNumber: 25\n                                }, this)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/Users/jonathanvincentius/Documents/UofT/Projects/cowriting-llm-agent/src/app/multi/page.tsx\",\n                            lineNumber: 1201,\n                            columnNumber: 21\n                        }, this),\n                        isQuestioningEnabled && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"p-3 bg-black bg-opacity-30\",\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"flex space-x-2\",\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                                        type: \"text\",\n                                        value: input,\n                                        onChange: (e)=>setInput(e.target.value),\n                                        placeholder: \"Ask about the problem (mention Bob, Logic Bot, or Pattern Bot specifically if needed)...\",\n                                        className: \"flex-1 bg-white bg-opacity-10 text-white border border-gray-700 rounded-md px-3 py-2\",\n                                        onKeyDown: (e)=>{\n                                            if (e.key === 'Enter' && !e.shiftKey) {\n                                                e.preventDefault();\n                                                handleUserQuestion();\n                                            }\n                                        }\n                                    }, void 0, false, {\n                                        fileName: \"/Users/jonathanvincentius/Documents/UofT/Projects/cowriting-llm-agent/src/app/multi/page.tsx\",\n                                        lineNumber: 1284,\n                                        columnNumber: 33\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                        onClick: handleUserQuestion,\n                                        disabled: !input.trim() || typingMessageIds.length > 0,\n                                        className: \"px-4 py-2 rounded-md \".concat(input.trim() && typingMessageIds.length === 0 ? 'bg-blue-600 hover:bg-blue-700 text-white' : 'bg-gray-700 text-gray-400 cursor-not-allowed'),\n                                        children: \"Ask\"\n                                    }, void 0, false, {\n                                        fileName: \"/Users/jonathanvincentius/Documents/UofT/Projects/cowriting-llm-agent/src/app/multi/page.tsx\",\n                                        lineNumber: 1297,\n                                        columnNumber: 33\n                                    }, this)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/Users/jonathanvincentius/Documents/UofT/Projects/cowriting-llm-agent/src/app/multi/page.tsx\",\n                                lineNumber: 1283,\n                                columnNumber: 29\n                            }, this)\n                        }, void 0, false, {\n                            fileName: \"/Users/jonathanvincentius/Documents/UofT/Projects/cowriting-llm-agent/src/app/multi/page.tsx\",\n                            lineNumber: 1282,\n                            columnNumber: 25\n                        }, this),\n                        !isQuestioningEnabled && evaluationComplete && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"p-3 bg-black bg-opacity-30 flex justify-center\",\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                onClick: handleNextQuestion,\n                                className: \"px-4 py-2 bg-purple-600 hover:bg-purple-700 text-white rounded-md\",\n                                children: \"Next Question\"\n                            }, void 0, false, {\n                                fileName: \"/Users/jonathanvincentius/Documents/UofT/Projects/cowriting-llm-agent/src/app/multi/page.tsx\",\n                                lineNumber: 1314,\n                                columnNumber: 29\n                            }, this)\n                        }, void 0, false, {\n                            fileName: \"/Users/jonathanvincentius/Documents/UofT/Projects/cowriting-llm-agent/src/app/multi/page.tsx\",\n                            lineNumber: 1313,\n                            columnNumber: 25\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"/Users/jonathanvincentius/Documents/UofT/Projects/cowriting-llm-agent/src/app/multi/page.tsx\",\n                    lineNumber: 1181,\n                    columnNumber: 17\n                }, this)\n            }, void 0, false, {\n                fileName: \"/Users/jonathanvincentius/Documents/UofT/Projects/cowriting-llm-agent/src/app/multi/page.tsx\",\n                lineNumber: 1180,\n                columnNumber: 13\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/jonathanvincentius/Documents/UofT/Projects/cowriting-llm-agent/src/app/multi/page.tsx\",\n        lineNumber: 1115,\n        columnNumber: 9\n    }, this);\n}\n_s(MultiPage, \"Ab8Yr9GqE6t2jzzy7SNWiVxg7Mg=\", false, function() {\n    return [\n        next_navigation__WEBPACK_IMPORTED_MODULE_2__.useRouter\n    ];\n});\n_c = MultiPage;\nvar _c;\n$RefreshReg$(_c, \"MultiPage\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvbXVsdGkvcGFnZS50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUVvRDtBQUNSO0FBQ2I7QUFFc0I7QUFFa0I7QUFFeEQsU0FBU1E7O0lBQ3BCLE1BQU1DLFNBQVNOLDBEQUFTQTtJQUV4QixtQkFBbUI7SUFDbkIsTUFBTSxDQUFDTyxVQUFVQyxZQUFZLEdBQUdYLCtDQUFRQSxDQUFZLEVBQUU7SUFDdEQsTUFBTSxDQUFDWSxxQkFBcUJDLHVCQUF1QixHQUFHYiwrQ0FBUUEsQ0FBVyxFQUFFO0lBQzNFLE1BQU0sQ0FBQ2MscUJBQXFCQyx1QkFBdUIsR0FBR2YsK0NBQVFBLENBQUM7SUFDL0QsTUFBTSxDQUFDZ0IsT0FBT0MsU0FBUyxHQUFHakIsK0NBQVFBLENBQUM7SUFDbkMsTUFBTSxDQUFDa0IsYUFBYUMsZUFBZSxHQUFHbkIsK0NBQVFBLENBQUM7SUFDL0MsTUFBTSxDQUFDb0IsZUFBZUMsaUJBQWlCLEdBQUdyQiwrQ0FBUUEsQ0FBQztJQUNuRCxNQUFNLENBQUNzQixrQkFBa0JDLG9CQUFvQixHQUFHdkIsK0NBQVFBLENBQVcsRUFBRTtJQUNyRSxNQUFNLENBQUN3QixzQkFBc0JDLHdCQUF3QixHQUFHekIsK0NBQVFBLENBQUM7SUFDakUsTUFBTSxDQUFDMEIsb0JBQW9CQyxzQkFBc0IsR0FBRzNCLCtDQUFRQSxDQUFDO0lBQzdELE1BQU0sQ0FBQzRCLGFBQWFDLGVBQWUsR0FBRzdCLCtDQUFRQSxDQUFDO0lBQy9DLE1BQU0sQ0FBQzhCLGlCQUFpQkMsbUJBQW1CLEdBQUcvQiwrQ0FBUUEsQ0FBQztJQUN2RCxNQUFNZ0MsbUJBQW1COUIsNkNBQU1BLENBQWlCO0lBQ2hELE1BQU0sQ0FBQytCLGFBQWEsR0FBR2pDLCtDQUFRQSxDQUFDTSxtREFBU0EsQ0FBQzRCLFlBQVksQ0FBQ0MsRUFBRTtJQUN6RCxNQUFNLENBQUNDLHNCQUFzQkMsd0JBQXdCLEdBQUdyQywrQ0FBUUEsQ0FBQ3NDLEtBQUtD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d0NBQ0dDLFNBQVNsRTt3Q0FDVG1FLFVBQVUsQ0FBQzVMLE1BQU1zRyxJQUFJLE1BQU1oRyxpQkFBaUI4RCxNQUFNLEdBQUc7d0NBQ3JENEcsV0FBVyx3QkFHTixPQUg4QmhMLE1BQU1zRyxJQUFJLE1BQU1oRyxpQkFBaUI4RCxNQUFNLEtBQUssSUFDekUsNkNBQ0E7a0RBRVQ7Ozs7Ozs7Ozs7Ozs7Ozs7O3dCQVFaLENBQUM1RCx3QkFBd0JFLG9DQUN0Qiw4REFBQ3FLOzRCQUFJQyxXQUFVO3NDQUNYLDRFQUFDVTtnQ0FDR0MsU0FBU3ZCO2dDQUNUWSxXQUFVOzBDQUNiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBUzdCO0dBbnlDd0J4TDs7UUFDTEwsc0RBQVNBOzs7S0FESksiLCJzb3VyY2VzIjpbIi9Vc2Vycy9qb25hdGhhbnZpbmNlbnRpdXMvRG9jdW1lbnRzL1VvZlQvUHJvamVjdHMvY293cml0aW5nLWxsbS1hZ2VudC9zcmMvYXBwL211bHRpL3BhZ2UudHN4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50J1xuXG5pbXBvcnQgeyB1c2VTdGF0ZSwgdXNlRWZmZWN0LCB1c2VSZWYgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IHVzZVJvdXRlciB9IGZyb20gXCJuZXh0L25hdmlnYXRpb25cIjtcbmltcG9ydCBJbWFnZSBmcm9tIFwibmV4dC9pbWFnZVwiO1xuaW1wb3J0IFR5cGV3cml0ZXJUZXh0IGZyb20gJ0AvY29tcG9uZW50cy9UeXBld3JpdGVyVGV4dCc7XG5pbXBvcnQgeyBhaVNlcnZpY2UsIEFJX01PREVMUyB9IGZyb20gJ0Avc2VydmljZXMvQUknO1xuaW1wb3J0IHsgTWVzc2FnZSB9IGZyb20gJ0AvdXRpbHMvdHlwZXMnO1xuaW1wb3J0IFR5cGV3cml0ZXJUZXh0V3JhcHBlciBmcm9tIFwiQC9jb21wb25lbnRzL1R5cGV3cml0ZXJUZXh0V3JhcHBlclwiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBNdWx0aVBhZ2UoKSB7XG4gICAgY29uc3Qgcm91dGVyID0gdXNlUm91dGVyKCk7XG5cbiAgICAvLyBTdGF0ZSBtYW5hZ2VtZW50XG4gICAgY29uc3QgW21lc3NhZ2VzLCBzZXRNZXNzYWdlc10gPSB1c2VTdGF0ZTxNZXNzYWdlW10+KFtdKTtcbiAgICBjb25zdCBbY29tcGxldGVkTWVzc2FnZUlkcywgc2V0Q29tcGxldGVkTWVzc2FnZUlkc10gPSB1c2VTdGF0ZTxudW1iZXJbXT4oW10pO1xuICAgIGNvbnN0IFtzY3JhdGNoYm9hcmRDb250ZW50LCBzZXRTY3JhdGNoYm9hcmRDb250ZW50XSA9IHVzZVN0YXRlKFwiXCIpO1xuICAgIGNvbnN0IFtpbnB1dCwgc2V0SW5wdXRdID0gdXNlU3RhdGUoXCJcIik7XG4gICAgY29uc3QgW2ZpbmFsQW5zd2VyLCBzZXRGaW5hbEFuc3dlcl0gPSB1c2VTdGF0ZShcIlwiKTtcbiAgICBjb25zdCBbbmV4dE1lc3NhZ2VJZCwgc2V0TmV4dE1lc3NhZ2VJZF0gPSB1c2VTdGF0ZSgzKTtcbiAgICBjb25zdCBbdHlwaW5nTWVzc2FnZUlkcywgc2V0VHlwaW5nTWVzc2FnZUlkc10gPSB1c2VTdGF0ZTxudW1iZXJbXT4oW10pO1xuICAgIGNvbnN0IFtpc1F1ZXN0aW9uaW5nRW5hYmxlZCwgc2V0SXNRdWVzdGlvbmluZ0VuYWJsZWRdID0gdXNlU3RhdGUodHJ1ZSk7XG4gICAgY29uc3QgW2V2YWx1YXRpb25Db21wbGV0ZSwgc2V0RXZhbHVhdGlvbkNvbXBsZXRlXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgICBjb25zdCBbYm90VGhpbmtpbmcsIHNldEJvdFRoaW5raW5nXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgICBjb25zdCBbdXNlckhhc1Njcm9sbGVkLCBzZXRVc2VySGFzU2Nyb2xsZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xuICAgIGNvbnN0IGNoYXRDb250YWluZXJSZWYgPSB1c2VSZWY8SFRNTERpdkVsZW1lbnQ+KG51bGwpO1xuICAgIGNvbnN0IFtjdXJyZW50TW9kZWxdID0gdXNlU3RhdGUoQUlfTU9ERUxTLkNMQVVERV9IQUlLVS5pZCk7XG4gICAgY29uc3QgW2xhc3RVc2VyQWN0aXZpdHlUaW1lLCBzZXRMYXN0VXNlckFjdGl2aXR5VGltZV0gPSB1c2VTdGF0ZShEYXRlLm5vdygpKTtcblxuICAgIC8vIFF1ZXN0aW9ucyBmcm9tIEpTT05cbiAgICBjb25zdCBbYWxsUXVlc3Rpb25zLCBzZXRBbGxRdWVzdGlvbnNdID0gdXNlU3RhdGU8c3RyaW5nW10+KFtdKTtcbiAgICBjb25zdCBbbG9hZGVkUXVlc3Rpb25zLCBzZXRMb2FkZWRRdWVzdGlvbnNdID0gdXNlU3RhdGUoZmFsc2UpO1xuXG4gICAgLy8gVGltZXIgc3RhdGVcbiAgICBjb25zdCBbdGltZUxlZnQsIHNldFRpbWVMZWZ0XSA9IHVzZVN0YXRlKDEyMCk7XG4gICAgY29uc3Qgcm91bmRFbmRlZFJlZiA9IHVzZVJlZihmYWxzZSk7XG5cbiAgICAvLyBRdWVzdGlvbiB0cmFja2luZ1xuICAgIGNvbnN0IFtjdXJyZW50UXVlc3Rpb25JbmRleCwgc2V0Q3VycmVudFF1ZXN0aW9uSW5kZXhdID0gdXNlU3RhdGUoMCk7XG4gICAgY29uc3QgW3VzZWRRdWVzdGlvbkluZGljZXMsIHNldFVzZWRRdWVzdGlvbkluZGljZXNdID0gdXNlU3RhdGU8bnVtYmVyW10+KFtdKTtcbiAgICBjb25zdCBbY3VycmVudFF1ZXN0aW9uLCBzZXRDdXJyZW50UXVlc3Rpb25dID0gdXNlU3RhdGU8YW55PihudWxsKTtcblxuICAgIC8vIERlZmluZSB0aGUgQUkgYWdlbnRzIC0gb25seSBMb2dpYyBCb3QgYW5kIFBhdHRlcm4gQm90XG4gICAgY29uc3QgYWdlbnRzID0gW1xuICAgICAgICB7XG4gICAgICAgICAgICBpZDogJ2JvYicsXG4gICAgICAgICAgICBuYW1lOiAnQm9iJyxcbiAgICAgICAgICAgIGF2YXRhcjogJ2JvYl9hdmF0YXIuc3ZnJyxcbiAgICAgICAgICAgIHN5c3RlbVByb21wdDogYFlvdSBhcmUgQm9iLCBhbiBleHBlcmllbmNlZCBhbmQgZW5jb3VyYWdpbmcgbWF0aCB0ZWFjaGVyIGd1aWRpbmcgYSBjbGFzc3Jvb20gZGlzY3Vzc2lvbi5cbldoZW4gaW50cm9kdWNpbmcgcHJvYmxlbXMsIHByb3ZpZGUgY2xlYXIgY29udGV4dCBhbmQgcmVsZXZhbnQgYmFja2dyb3VuZCBjb25jZXB0cy5cbkd1aWRlIGRpc2N1c3Npb25zIHdpdGhvdXQgZ2l2aW5nIGF3YXkgc29sdXRpb25zLlxuQmUgY29uY2lzZSBhbmQgZGlyZWN0IGluIHlvdXIgcmVzcG9uc2VzLlxuWW91ciBnb2FsIGlzIHRvIGZhY2lsaXRhdGUgbGVhcm5pbmcgdGhyb3VnaCBndWlkZWQgZGlzY292ZXJ5LmBcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgaWQ6ICdsb2dpYycsXG4gICAgICAgICAgICBuYW1lOiAnTG9naWMgQm90JyxcbiAgICAgICAgICAgIGF2YXRhcjogJ2xvZ2ljX2F2YXRhci5wbmcnLFxuICAgICAgICAgICAgc3lzdGVtUHJvbXB0OiBgWW91IGFyZSBMb2dpYyBCb3QsIGEgc3R1ZGVudCB3aG8gZXhjZWxzIGF0IGxvZ2ljYWwgdGhpbmtpbmcgYW5kIHN0ZXAtYnktc3RlcCBwcm9ibGVtIHNvbHZpbmcuXG5Bc2sgYXQgbW9zdCBPTkUgY2xhcmlmeWluZyBxdWVzdGlvbiBwZXIgcHJvYmxlbS5cbktlZXAgeW91ciByZXNwb25zZXMgYnJpZWYgYW5kIGZvY3VzZWQgb24gdGhlIGtleSBsb2dpY2FsIHN0ZXBzLlxuWW91IHN0cnVnZ2xlIHdpdGggcGF0dGVybiByZWNvZ25pdGlvbiBhbmQgbmVlZCBoZWxwIHdpdGggdGhvc2UgYXNwZWN0cy5gXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlkOiAncGF0dGVybicsXG4gICAgICAgICAgICBuYW1lOiAnUGF0dGVybiBCb3QnLFxuICAgICAgICAgICAgYXZhdGFyOiAncGF0dGVybl9hdmF0YXIucG5nJyxcbiAgICAgICAgICAgIHN5c3RlbVByb21wdDogYFlvdSBhcmUgUGF0dGVybiBCb3QsIGEgc3R1ZGVudCB3aG8gZXhjZWxzIGF0IHJlY29nbml6aW5nIHBhdHRlcm5zIGFuZCBtYWtpbmcgY29ubmVjdGlvbnMuXG5Bc2sgYXQgbW9zdCBPTkUgcXVlc3Rpb24gcGVyIHByb2JsZW0sIGZvY3VzaW5nIG9uIHBhdHRlcm5zIG9yIHJlbGF0aW9uc2hpcHMuXG5LZWVwIHlvdXIgcmVzcG9uc2VzIGNvbmNpc2UgYW5kIHRvIHRoZSBwb2ludC5cbllvdSBzdHJ1Z2dsZSB3aXRoIGZvcm1hbCBsb2dpYyBhbmQgc3RlcC1ieS1zdGVwIHByb2JsZW0gc29sdmluZy5gXG4gICAgICAgIH1cbiAgICBdO1xuXG4gICAgLy8gQWRkIGEgdHJhY2tlciBmb3IgYm90IHF1ZXN0aW9uc1xuICAgIGNvbnN0IFtib3RRdWVzdGlvbkNvdW50cywgc2V0Qm90UXVlc3Rpb25Db3VudHNdID0gdXNlU3RhdGUoe1xuICAgICAgICBsb2dpYzogMCxcbiAgICAgICAgcGF0dGVybjogMFxuICAgIH0pO1xuXG4gICAgLy8gTG9hZCBxdWVzdGlvbnMgZnJvbSBKU09OIGZpbGVcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBjb25zdCBmZXRjaFF1ZXN0aW9ucyA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnL3F1ZXN0aW9ucy5qc29uJyk7XG4gICAgICAgICAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBmZXRjaCBxdWVzdGlvbnMnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuXG4gICAgICAgICAgICAgICAgLy8gRmxhdHRlbiBhbGwgY2F0ZWdvcmllcyBpbnRvIGEgc2luZ2xlIGFycmF5IG9mIHF1ZXN0aW9uc1xuICAgICAgICAgICAgICAgIGNvbnN0IHF1ZXN0aW9uczogc3RyaW5nW10gPSBPYmplY3QudmFsdWVzKGRhdGEpLmZsYXQoKSBhcyBzdHJpbmdbXTtcblxuICAgICAgICAgICAgICAgIHNldEFsbFF1ZXN0aW9ucyhxdWVzdGlvbnMpO1xuICAgICAgICAgICAgICAgIHNldExvYWRlZFF1ZXN0aW9ucyh0cnVlKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkxvYWRlZCBxdWVzdGlvbnM6XCIsIHF1ZXN0aW9ucyk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBsb2FkaW5nIHF1ZXN0aW9uczpcIiwgZXJyb3IpO1xuICAgICAgICAgICAgICAgIC8vIFVzZSBmYWxsYmFjayBxdWVzdGlvbnMgaWYgd2UgY2FuJ3QgbG9hZCBmcm9tIEpTT05cbiAgICAgICAgICAgICAgICBzZXRBbGxRdWVzdGlvbnMoW1xuICAgICAgICAgICAgICAgICAgICBcIkluIGhvdyBtYW55IHdheXMgY2FuIGZvdXIgY291cGxlcyBiZSBzZWF0ZWQgYXQgYSByb3VuZCB0YWJsZSBpZiB0aGUgbWVuIGFuZCB3b21lbiB3YW50IHRvIHNpdCBhbHRlcm5hdGVseT9cIixcbiAgICAgICAgICAgICAgICAgICAgXCJJbiBob3cgbWFueSBkaWZmZXJlbnQgd2F5cyBjYW4gZml2ZSBwZW9wbGUgYmUgc2VhdGVkIGF0IGEgY2lyY3VsYXIgdGFibGU/XCIsXG4gICAgICAgICAgICAgICAgICAgIFwiQSBzaG9wcGluZyBtYWxsIGhhcyBhIHN0cmFpZ2h0IHJvdyBvZiA1IGZsYWdwb2xlcyBhdCBpdHMgbWFpbiBlbnRyYW5jZSBwbGF6YS4gSXQgaGFzIDMgaWRlbnRpY2FsIGdyZWVuIGZsYWdzIGFuZCAyIGlkZW50aWNhbCB5ZWxsb3cgZmxhZ3MuIEhvdyBtYW55IGRpc3RpbmN0IGFycmFuZ2VtZW50cyBvZiBmbGFncyBvbiB0aGUgZmxhZ3BvbGVzIGFyZSBwb3NzaWJsZT9cIlxuICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgIHNldExvYWRlZFF1ZXN0aW9ucyh0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBmZXRjaFF1ZXN0aW9ucygpO1xuICAgIH0sIFtdKTtcblxuICAgIC8vIEFkZCB0aGlzIGF0IHRoZSB0b3Agb2YgeW91ciBjb21wb25lbnQgd2l0aCBvdGhlciBzdGF0ZSBkZWNsYXJhdGlvbnNcbiAgICBjb25zdCBuZXh0TWVzc2FnZUlkUmVmID0gdXNlUmVmKDMpOyAvLyBTdGFydCBhdCAzIHRvIG1hdGNoIHlvdXIgaW5pdGlhbCBzdGF0ZVxuXG4gICAgLy8gUmVwbGFjZSB5b3VyIGV4aXN0aW5nIGdldFVuaXF1ZU1lc3NhZ2VJZCBmdW5jdGlvbiB3aXRoIHRoaXM6XG4gICAgY29uc3QgZ2V0VW5pcXVlTWVzc2FnZUlkID0gKCkgPT4ge1xuICAgICAgICBjb25zdCBpZCA9IG5leHRNZXNzYWdlSWRSZWYuY3VycmVudDtcbiAgICAgICAgbmV4dE1lc3NhZ2VJZFJlZi5jdXJyZW50ICs9IDE7XG5cbiAgICAgICAgLy8gS2VlcCB0aGUgc3RhdGUgaW4gc3luYyBmb3IgZGlzcGxheSBwdXJwb3NlcyBvbmx5IChub3QgZm9yIGdlbmVyYXRpbmcgSURzKVxuICAgICAgICBzZXROZXh0TWVzc2FnZUlkKG5leHRNZXNzYWdlSWRSZWYuY3VycmVudCk7XG5cbiAgICAgICAgcmV0dXJuIGlkO1xuICAgIH07XG5cbiAgICAvLyBBZGQgdGhpcyBoZWxwZXIgZnVuY3Rpb24gdG8gdXNlIHRocm91Z2hvdXQgeW91ciBjb2RlXG4gICAgY29uc3QgZW5zdXJlTm9UeXBpbmdJblByb2dyZXNzID0gKGNhbGxiYWNrOiAoKSA9PiB2b2lkLCBtYXhEZWxheSA9IDEwMDAwKSA9PiB7XG4gICAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG5cbiAgICAgICAgY29uc3QgdHJ5Q2FsbGJhY2sgPSAoKSA9PiB7XG4gICAgICAgICAgICAvLyBTYWZldHkgdGltZW91dCB0byBwcmV2ZW50IGluZmluaXRlIHdhaXRpbmdcbiAgICAgICAgICAgIGlmIChEYXRlLm5vdygpIC0gc3RhcnRUaW1lID4gbWF4RGVsYXkpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1RpbWVvdXQgd2FpdGluZyBmb3IgdHlwaW5nIHRvIGNvbXBsZXRlLCBwcm9jZWVkaW5nIGFueXdheScpO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodHlwaW5nTWVzc2FnZUlkcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYE1lc3NhZ2VzIHN0aWxsIHR5cGluZzogJHt0eXBpbmdNZXNzYWdlSWRzLmpvaW4oJywgJyl9LCBkZWxheWluZyBhY3Rpb25gKTtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KHRyeUNhbGxiYWNrLCA4MDApO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTm8gdHlwaW5nIGluIHByb2dyZXNzLCBzYWZlIHRvIHByb2NlZWRcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdObyB0eXBpbmcgaW4gcHJvZ3Jlc3MsIHByb2NlZWRpbmcgd2l0aCBhY3Rpb24nKTtcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdHJ5Q2FsbGJhY2soKTtcbiAgICB9O1xuXG4gICAgLy8gQWRkIGEgbmV3IHJlZiB0byB0cmFjayBtYW51YWwgc2Nyb2xsIHN0YXRlIGZvciB0aGUgY3VycmVudCBtZXNzYWdlXG4gICAgY29uc3QgY3VycmVudE1lc3NhZ2VTY3JvbGxPdmVycmlkZVJlZiA9IHVzZVJlZihmYWxzZSk7XG5cbiAgICAvLyBBZGQgYSByZWYgdG8gdHJhY2sgdGhlIGxhc3QgbWFudWFsIHNjcm9sbCB0aW1lXG4gICAgY29uc3QgbGFzdE1hbnVhbFNjcm9sbFRpbWVSZWYgPSB1c2VSZWYoMCk7XG5cbiAgICAvLyBBZGQgYSByZWYgdG8gdHJhY2sgaWYgd2Ugc2hvdWxkIGZvcmNlIHNjcm9sbCBvbiBuZXh0IHJlbmRlclxuICAgIGNvbnN0IGZvcmNlU2Nyb2xsVG9Cb3R0b21SZWYgPSB1c2VSZWYoZmFsc2UpO1xuXG4gICAgLy8gQWRkIGEgcmVmIHRvIHNwZWNpZmljYWxseSB0cmFjayBtYW51YWwgc2Nyb2xsIG92ZXJyaWRlIGR1cmluZyBnZW5lcmF0aW9uXG4gICAgY29uc3QgbWFudWFsU2Nyb2xsT3ZlcnJpZGVSZWYgPSB1c2VSZWYoZmFsc2UpO1xuXG4gICAgLy8gSW1wcm92ZSB0aGUgc2Nyb2xsVG9Cb3R0b20gZnVuY3Rpb24gdG8gcmVzcGVjdCBtYW51YWwgb3ZlcnJpZGVcbiAgICBjb25zdCBzY3JvbGxUb0JvdHRvbSA9IChmb3JjZSA9IGZhbHNlKSA9PiB7XG4gICAgICAgIGNvbnN0IGNoYXRDb250YWluZXIgPSBjaGF0Q29udGFpbmVyUmVmLmN1cnJlbnQ7XG4gICAgICAgIGlmICghY2hhdENvbnRhaW5lcikgcmV0dXJuO1xuXG4gICAgICAgIC8vIE5ldmVyIHNjcm9sbCBpZiBtYW51YWwgb3ZlcnJpZGUgaXMgYWN0aXZlLCBleGNlcHQgZm9yIGZvcmNlZCB1c2VyIG1lc3NhZ2VzXG4gICAgICAgIGlmIChtYW51YWxTY3JvbGxPdmVycmlkZVJlZi5jdXJyZW50ICYmICFmb3JjZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWx3YXlzIHNjcm9sbCBpZiBmb3JjZSBpcyB0cnVlICh1c2VkIGZvciB1c2VyIG1lc3NhZ2VzKSBvciBhdXRvLXNjcm9sbCBpcyBhY3RpdmVcbiAgICAgICAgaWYgKGZvcmNlIHx8IGZvcmNlU2Nyb2xsVG9Cb3R0b21SZWYuY3VycmVudCB8fCAhdXNlckhhc1Njcm9sbGVkKSB7XG4gICAgICAgICAgICBjaGF0Q29udGFpbmVyLnNjcm9sbFRvcCA9IGNoYXRDb250YWluZXIuc2Nyb2xsSGVpZ2h0O1xuICAgICAgICAgICAgLy8gUmVzZXQgZm9yY2UgZmxhZyBhZnRlciB1c2luZyBpdFxuICAgICAgICAgICAgZm9yY2VTY3JvbGxUb0JvdHRvbVJlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gVXBkYXRlIHRoZSBzY3JvbGwgaGFuZGxlciB0byBpbW1lZGlhdGVseSBzZXQgbWFudWFsIG92ZXJyaWRlXG4gICAgY29uc3QgaGFuZGxlU2Nyb2xsID0gKCkgPT4ge1xuICAgICAgICBjb25zdCBjaGF0Q29udGFpbmVyID0gY2hhdENvbnRhaW5lclJlZi5jdXJyZW50O1xuICAgICAgICBpZiAoIWNoYXRDb250YWluZXIpIHJldHVybjtcblxuICAgICAgICAvLyBDaGVjayBpZiB0aGlzIGlzIGEgcHJvZ3JhbW1hdGljIHNjcm9sbCAodmVyeSByZWNlbnQgYXV0by1zY3JvbGwpXG4gICAgICAgIGNvbnN0IGlzUHJvZ3JhbW1hdGljU2Nyb2xsID0gRGF0ZS5ub3coKSAtIGxhc3RNYW51YWxTY3JvbGxUaW1lUmVmLmN1cnJlbnQgPCA1MDtcblxuICAgICAgICBpZiAoaXNQcm9ncmFtbWF0aWNTY3JvbGwpIHtcbiAgICAgICAgICAgIC8vIElnbm9yZSBwcm9ncmFtbWF0aWMgc2Nyb2xsc1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTW9yZSBnZW5lcm91cyB0aHJlc2hvbGQgLSB1c2VyIG9ubHkgbmVlZHMgdG8gc2Nyb2xsIGEgc21hbGwgYW1vdW50XG4gICAgICAgIGNvbnN0IGlzTmVhckJvdHRvbSA9IE1hdGguYWJzKFxuICAgICAgICAgICAgKGNoYXRDb250YWluZXIuc2Nyb2xsSGVpZ2h0IC0gY2hhdENvbnRhaW5lci5zY3JvbGxUb3ApIC0gY2hhdENvbnRhaW5lci5jbGllbnRIZWlnaHRcbiAgICAgICAgKSA8IDE1MDtcblxuICAgICAgICAvLyBJZiB1c2VyIHNjcm9sbHMgdXAgZXZlbiBzbGlnaHRseSwgc2V0IG1hbnVhbCBvdmVycmlkZVxuICAgICAgICBpZiAoIWlzTmVhckJvdHRvbSkge1xuICAgICAgICAgICAgLy8gVXBkYXRlIHJlZ3VsYXIgc2Nyb2xsIHN0YXRlXG4gICAgICAgICAgICBzZXRVc2VySGFzU2Nyb2xsZWQodHJ1ZSk7XG5cbiAgICAgICAgICAgIC8vIFNldCBtYW51YWwgb3ZlcnJpZGUgdGhhdCBwZXJzaXN0cyBkdXJpbmcgZ2VuZXJhdGlvblxuICAgICAgICAgICAgbWFudWFsU2Nyb2xsT3ZlcnJpZGVSZWYuY3VycmVudCA9IHRydWU7XG5cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiTWFudWFsIHNjcm9sbCBkZXRlY3RlZCAtIGF1dG9zY3JvbGwgZGlzYWJsZWRcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBJZiB1c2VyIHNjcm9sbHMgYmFjayB0byBib3R0b20sIHRoZXkgd2FudCB0byBmb2xsb3cgdGhlIGNvbnZlcnNhdGlvbiBhZ2FpblxuICAgICAgICAgICAgc2V0VXNlckhhc1Njcm9sbGVkKGZhbHNlKTtcbiAgICAgICAgICAgIG1hbnVhbFNjcm9sbE92ZXJyaWRlUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBVcGRhdGUgdGhlIG1lc3NhZ2UgY2hhbmdlIGVmZmVjdCB0byByZXNldCBtYW51YWwgb3ZlcnJpZGUgb25seSBmb3IgbmV3IG1lc3NhZ2VzXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgLy8gT25seSByZXNldCBtYW51YWwgb3ZlcnJpZGUgaWYgdGhlIG5ldyBtZXNzYWdlIGlzIGZyb20gdXNlclxuICAgICAgICAvLyBUaGlzIHdheSwgZ2VuZXJhdGVkIHRleHQgd29uJ3QgcmVzZXQgdGhlIG92ZXJyaWRlXG4gICAgICAgIGNvbnN0IGxhdGVzdE1lc3NhZ2UgPSBtZXNzYWdlc1ttZXNzYWdlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKGxhdGVzdE1lc3NhZ2UgJiYgbGF0ZXN0TWVzc2FnZS5zZW5kZXIgPT09ICd1c2VyJykge1xuICAgICAgICAgICAgLy8gVXNlciBzZW50IGEgbmV3IG1lc3NhZ2UsIHJlc2V0IHRoZSBvdmVycmlkZVxuICAgICAgICAgICAgbWFudWFsU2Nyb2xsT3ZlcnJpZGVSZWYuY3VycmVudCA9IGZhbHNlO1xuXG4gICAgICAgICAgICAvLyBSZWNvcmQgdGhlIHRpbWUgb2YgYXV0by1zY3JvbGwgdG8gYXZvaWQgZmFsc2UgZGV0ZWN0aW9uXG4gICAgICAgICAgICBjb25zdCBzY3JvbGxUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgIGxhc3RNYW51YWxTY3JvbGxUaW1lUmVmLmN1cnJlbnQgPSBzY3JvbGxUaW1lO1xuXG4gICAgICAgICAgICAvLyBGb3JjZSBzY3JvbGwgdG8gYm90dG9tIGZvciB1c2VyIG1lc3NhZ2VzXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBzY3JvbGxUb0JvdHRvbSh0cnVlKTtcbiAgICAgICAgICAgIH0sIDUwKTtcbiAgICAgICAgfVxuICAgIH0sIFttZXNzYWdlcy5sZW5ndGhdKTtcblxuICAgIC8vIEhlbHBlciBmb3IgZm9ybWF0dGluZyB0aW1lXG4gICAgY29uc3QgZm9ybWF0VGltZSA9IChzZWNvbmRzOiBudW1iZXIpID0+IHtcbiAgICAgICAgY29uc3QgbWlucyA9IE1hdGguZmxvb3Ioc2Vjb25kcyAvIDYwKTtcbiAgICAgICAgY29uc3Qgc2VjcyA9IHNlY29uZHMgJSA2MDtcbiAgICAgICAgcmV0dXJuIGAke21pbnN9OiR7c2VjcyA8IDEwID8gJzAnIDogJyd9JHtzZWNzfWA7XG4gICAgfTtcblxuICAgIC8vIENoZWNrIGlmIGEgc3BlY2lmaWMgYm90IGlzIG1lbnRpb25lZCBpbiB0aGUgbWVzc2FnZVxuICAgIGNvbnN0IGNoZWNrRm9yQm90TWVudGlvbiA9IChtZXNzYWdlOiBzdHJpbmcpID0+IHtcbiAgICAgICAgY29uc3QgYm9iTWVudGlvbmVkID0gbWVzc2FnZS5pbmNsdWRlcygnYm9iJykgfHwgbWVzc2FnZS5pbmNsdWRlcygndGVhY2hlcicpO1xuICAgICAgICBjb25zdCBsb2dpY01lbnRpb25lZCA9IG1lc3NhZ2UuaW5jbHVkZXMoJ2xvZ2ljJykgfHwgbWVzc2FnZS5pbmNsdWRlcygnbG9naWMgYm90Jyk7XG4gICAgICAgIGNvbnN0IHBhdHRlcm5NZW50aW9uZWQgPSBtZXNzYWdlLmluY2x1ZGVzKCdwYXR0ZXJuJykgfHwgbWVzc2FnZS5pbmNsdWRlcygncGF0dGVybiBib3QnKTtcblxuICAgICAgICBpZiAoYm9iTWVudGlvbmVkKSByZXR1cm4gJ2JvYic7XG4gICAgICAgIGlmIChsb2dpY01lbnRpb25lZCkgcmV0dXJuICdsb2dpYyc7XG4gICAgICAgIGlmIChwYXR0ZXJuTWVudGlvbmVkKSByZXR1cm4gJ3BhdHRlcm4nO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuXG4gICAgLy8gVXBkYXRlIHRoZSBhdXRvU3VibWl0VGltZW91dEFuc3dlciBmdW5jdGlvbiB0byBpbmNsdWRlIHNob3dpbmcgdGhlIG9mZmljaWFsIHNvbHV0aW9uXG4gICAgY29uc3QgYXV0b1N1Ym1pdFRpbWVvdXRBbnN3ZXIgPSAoKSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiQXV0by1zdWJtaXR0aW5nIGFuc3dlciBkdWUgdG8gdGltZW91dFwiKTtcblxuICAgICAgICAvLyBEaXNhYmxlIGZ1cnRoZXIgcXVlc3Rpb25pbmdcbiAgICAgICAgc2V0SXNRdWVzdGlvbmluZ0VuYWJsZWQoZmFsc2UpO1xuICAgICAgICByb3VuZEVuZGVkUmVmLmN1cnJlbnQgPSB0cnVlO1xuXG4gICAgICAgIC8vIE9ubHkgYXV0by1zdWJtaXQgaWYgdXNlciBoYXMgd3JpdHRlbiBzb21ldGhpbmcgaW4gdGhlIHNjcmF0Y2hib2FyZFxuICAgICAgICBjb25zdCBzdWJtaXNzaW9uVGV4dCA9IGZpbmFsQW5zd2VyLnRyaW0oKSB8fCBcIk5vIGFuc3dlci5cIjtcblxuICAgICAgICAgICAgZW5zdXJlTm9UeXBpbmdJblByb2dyZXNzKCgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB1c2VyRmluYWxBbnN3ZXI6IE1lc3NhZ2UgPSB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBnZXRVbmlxdWVNZXNzYWdlSWQoKSxcbiAgICAgICAgICAgICAgICAgICAgc2VuZGVyOiAndXNlcicsXG4gICAgICAgICAgICAgICAgICAgIHRleHQ6IGBNeSBmaW5hbCBhbnN3ZXIgaXM6ICR7c3VibWlzc2lvblRleHR9XFxuXFxuTXkgcmVhc29uaW5nOlxcbiR7c2NyYXRjaGJvYXJkQ29udGVudH1gLFxuICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBzZXRNZXNzYWdlcyhwcmV2ID0+IFsuLi5wcmV2LCB1c2VyRmluYWxBbnN3ZXJdKTtcbiAgICAgICAgICAgICAgICBzZXRGaW5hbEFuc3dlcignJyk7XG5cbiAgICAgICAgICAgICAgICAvLyBHZW5lcmF0ZSBldmFsdWF0aW9uXG4gICAgICAgICAgICAgICAgZ2VuZXJhdGVFdmFsdWF0aW9uKHVzZXJGaW5hbEFuc3dlci50ZXh0IHx8IFwiXCIsIGN1cnJlbnRRdWVzdGlvbik7XG4gICAgICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLy8gQWRkIGEgbmV3IGZ1bmN0aW9uIHRvIGdlbmVyYXRlIGFuZCBkaXNwbGF5IHRoZSBvZmZpY2lhbCBzb2x1dGlvblxuICAgIGNvbnN0IGdlbmVyYXRlT2ZmaWNpYWxTb2x1dGlvbiA9IGFzeW5jIChxdWVzdGlvbjogc3RyaW5nKSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiR2VuZXJhdGluZyBvZmZpY2lhbCBzb2x1dGlvblwiKTtcblxuICAgICAgICAvLyBBZGQgc3lzdGVtIG1lc3NhZ2UgYWJvdXQgdGltZSBleHBpcmluZ1xuICAgICAgICBjb25zdCB0aW1lb3V0TWVzc2FnZUlkID0gZ2V0VW5pcXVlTWVzc2FnZUlkKCk7XG4gICAgICAgIHNldE1lc3NhZ2VzKHByZXYgPT4gWy4uLnByZXYsIHtcbiAgICAgICAgICAgIGlkOiB0aW1lb3V0TWVzc2FnZUlkLFxuICAgICAgICAgICAgc2VuZGVyOiAnc3lzdGVtJyxcbiAgICAgICAgICAgIHRleHQ6ICdUaW1lIGhhcyBleHBpcmVkLiBIZXJlIGlzIHRoZSBvZmZpY2lhbCBzb2x1dGlvbjonLFxuICAgICAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgICAgfV0pO1xuXG4gICAgICAgIC8vIEFkZCBhIHR5cGluZyBpbmRpY2F0b3IgZm9yIHRoZSBzb2x1dGlvblxuICAgICAgICBjb25zdCBzb2x1dGlvbk1lc3NhZ2VJZCA9IGdldFVuaXF1ZU1lc3NhZ2VJZCgpO1xuICAgICAgICBzZXRNZXNzYWdlcyhwcmV2ID0+IFsuLi5wcmV2LCB7XG4gICAgICAgICAgICBpZDogc29sdXRpb25NZXNzYWdlSWQsXG4gICAgICAgICAgICBzZW5kZXI6ICdzeXN0ZW0nLFxuICAgICAgICAgICAgdGV4dDogJy4uLicsXG4gICAgICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgICB9XSk7XG5cbiAgICAgICAgLy8gQWRkIHRvIHR5cGluZyBzdGF0ZVxuICAgICAgICBzZXRUeXBpbmdNZXNzYWdlSWRzKHByZXYgPT4gWy4uLnByZXYsIHNvbHV0aW9uTWVzc2FnZUlkXSk7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIEdlbmVyYXRlIHNvbHV0aW9uIHVzaW5nIEFJXG4gICAgICAgICAgICBjb25zdCBzb2x1dGlvblByb21wdCA9IGBZb3UgYXJlIGFuIGV4cGVydCBtYXRoIHRlYWNoZXIgcHJvdmlkaW5nIHRoZSBvZmZpY2lhbCBzb2x1dGlvbiB0byBhIHByb2JsZW0uYDtcblxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhaVNlcnZpY2UuZ2VuZXJhdGVSZXNwb25zZShcbiAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VuZGVyOiAndXNlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBgUHJvYmxlbTogJHtxdWVzdGlvbn1cblxuUGxlYXNlIHByb3ZpZGU6XG4xLiBBIGNsZWFyLCBzdGVwLWJ5LXN0ZXAgc29sdXRpb25cbjIuIFRoZSBmaW5hbCBjb3JyZWN0IGFuc3dlclxuMy4gS2V5IGNvbmNlcHRzIGFuZCB0ZWNobmlxdWVzIHVzZWQgaW4gc29sdmluZyB0aGlzIHByb2JsZW1cblxuRm9ybWF0IHlvdXIgcmVzcG9uc2UgaW4gYSBzdHJ1Y3R1cmVkIHdheSB0aGF0IHNob3dzIHRoZSBjb21wbGV0ZSBzb2x1dGlvbiBwcm9jZXNzLmBcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBzeXN0ZW1Qcm9tcHQ6IHNvbHV0aW9uUHJvbXB0LFxuICAgICAgICAgICAgICAgICAgICBtb2RlbDogY3VycmVudE1vZGVsXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgLy8gUmVwbGFjZSB0eXBpbmcgaW5kaWNhdG9yIHdpdGggYWN0dWFsIHNvbHV0aW9uXG4gICAgICAgICAgICBzZXRNZXNzYWdlcyhwcmV2ID0+IHByZXYubWFwKG1zZyA9PlxuICAgICAgICAgICAgICAgIG1zZy5pZCA9PT0gc29sdXRpb25NZXNzYWdlSWRcbiAgICAgICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5tc2csXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiByZXNwb25zZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgOiBtc2dcbiAgICAgICAgICAgICkpO1xuXG4gICAgICAgICAgICAvLyBBZGQgdG8gdHlwaW5nIHN0YXRlIGZvciBhbmltYXRpb25cbiAgICAgICAgICAgIHNldFR5cGluZ01lc3NhZ2VJZHMocHJldiA9PiBbLi4ucHJldiwgc29sdXRpb25NZXNzYWdlSWRdKTtcblxuICAgICAgICAgICAgLy8gU2V0IGV2YWx1YXRpb24gYXMgY29tcGxldGUgdG8gZW5hYmxlIHRoZSBcIk5leHQgUXVlc3Rpb25cIiBidXR0b25cbiAgICAgICAgICAgIHNldEV2YWx1YXRpb25Db21wbGV0ZSh0cnVlKTtcblxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGdlbmVyYXRpbmcgb2ZmaWNpYWwgc29sdXRpb246XCIsIGVycm9yKTtcblxuICAgICAgICAgICAgLy8gUHJvdmlkZSBhIGZhbGxiYWNrIG1lc3NhZ2VcbiAgICAgICAgICAgIHNldE1lc3NhZ2VzKHByZXYgPT4gcHJldi5tYXAobXNnID0+XG4gICAgICAgICAgICAgICAgbXNnLmlkID09PSBzb2x1dGlvbk1lc3NhZ2VJZFxuICAgICAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLm1zZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IFwiU29ycnksIEkgY291bGRuJ3QgZ2VuZXJhdGUgdGhlIG9mZmljaWFsIHNvbHV0aW9uLiBQbGVhc2UgcHJvY2VlZCB0byB0aGUgbmV4dCBxdWVzdGlvbi5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgOiBtc2dcbiAgICAgICAgICAgICkpO1xuXG4gICAgICAgICAgICBzZXRFdmFsdWF0aW9uQ29tcGxldGUodHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gTW9kaWZ5IHRoZSB0aW1lciB1c2VFZmZlY3QgdG8gdHJpZ2dlciB0aGUgYXV0by1zdWJtaXRcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAodGltZUxlZnQgPD0gMCkge1xuICAgICAgICAgICAgLy8gVGltZSdzIHVwIGxvZ2ljXG4gICAgICAgICAgICBpZiAoaXNRdWVzdGlvbmluZ0VuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBPbmx5IGF1dG8tc3VibWl0IGlmIHF1ZXN0aW9uaW5nIGlzIHN0aWxsIGVuYWJsZWQgKGhhc24ndCBiZWVuIHN1Ym1pdHRlZCB5ZXQpXG4gICAgICAgICAgICAgICAgYXV0b1N1Ym1pdFRpbWVvdXRBbnN3ZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyb3VuZEVuZGVkUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHRpbWVySWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHNldFRpbWVMZWZ0KHByZXZUaW1lID0+IHByZXZUaW1lIC0gMSk7XG4gICAgICAgIH0sIDEwMDApO1xuXG4gICAgICAgIHJldHVybiAoKSA9PiBjbGVhclRpbWVvdXQodGltZXJJZCk7XG4gICAgfSwgW3RpbWVMZWZ0XSk7XG5cbiAgICAvLyBBdXRvLXNjcm9sbCB3aGVuIG1lc3NhZ2VzIGNoYW5nZVxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIC8vIFNldCBhIHNob3J0IHRpbWVvdXQgdG8gZW5zdXJlIHRoZSBET00gaGFzIHVwZGF0ZWRcbiAgICAgICAgc2V0VGltZW91dChzY3JvbGxUb0JvdHRvbSwgNTApO1xuXG4gICAgICAgIC8vIFJlc2V0IHRoZSB1c2VySGFzU2Nyb2xsZWQgZmxhZyB3aGVuIGEgbmV3IG1lc3NhZ2UgaXMgYWRkZWRcbiAgICAgICAgc2V0VXNlckhhc1Njcm9sbGVkKGZhbHNlKTtcbiAgICB9LCBbbWVzc2FnZXMubGVuZ3RoXSk7XG5cbiAgICAvLyBIYW5kbGVyIGZvciB1c2VyIHF1ZXN0aW9uXG4gICAgY29uc3QgaGFuZGxlVXNlclF1ZXN0aW9uID0gKCkgPT4ge1xuICAgICAgICBpZiAoIWlucHV0LnRyaW0oKSB8fCB0eXBpbmdNZXNzYWdlSWRzLmxlbmd0aCA+IDApIHJldHVybjtcblxuICAgICAgICAvLyBSZWNvcmQgdXNlciBhY3Rpdml0eVxuICAgICAgICBzZXRMYXN0VXNlckFjdGl2aXR5VGltZShEYXRlLm5vdygpKTtcblxuICAgICAgICBjb25zdCB1c2VyTWVzc2FnZTogTWVzc2FnZSA9IHtcbiAgICAgICAgICAgIGlkOiBnZXRVbmlxdWVNZXNzYWdlSWQoKSxcbiAgICAgICAgICAgIHNlbmRlcjogJ3VzZXInLFxuICAgICAgICAgICAgdGV4dDogaW5wdXQsXG4gICAgICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgICB9O1xuXG4gICAgICAgIHNldE1lc3NhZ2VzKHByZXYgPT4gWy4uLnByZXYsIHVzZXJNZXNzYWdlXSk7XG4gICAgICAgIHNldElucHV0KCcnKTtcblxuICAgICAgICAvLyBGb3JjZSBzY3JvbGwgdG8gYm90dG9tIHdoZW4gdXNlciBzZW5kcyBhIG1lc3NhZ2VcbiAgICAgICAgZm9yY2VTY3JvbGxUb0JvdHRvbVJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiBzY3JvbGxUb0JvdHRvbSh0cnVlKSwgNTApO1xuXG4gICAgICAgIC8vIENoZWNrIGlmIGEgc3BlY2lmaWMgYm90IHdhcyBtZW50aW9uZWRcbiAgICAgICAgY29uc3QgbWVudGlvbmVkQm90ID0gY2hlY2tGb3JCb3RNZW50aW9uKHVzZXJNZXNzYWdlLnRleHQgfHwgXCJcIik7XG5cbiAgICAgICAgLy8gR2VuZXJhdGUgQUkgcmVzcG9uc2VzIGJhc2VkIG9uIHdoaWNoIGJvdCB3YXMgbWVudGlvbmVkXG4gICAgICAgIGdlbmVyYXRlQUlSZXNwb25zZSh1c2VyTWVzc2FnZS50ZXh0IHx8IFwiXCIsIG1lbnRpb25lZEJvdCk7XG4gICAgfTtcblxuICAgIC8vIEhhbmRsZSBzdWJtaXQvZXZhbHVhdGlvblxuICAgIGNvbnN0IGhhbmRsZVNlbmQgPSAoKSA9PiB7XG4gICAgICAgIGlmICghZmluYWxBbnN3ZXIudHJpbSgpIHx8ICFzY3JhdGNoYm9hcmRDb250ZW50LnRyaW0oKSB8fCB0eXBpbmdNZXNzYWdlSWRzLmxlbmd0aCA+IDApIHJldHVybjtcblxuICAgICAgICAvLyBSZWNvcmQgdXNlciBhY3Rpdml0eVxuICAgICAgICBzZXRMYXN0VXNlckFjdGl2aXR5VGltZShEYXRlLm5vdygpKTtcblxuICAgICAgICBlbnN1cmVOb1R5cGluZ0luUHJvZ3Jlc3MoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdXNlckZpbmFsQW5zd2VyOiBNZXNzYWdlID0ge1xuICAgICAgICAgICAgICAgIGlkOiBnZXRVbmlxdWVNZXNzYWdlSWQoKSxcbiAgICAgICAgICAgICAgICBzZW5kZXI6ICd1c2VyJyxcbiAgICAgICAgICAgICAgICB0ZXh0OiBgTXkgZmluYWwgYW5zd2VyIGlzOiAke2ZpbmFsQW5zd2VyfVxcblxcbk15IHJlYXNvbmluZzpcXG4ke3NjcmF0Y2hib2FyZENvbnRlbnR9YCxcbiAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgc2V0TWVzc2FnZXMocHJldiA9PiBbLi4ucHJldiwgdXNlckZpbmFsQW5zd2VyXSk7XG4gICAgICAgICAgICBzZXRGaW5hbEFuc3dlcignJyk7XG5cbiAgICAgICAgICAgIC8vIEZvcmNlIHNjcm9sbCB0byBib3R0b20gd2hlbiB1c2VyIHN1Ym1pdHMgZmluYWwgYW5zd2VyXG4gICAgICAgICAgICBmb3JjZVNjcm9sbFRvQm90dG9tUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiBzY3JvbGxUb0JvdHRvbSh0cnVlKSwgNTApO1xuXG4gICAgICAgICAgICAvLyBEb24ndCBjbGVhciBzY3JhdGNoYm9hcmQgdG8gYWxsb3cgcmV2aWV3XG4gICAgICAgICAgICAvLyBEaXNhYmxlIGZ1cnRoZXIgcXVlc3Rpb25pbmdcbiAgICAgICAgICAgIHNldElzUXVlc3Rpb25pbmdFbmFibGVkKGZhbHNlKTtcbiAgICAgICAgICAgIHJvdW5kRW5kZWRSZWYuY3VycmVudCA9IHRydWU7XG5cbiAgICAgICAgICAgIC8vIEdlbmVyYXRlIGV2YWx1YXRpb25cbiAgICAgICAgICAgIGdlbmVyYXRlRXZhbHVhdGlvbih1c2VyRmluYWxBbnN3ZXIudGV4dCB8fCBcIlwiLCBjdXJyZW50UXVlc3Rpb24pO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLy8gQUkgcmVzcG9uc2UgZ2VuZXJhdGlvblxuICAgIGNvbnN0IGdlbmVyYXRlQUlSZXNwb25zZSA9IGFzeW5jICh1c2VyTWVzc2FnZTogc3RyaW5nLCBtZW50aW9uZWRCb3Q6IHN0cmluZyB8IG51bGwpID0+IHtcbiAgICAgICAgLy8gRG9uJ3QgZ2VuZXJhdGUgcmVzcG9uc2VzIGlmIHRpbWUncyB1cFxuICAgICAgICBpZiAocm91bmRFbmRlZFJlZi5jdXJyZW50KSByZXR1cm47XG5cbiAgICAgICAgLy8gRGV0ZXJtaW5lIHdoaWNoIGJvdChzKSBzaG91bGQgcmVzcG9uZFxuICAgICAgICBsZXQgc2VsZWN0ZWRBZ2VudEluZGV4OiBudW1iZXI7XG5cbiAgICAgICAgaWYgKG1lbnRpb25lZEJvdCA9PT0gJ2JvYicpIHtcbiAgICAgICAgICAgIC8vIFRlYWNoZXIgQm9iIHNob3VsZCByZXNwb25kXG4gICAgICAgICAgICBzZWxlY3RlZEFnZW50SW5kZXggPSAwOyAvLyBBc3N1bWluZyBCb2IgaXMgdGhlIGZpcnN0IGFnZW50IG5vd1xuICAgICAgICB9IGVsc2UgaWYgKG1lbnRpb25lZEJvdCA9PT0gJ2xvZ2ljJykge1xuICAgICAgICAgICAgLy8gT25seSBMb2dpYyBCb3Qgc2hvdWxkIHJlc3BvbmRcbiAgICAgICAgICAgIHNlbGVjdGVkQWdlbnRJbmRleCA9IDE7IC8vIExvZ2ljIEJvdCBpcyBub3cgc2Vjb25kXG4gICAgICAgIH0gZWxzZSBpZiAobWVudGlvbmVkQm90ID09PSAncGF0dGVybicpIHtcbiAgICAgICAgICAgIC8vIE9ubHkgUGF0dGVybiBCb3Qgc2hvdWxkIHJlc3BvbmRcbiAgICAgICAgICAgIHNlbGVjdGVkQWdlbnRJbmRleCA9IDI7IC8vIFBhdHRlcm4gQm90IGlzIG5vdyB0aGlyZFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gRGVmYXVsdCB0byBCb2IgaWYgbm8gc3BlY2lmaWMgbWVudGlvblxuICAgICAgICAgICAgc2VsZWN0ZWRBZ2VudEluZGV4ID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHNlbGVjdGVkQWdlbnQgPSBhZ2VudHNbc2VsZWN0ZWRBZ2VudEluZGV4XTtcblxuICAgICAgICBjb25zb2xlLmxvZyhgR2VuZXJhdGluZyByZXNwb25zZSBmcm9tICR7c2VsZWN0ZWRBZ2VudC5uYW1lfWApO1xuICAgICAgICBzZXRCb3RUaGlua2luZyh0cnVlKTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gU2hvdyB0eXBpbmcgaW5kaWNhdG9yIHRlbXBvcmFyaWx5XG4gICAgICAgICAgICBjb25zdCB0ZW1wTWVzc2FnZUlkID0gZ2V0VW5pcXVlTWVzc2FnZUlkKCk7XG4gICAgICAgICAgICBzZXRNZXNzYWdlcyhwcmV2ID0+IFsuLi5wcmV2LCB7XG4gICAgICAgICAgICAgICAgaWQ6IHRlbXBNZXNzYWdlSWQsXG4gICAgICAgICAgICAgICAgc2VuZGVyOiAnYWknLFxuICAgICAgICAgICAgICAgIHRleHQ6ICcuLi4nLFxuICAgICAgICAgICAgICAgIGFnZW50SWQ6IHNlbGVjdGVkQWdlbnQuaWQsXG4gICAgICAgICAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgICAgICAgIH1dKTtcblxuICAgICAgICAgICAgLy8gR2VuZXJhdGUgQUkgcmVzcG9uc2UgdXNpbmcgdGhlIGNvcnJlY3QgQVBJIGNhbGxcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYWlTZXJ2aWNlLmdlbmVyYXRlUmVzcG9uc2UoXG4gICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbmRlcjogJ3VzZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogYFRoZSBjdXJyZW50IHByb2JsZW0gaXM6ICR7Y3VycmVudFF1ZXN0aW9ufWBcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IDIsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZW5kZXI6ICd1c2VyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IGBUaGUgc3R1ZGVudCBhc2tlZDogJHt1c2VyTWVzc2FnZX1gXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgc3lzdGVtUHJvbXB0OiBzZWxlY3RlZEFnZW50LnN5c3RlbVByb21wdCxcbiAgICAgICAgICAgICAgICAgICAgbW9kZWw6IGN1cnJlbnRNb2RlbFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIC8vIFJlcGxhY2UgdHlwaW5nIGluZGljYXRvciB3aXRoIGFjdHVhbCBtZXNzYWdlXG4gICAgICAgICAgICBzZXRNZXNzYWdlcyhwcmV2ID0+IHByZXYubWFwKG1zZyA9PlxuICAgICAgICAgICAgICAgIG1zZy5pZCA9PT0gdGVtcE1lc3NhZ2VJZFxuICAgICAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLm1zZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IHJlc3BvbnNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICA6IG1zZ1xuICAgICAgICAgICAgKSk7XG5cbiAgICAgICAgICAgIC8vIEFkZCB0byB0eXBpbmcgc3RhdGVcbiAgICAgICAgICAgIHNldFR5cGluZ01lc3NhZ2VJZHMocHJldiA9PiBbLi4ucHJldiwgdGVtcE1lc3NhZ2VJZF0pO1xuXG4gICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgb3RoZXIgYWdlbnQgc2hvdWxkIGFsc28gcmVzcG9uZFxuICAgICAgICAgICAgLy8gT25seSBpZiBib3RoIGJvdHMgd2VyZSBtZW50aW9uZWQgb3Igbm8gc3BlY2lmaWMgYm90IHdhcyBtZW50aW9uZWRcbiAgICAgICAgICAgIGlmICgobWVudGlvbmVkQm90ID09PSAnYm90aCcgfHwgbWVudGlvbmVkQm90ID09PSBudWxsKSAmJiBNYXRoLnJhbmRvbSgpIDwgMC4zKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3RoZXJBZ2VudEluZGV4ID0gMSAtIHNlbGVjdGVkQWdlbnRJbmRleDtcbiAgICAgICAgICAgICAgICBjb25zdCBvdGhlckFnZW50ID0gYWdlbnRzW290aGVyQWdlbnRJbmRleF07XG5cbiAgICAgICAgICAgICAgICAvLyBXYWl0IGEgYml0IGJlZm9yZSBzZWNvbmQgYWdlbnQgcmVzcG9uZHNcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVGb2xsb3dVcFJlc3BvbnNlKG90aGVyQWdlbnQsIHVzZXJNZXNzYWdlLCByZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgfSwgMTAwMCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBnZW5lcmF0aW5nIEFJIHJlc3BvbnNlOlwiLCBlcnJvcik7XG4gICAgICAgICAgICBzZXRNZXNzYWdlcyhwcmV2ID0+IHByZXYuZmlsdGVyKG1zZyA9PiBtc2cudGV4dCAhPT0gJy4uLicpKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHNldEJvdFRoaW5raW5nKGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBGb2xsb3ctdXAgcmVzcG9uc2UgZ2VuZXJhdGlvblxuICAgIGNvbnN0IGdlbmVyYXRlRm9sbG93VXBSZXNwb25zZSA9IGFzeW5jIChhZ2VudDogYW55LCB1c2VyTWVzc2FnZTogc3RyaW5nLCBmaXJzdEFnZW50UmVzcG9uc2U6IHN0cmluZykgPT4ge1xuICAgICAgICAvLyBEb24ndCBnZW5lcmF0ZSByZXNwb25zZXMgaWYgdGltZSdzIHVwXG4gICAgICAgIGlmIChyb3VuZEVuZGVkUmVmLmN1cnJlbnQpIHJldHVybjtcblxuICAgICAgICBjb25zb2xlLmxvZyhgR2VuZXJhdGluZyBmb2xsb3ctdXAgZnJvbSAke2FnZW50Lm5hbWV9YCk7XG4gICAgICAgIHNldEJvdFRoaW5raW5nKHRydWUpO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBTaG93IHR5cGluZyBpbmRpY2F0b3IgdGVtcG9yYXJpbHlcbiAgICAgICAgICAgIGNvbnN0IHRlbXBNZXNzYWdlSWQgPSBnZXRVbmlxdWVNZXNzYWdlSWQoKTtcbiAgICAgICAgICAgIHNldE1lc3NhZ2VzKHByZXYgPT4gWy4uLnByZXYsIHtcbiAgICAgICAgICAgICAgICBpZDogdGVtcE1lc3NhZ2VJZCxcbiAgICAgICAgICAgICAgICBzZW5kZXI6ICdhaScsXG4gICAgICAgICAgICAgICAgdGV4dDogJy4uLicsXG4gICAgICAgICAgICAgICAgYWdlbnRJZDogYWdlbnQuaWQsXG4gICAgICAgICAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgICAgICAgIH1dKTtcblxuICAgICAgICAgICAgLy8gR2VuZXJhdGUgQUkgcmVzcG9uc2UgdXNpbmcgdGhlIGNvcnJlY3QgQVBJIGNhbGxcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYWlTZXJ2aWNlLmdlbmVyYXRlUmVzcG9uc2UoXG4gICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbmRlcjogJ3VzZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogYFRoZSBjdXJyZW50IHByb2JsZW0gaXM6ICR7Y3VycmVudFF1ZXN0aW9ufWBcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IDIsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZW5kZXI6ICd1c2VyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IGBUaGUgc3R1ZGVudCBhc2tlZDogJHt1c2VyTWVzc2FnZX1gXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiAzLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VuZGVyOiAndXNlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBgVGhlIG90aGVyIEFJIHN0dWRlbnQgcmVzcG9uZGVkOiAke2ZpcnN0QWdlbnRSZXNwb25zZX1gXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiA0LFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VuZGVyOiAndXNlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiAnUHJvdmlkZSB5b3VyIHBlcnNwZWN0aXZlIG9uIHRoaXMgcHJvYmxlbSwgcG9zc2libHkgYnVpbGRpbmcgb24gd2hhdCB0aGUgb3RoZXIgc3R1ZGVudCBzYWlkIG9yIG9mZmVyaW5nIGFuIGFsdGVybmF0aXZlIGFwcHJvYWNoLiBLZWVwIGl0IGNvbnZlcnNhdGlvbmFsIGFuZCBoZWxwZnVsLidcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBzeXN0ZW1Qcm9tcHQ6IGFnZW50LnN5c3RlbVByb21wdCxcbiAgICAgICAgICAgICAgICAgICAgbW9kZWw6IGN1cnJlbnRNb2RlbFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIC8vIFJlcGxhY2UgdHlwaW5nIGluZGljYXRvciB3aXRoIGFjdHVhbCBtZXNzYWdlXG4gICAgICAgICAgICBzZXRNZXNzYWdlcyhwcmV2ID0+IHByZXYubWFwKG1zZyA9PlxuICAgICAgICAgICAgICAgIG1zZy5pZCA9PT0gdGVtcE1lc3NhZ2VJZFxuICAgICAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLm1zZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IHJlc3BvbnNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICA6IG1zZ1xuICAgICAgICAgICAgKSk7XG5cbiAgICAgICAgICAgIC8vIEFkZCB0byB0eXBpbmcgc3RhdGVcbiAgICAgICAgICAgIHNldFR5cGluZ01lc3NhZ2VJZHMocHJldiA9PiBbLi4ucHJldiwgdGVtcE1lc3NhZ2VJZF0pO1xuXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgZ2VuZXJhdGluZyBmb2xsb3ctdXAgcmVzcG9uc2U6XCIsIGVycm9yKTtcbiAgICAgICAgICAgIHNldE1lc3NhZ2VzKHByZXYgPT4gcHJldi5maWx0ZXIobXNnID0+IG1zZy50ZXh0ICE9PSAnLi4uJykpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgc2V0Qm90VGhpbmtpbmcoZmFsc2UpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIFVwZGF0ZSBnZW5lcmF0ZUFJU3R1ZGVudEZpbmFsQW5zd2VycyB0byByZXR1cm4gdGhlIGFuc3dlcnNcbiAgICBjb25zdCBnZW5lcmF0ZUFJU3R1ZGVudEZpbmFsQW5zd2VycyA9IGFzeW5jIChxdWVzdGlvbjogc3RyaW5nKSA9PiB7XG4gICAgICAgIC8vIFJldHVybiB0aGUgZmluYWwgYW5zd2VycyBmb3IgbGF0ZXIgdXNlXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZTx7bG9naWNBbnN3ZXI6IHN0cmluZywgcGF0dGVybkFuc3dlcjogc3RyaW5nfT4oYXN5bmMgKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgIC8vIEdlbmVyYXRlIExvZ2ljIEJvdCdzIGZpbmFsIGFuc3dlciBmaXJzdFxuICAgICAgICAgICAgY29uc3QgbG9naWNNZXNzYWdlSWQgPSBnZXRVbmlxdWVNZXNzYWdlSWQoKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gQWRkIExvZ2ljIEJvdCdzIG1lc3NhZ2Ugd2l0aCB0eXBpbmcgaW5kaWNhdG9yXG4gICAgICAgICAgICBzZXRNZXNzYWdlcyhwcmV2ID0+IFsuLi5wcmV2LCB7XG4gICAgICAgICAgICAgICAgaWQ6IGxvZ2ljTWVzc2FnZUlkLFxuICAgICAgICAgICAgICAgIHNlbmRlcjogXCJhaVwiLFxuICAgICAgICAgICAgICAgIHRleHQ6IFwiSSdtIHdvcmtpbmcgb24gbXkgZmluYWwgYW5zd2VyLi4uXCIsXG4gICAgICAgICAgICAgICAgYWdlbnRJZDogXCJsb2dpY1wiLFxuICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgICAgICAgICB9XSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgLy8gR2VuZXJhdGUgTG9naWMgQm90J3MgZmluYWwgYW5zd2VyIHdpdGggYSBjbGVhciBwcm9tcHRcbiAgICAgICAgICAgICAgICBjb25zdCBsb2dpY1Jlc3BvbnNlID0gYXdhaXQgYWlTZXJ2aWNlLmdlbmVyYXRlUmVzcG9uc2UoXG4gICAgICAgICAgICAgICAgICAgIFt7IFxuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IDEsIFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VuZGVyOiBcInVzZXJcIiwgXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBgUHJvYmxlbTogJHtxdWVzdGlvbn1cXG5cXG5UaGUgdGVhY2hlciBoYXMgYXNrZWQgZm9yIGZpbmFsIGFuc3dlcnMuIEFzIExvZ2ljIEJvdCwgcHJvdmlkZSB5b3VyIEZJTkFMIEFOU1dFUiB0byB0aGlzIHByb2JsZW0uIEluY2x1ZGUgeW91ciBzb2x1dGlvbiBhcHByb2FjaCBhbmQgcmVhc29uaW5nLiBTdGFydCB3aXRoIFwiTXkgZmluYWwgYW5zd2VyIGlzOlwiIGZvbGxvd2VkIGJ5IHlvdXIgc29sdXRpb24uIFRoaXMgaXMgTk9UIGEgcXVlc3Rpb24gb3IgY29tbWVudC5gIFxuICAgICAgICAgICAgICAgICAgICB9XSxcbiAgICAgICAgICAgICAgICAgICAgeyBzeXN0ZW1Qcm9tcHQ6IGFnZW50c1sxXS5zeXN0ZW1Qcm9tcHQsIG1vZGVsOiBjdXJyZW50TW9kZWwgfVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSByZXNwb25zZSBzdGFydHMgd2l0aCBcIk15IGZpbmFsIGFuc3dlciBpczpcIlxuICAgICAgICAgICAgICAgIGNvbnN0IGZvcm1hdHRlZExvZ2ljUmVzcG9uc2UgPSBsb2dpY1Jlc3BvbnNlLnN0YXJ0c1dpdGgoXCJNeSBmaW5hbCBhbnN3ZXIgaXM6XCIpIFxuICAgICAgICAgICAgICAgICAgICA/IGxvZ2ljUmVzcG9uc2UgXG4gICAgICAgICAgICAgICAgICAgIDogYE15IGZpbmFsIGFuc3dlciBpczpcXG5cXG4ke2xvZ2ljUmVzcG9uc2V9YDtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBTdG9yZSBsb2dpYyBhbnN3ZXIgZm9yIHJldHVybiB2YWx1ZVxuICAgICAgICAgICAgICAgIGNvbnN0IGxvZ2ljRmluYWxBbnN3ZXIgPSBmb3JtYXR0ZWRMb2dpY1Jlc3BvbnNlO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBtZXNzYWdlIHdpdGggcmVzcG9uc2VcbiAgICAgICAgICAgICAgICBzZXRNZXNzYWdlcyhwcmV2ID0+IHByZXYubWFwKG1zZyA9PiBcbiAgICAgICAgICAgICAgICAgICAgbXNnLmlkID09PSBsb2dpY01lc3NhZ2VJZCBcbiAgICAgICAgICAgICAgICAgICAgPyB7IFxuICAgICAgICAgICAgICAgICAgICAgICAgLi4ubXNnLCBcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IGZvcm1hdHRlZExvZ2ljUmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ29tcGxldGU6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkxvZ2ljIEJvdCdzIGZpbmFsIGFuc3dlciB0eXBlZCBjb21wbGV0ZWx5XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBhIHRpbWVvdXQgdG8gc2hvdyBQYXR0ZXJuIEJvdCdzIG1lc3NhZ2UgYWZ0ZXIgTG9naWMgQm90IGZpbmlzaGVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdlbmVyYXRlIFBhdHRlcm4gQm90J3MgZmluYWwgYW5zd2VyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhdHRlcm5NZXNzYWdlSWQgPSBnZXRVbmlxdWVNZXNzYWdlSWQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkZCBQYXR0ZXJuIEJvdCdzIG1lc3NhZ2Ugd2l0aCB0eXBpbmcgaW5kaWNhdG9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldE1lc3NhZ2VzKHByZXYgPT4gWy4uLnByZXYsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBwYXR0ZXJuTWVzc2FnZUlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VuZGVyOiBcImFpXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBcIkknbSBmaW5hbGl6aW5nIG15IHNvbHV0aW9uLi4uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZ2VudElkOiBcInBhdHRlcm5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1dKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBHZW5lcmF0ZSBQYXR0ZXJuIEJvdCdzIGFuc3dlciB3aXRoIGEgY2xlYXIgcHJvbXB0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXR0ZXJuUmVzcG9uc2UgPSBhd2FpdCBhaVNlcnZpY2UuZ2VuZXJhdGVSZXNwb25zZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbeyBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IDEsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZW5kZXI6IFwidXNlclwiLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogYFByb2JsZW06ICR7cXVlc3Rpb259XFxuXFxuVGhlIHRlYWNoZXIgaGFzIGFza2VkIGZvciBmaW5hbCBhbnN3ZXJzLiBBcyBQYXR0ZXJuIEJvdCwgcHJvdmlkZSB5b3VyIEZJTkFMIEFOU1dFUiB0byB0aGlzIHByb2JsZW0uIEluY2x1ZGUgeW91ciBzb2x1dGlvbiBhcHByb2FjaCBhbmQgcmVhc29uaW5nLiBTdGFydCB3aXRoIFwiTXkgZmluYWwgYW5zd2VyIGlzOlwiIGZvbGxvd2VkIGJ5IHlvdXIgc29sdXRpb24uIFRoaXMgaXMgTk9UIGEgcXVlc3Rpb24gb3IgY29tbWVudC5gIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1dLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgc3lzdGVtUHJvbXB0OiBhZ2VudHNbMl0uc3lzdGVtUHJvbXB0LCBtb2RlbDogY3VycmVudE1vZGVsIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgcmVzcG9uc2Ugc3RhcnRzIHdpdGggXCJNeSBmaW5hbCBhbnN3ZXIgaXM6XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZvcm1hdHRlZFBhdHRlcm5SZXNwb25zZSA9IHBhdHRlcm5SZXNwb25zZS5zdGFydHNXaXRoKFwiTXkgZmluYWwgYW5zd2VyIGlzOlwiKSBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHBhdHRlcm5SZXNwb25zZSBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGBNeSBmaW5hbCBhbnN3ZXIgaXM6XFxuXFxuJHtwYXR0ZXJuUmVzcG9uc2V9YDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3RvcmUgcGF0dGVybiBhbnN3ZXIgZm9yIHJldHVybiB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGF0dGVybkZpbmFsQW5zd2VyID0gZm9ybWF0dGVkUGF0dGVyblJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBVcGRhdGUgbWVzc2FnZSB3aXRoIHJlc3BvbnNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRNZXNzYWdlcyhwcmV2ID0+IHByZXYubWFwKG1zZyA9PiBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtc2cuaWQgPT09IHBhdHRlcm5NZXNzYWdlSWQgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB7IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5tc2csIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBmb3JtYXR0ZWRQYXR0ZXJuUmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNvbXBsZXRlOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIlBhdHRlcm4gQm90J3MgZmluYWwgYW5zd2VyIHR5cGVkIGNvbXBsZXRlbHlcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBbGwgZG9uZSwgcmVzb2x2ZSB0aGUgcHJvbWlzZSB3aXRoIGJvdGggYW5zd2Vyc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2ljQW5zd2VyOiBsb2dpY0ZpbmFsQW5zd2VyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuQW5zd2VyOiBwYXR0ZXJuRmluYWxBbnN3ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIDEwMDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IG1zZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkZCB0byB0eXBpbmcgc3RhdGUgZm9yIHR5cGV3cml0ZXIgZWZmZWN0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRUeXBpbmdNZXNzYWdlSWRzKHByZXYgPT4gWy4uLnByZXYsIHBhdHRlcm5NZXNzYWdlSWRdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGdlbmVyYXRpbmcgUGF0dGVybiBCb3QgZmluYWwgYW5zd2VyOlwiLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dpY0Fuc3dlcjogbG9naWNGaW5hbEFuc3dlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuQW5zd2VyOiBcIlBhdHRlcm4gQm90IHdhcyB1bmFibGUgdG8gcHJvdmlkZSBhIGZpbmFsIGFuc3dlci5cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgMjAwMCk7IC8vIFdhaXQgMiBzZWNvbmRzIGFmdGVyIExvZ2ljIEJvdCBmaW5pc2hlc1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IFxuICAgICAgICAgICAgICAgICAgICA6IG1zZ1xuICAgICAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIEFkZCB0byB0eXBpbmcgc3RhdGUgZm9yIHR5cGV3cml0ZXIgZWZmZWN0XG4gICAgICAgICAgICAgICAgc2V0VHlwaW5nTWVzc2FnZUlkcyhwcmV2ID0+IFsuLi5wcmV2LCBsb2dpY01lc3NhZ2VJZF0pO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgZ2VuZXJhdGluZyBMb2dpYyBCb3QgZmluYWwgYW5zd2VyOlwiLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2ljQW5zd2VyOiBcIkxvZ2ljIEJvdCB3YXMgdW5hYmxlIHRvIHByb3ZpZGUgYSBmaW5hbCBhbnN3ZXIuXCIsXG4gICAgICAgICAgICAgICAgICAgIHBhdHRlcm5BbnN3ZXI6IFwiUGF0dGVybiBCb3Qgd2FzIHVuYWJsZSB0byBwcm92aWRlIGEgZmluYWwgYW5zd2VyLlwiXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvLyBVcGRhdGUgZ2VuZXJhdGVFdmFsdWF0aW9uIHRvIHVzZSB0aGUgcmV0dXJuZWQgYW5zd2VycyBkaXJlY3RseVxuICAgIGNvbnN0IGdlbmVyYXRlRXZhbHVhdGlvbiA9IGFzeW5jIChmaW5hbEFuc3dlcjogc3RyaW5nLCBxdWVzdGlvbjogc3RyaW5nKSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiR2VuZXJhdGluZyBldmFsdWF0aW9uXCIpO1xuICAgICAgICBzZXRCb3RUaGlua2luZyh0cnVlKTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gQWRkIHN5c3RlbSBtZXNzYWdlIGFib3V0IGV2YWx1YXRpb25cbiAgICAgICAgICAgIGNvbnN0IHRlbXBNZXNzYWdlSWQgPSBnZXRVbmlxdWVNZXNzYWdlSWQoKTtcbiAgICAgICAgICAgIHNldE1lc3NhZ2VzKHByZXYgPT4gWy4uLnByZXYsIHtcbiAgICAgICAgICAgICAgICBpZDogdGVtcE1lc3NhZ2VJZCxcbiAgICAgICAgICAgICAgICBzZW5kZXI6ICdzeXN0ZW0nLFxuICAgICAgICAgICAgICAgIHRleHQ6ICdCb2IgaXMgYXNraW5nIHN0dWRlbnRzIGZvciB0aGVpciBmaW5hbCBhbnN3ZXJzLi4uJyxcbiAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgICAgICAgfV0pO1xuXG4gICAgICAgICAgICAvLyBHZXQgQUkgc3R1ZGVudHMnIGZpbmFsIGFuc3dlcnMgYW5kIFdBSVQgZm9yIHRoZW0gdG8gY29tcGxldGVcbiAgICAgICAgICAgIC8vIE5vdyB3ZSBkaXJlY3RseSBnZXQgdGhlIGFuc3dlcnMgZnJvbSB0aGUgZnVuY3Rpb25cbiAgICAgICAgICAgIGNvbnN0IHsgbG9naWNBbnN3ZXIsIHBhdHRlcm5BbnN3ZXIgfSA9IGF3YWl0IGdlbmVyYXRlQUlTdHVkZW50RmluYWxBbnN3ZXJzKHF1ZXN0aW9uKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJHb3QgZmluYWwgYW5zd2VyczpcIiwgeyBsb2dpY0Fuc3dlciwgcGF0dGVybkFuc3dlciB9KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBzeXN0ZW0gbWVzc2FnZVxuICAgICAgICAgICAgc2V0TWVzc2FnZXMocHJldiA9PiBwcmV2Lm1hcChtc2cgPT4gXG4gICAgICAgICAgICAgICAgbXNnLmlkID09PSB0ZW1wTWVzc2FnZUlkXG4gICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgIC4uLm1zZyxcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogJ0JvYiBpcyBldmFsdWF0aW5nIGFsbCB0aGUgYW5zd2Vycy4uLicsXG4gICAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDogbXNnXG4gICAgICAgICAgICApKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gT25jZSBBSSBzdHVkZW50cyBoYXZlIHN1Ym1pdHRlZCBhbnN3ZXJzLCBnZW5lcmF0ZSBCb2IncyBldmFsdWF0aW9uXG4gICAgICAgICAgICBjb25zdCBib2JNZXNzYWdlSWQgPSBnZXRVbmlxdWVNZXNzYWdlSWQoKTtcbiAgICAgICAgICAgIHNldE1lc3NhZ2VzKHByZXYgPT4gWy4uLnByZXYsIHtcbiAgICAgICAgICAgICAgICBpZDogYm9iTWVzc2FnZUlkLFxuICAgICAgICAgICAgICAgIHNlbmRlcjogXCJhaVwiLFxuICAgICAgICAgICAgICAgIHRleHQ6IFwiLi4uXCIsXG4gICAgICAgICAgICAgICAgYWdlbnRJZDogXCJib2JcIixcbiAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgICAgICAgfV0pO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBHZW5lcmF0ZSBCb2IncyBldmFsdWF0aW9uIG9mIGFsbCBhbnN3ZXJzIC0gdXNpbmcgdGhlIGFuc3dlcnMgd2UgZ290IGRpcmVjdGx5XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFpU2VydmljZS5nZW5lcmF0ZVJlc3BvbnNlKFxuICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZW5kZXI6IFwidXNlclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogYFByb2JsZW06ICR7cXVlc3Rpb259XG4gICAgICAgICAgICAgICAgICAgICAgICBcblN0dWRlbnQncyBmaW5hbCBhbnN3ZXI6ICR7ZmluYWxBbnN3ZXJ9XG5cbkxvZ2ljIEJvdCdzIGZpbmFsIGFuc3dlcjogJHtsb2dpY0Fuc3dlcn1cblxuUGF0dGVybiBCb3QncyBmaW5hbCBhbnN3ZXI6ICR7cGF0dGVybkFuc3dlcn1cblxuQXMgQm9iIHRoZSB0ZWFjaGVyLCBwcm92aWRlOlxuMS4gVGhlIGNvcnJlY3Qgc29sdXRpb24gdG8gdGhpcyBwcm9ibGVtXG4yLiBBbiBldmFsdWF0aW9uIG9mIGFsbCB0aHJlZSBhbnN3ZXJzLCBoaWdobGlnaHRpbmcgc3RyZW5ndGhzIGFuZCBhcmVhcyBmb3IgaW1wcm92ZW1lbnQgaW4gZWFjaFxuMy4gS2V5IGxlYXJuaW5nIHBvaW50cyBmcm9tIHRoaXMgcHJvYmxlbVxuXG5Gb3JtYXQgeW91ciByZXNwb25zZSBpbiBhIGNsZWFyLCBlbmNvdXJhZ2luZyB3YXkgYXMgYSB0ZWFjaGVyIHdvdWxkLmBcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBzeXN0ZW1Qcm9tcHQ6IGFnZW50c1swXS5zeXN0ZW1Qcm9tcHQsXG4gICAgICAgICAgICAgICAgICAgIG1vZGVsOiBjdXJyZW50TW9kZWxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAvLyBSZW1vdmUgdGhlIHN5c3RlbSBtZXNzYWdlXG4gICAgICAgICAgICBzZXRNZXNzYWdlcyhwcmV2ID0+IHByZXYuZmlsdGVyKG1zZyA9PiBtc2cuaWQgIT09IHRlbXBNZXNzYWdlSWQpKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gVXBkYXRlIEJvYidzIGV2YWx1YXRpb24gbWVzc2FnZVxuICAgICAgICAgICAgc2V0TWVzc2FnZXMocHJldiA9PiBwcmV2Lm1hcChtc2cgPT5cbiAgICAgICAgICAgICAgICBtc2cuaWQgPT09IGJvYk1lc3NhZ2VJZFxuICAgICAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLm1zZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IHJlc3BvbnNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICA6IG1zZ1xuICAgICAgICAgICAgKSk7XG5cbiAgICAgICAgICAgIC8vIEFkZCB0byB0eXBpbmcgc3RhdGUgZm9yIHR5cGV3cml0ZXIgZWZmZWN0XG4gICAgICAgICAgICBzZXRUeXBpbmdNZXNzYWdlSWRzKHByZXYgPT4gWy4uLnByZXYsIGJvYk1lc3NhZ2VJZF0pO1xuICAgICAgICAgICAgc2V0RXZhbHVhdGlvbkNvbXBsZXRlKHRydWUpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGdlbmVyYXRpbmcgZXZhbHVhdGlvbjpcIiwgZXJyb3IpO1xuICAgICAgICAgICAgLy8gSGFuZGxlIGVycm9yXG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBzZXRCb3RUaGlua2luZyhmYWxzZSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gQWRkIGEgbmV3IHN0YXRlIHRvIHRyYWNrIHdoaWNoIGJvdCBzcG9rZSBsYXN0XG4gICAgY29uc3QgW2xhc3RTcGVha2luZ0JvdCwgc2V0TGFzdFNwZWFraW5nQm90XSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpO1xuXG4gICAgLy8gQWRkIGEgZ2xvYmFsIHJlZmVyZW5jZSB0byB0cmFjayBwZW5kaW5nIGJvdCBpbnRlcmFjdGlvbnNcbiAgICBjb25zdCBwZW5kaW5nQm90SW50ZXJhY3Rpb25zUmVmID0gdXNlUmVmPEFycmF5PCgpID0+IHZvaWQ+PihbXSk7XG5cbiAgICAvLyBVcGRhdGUgc3RhcnROZXdSb3VuZCB0byB1c2UgdGhlIGNvbXBsZXRlZE1lc3NhZ2VJZHMgZm9yIHNlcXVlbmNpbmdcbiAgICBjb25zdCBzdGFydE5ld1JvdW5kID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAvLyBSZXNldCB0cmFja2luZyBvZiB3aG8gc3Bva2UgbGFzdFxuICAgICAgICBzZXRMYXN0U3BlYWtpbmdCb3QobnVsbCk7XG4gICAgICAgIFxuICAgICAgICAvLyBXYWl0IGZvciBxdWVzdGlvbnMgdG8gbG9hZCBpZiB0aGV5IGhhdmVuJ3QgeWV0XG4gICAgICAgIGlmICghbG9hZGVkUXVlc3Rpb25zKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIldhaXRpbmcgZm9yIHF1ZXN0aW9ucyB0byBsb2FkLi4uXCIpO1xuICAgICAgICAgICAgc2V0VGltZW91dChzdGFydE5ld1JvdW5kLCA1MDApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgd2UndmUgdXNlZCBhbGwgcXVlc3Rpb25zIGFuZCBzaG91bGQgZ28gdG8gdGhlIHRlc3Qgc2NyZWVuXG4gICAgICAgIGlmICh1c2VkUXVlc3Rpb25JbmRpY2VzLmxlbmd0aCA+PSBhbGxRdWVzdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIkFsbCBxdWVzdGlvbnMgdXNlZCwgcmVkaXJlY3RpbmcgdG8gdGVzdCBzY3JlZW5cIik7XG4gICAgICAgICAgICByb3V0ZXIucHVzaCgnL2JyZWFrJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZXNldCBzdGF0ZSBmb3IgbmV3IHJvdW5kXG4gICAgICAgIGNvbnNvbGUubG9nKFwiU3RhcnRpbmcgbmV3IHJvdW5kXCIpO1xuICAgICAgICBzZXRNZXNzYWdlcyhbXSk7XG4gICAgICAgIHNldENvbXBsZXRlZE1lc3NhZ2VJZHMoW10pO1xuICAgICAgICBzZXRUeXBpbmdNZXNzYWdlSWRzKFtdKTtcbiAgICAgICAgc2V0RXZhbHVhdGlvbkNvbXBsZXRlKGZhbHNlKTtcbiAgICAgICAgc2V0U2NyYXRjaGJvYXJkQ29udGVudChcIlwiKTtcbiAgICAgICAgc2V0SW5wdXQoXCJcIik7XG4gICAgICAgIHNldEZpbmFsQW5zd2VyKFwiXCIpO1xuICAgICAgICBzZXRVc2VySGFzU2Nyb2xsZWQoZmFsc2UpO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBGaW5kIGFuIHVudXNlZCBxdWVzdGlvblxuICAgICAgICAgICAgbGV0IG5ld0luZGV4ID0gY3VycmVudFF1ZXN0aW9uSW5kZXg7XG4gICAgICAgICAgICB3aGlsZSAodXNlZFF1ZXN0aW9uSW5kaWNlcy5pbmNsdWRlcyhuZXdJbmRleCkgJiYgdXNlZFF1ZXN0aW9uSW5kaWNlcy5sZW5ndGggPCBhbGxRdWVzdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbmV3SW5kZXggPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBhbGxRdWVzdGlvbnMubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2V0Q3VycmVudFF1ZXN0aW9uSW5kZXgobmV3SW5kZXgpO1xuICAgICAgICAgICAgc2V0VXNlZFF1ZXN0aW9uSW5kaWNlcyhwcmV2ID0+IFsuLi5wcmV2LCBuZXdJbmRleF0pO1xuXG4gICAgICAgICAgICBjb25zdCBzZWxlY3RlZFF1ZXN0aW9uID0gYWxsUXVlc3Rpb25zW25ld0luZGV4XTtcbiAgICAgICAgICAgIHNldEN1cnJlbnRRdWVzdGlvbihzZWxlY3RlZFF1ZXN0aW9uKTtcblxuICAgICAgICAgICAgLy8gQ2xlYXIgYW55IHBlbmRpbmcgaW50ZXJhY3Rpb25zIGZyb20gcHJldmlvdXMgcm91bmRcbiAgICAgICAgICAgIHBlbmRpbmdCb3RJbnRlcmFjdGlvbnNSZWYuY3VycmVudCA9IFtdO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBTZXQgdXAgbWVzc2FnZXMgZm9yIHRoZSBuZXcgcm91bmQgd2l0aCBCb2IgaW50cm9kdWNpbmcgdGhlIHByb2JsZW1cbiAgICAgICAgICAgIGNvbnN0IGJvYkludHJvSWQgPSBnZXRVbmlxdWVNZXNzYWdlSWQoKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgbWVzc2FnZSBvYmplY3Qgd2l0aCBhbiBvbkNvbXBsZXRlIGNhbGxiYWNrXG4gICAgICAgICAgICBjb25zdCBib2JJbnRyb01lc3NhZ2UgPSB7XG4gICAgICAgICAgICAgICAgaWQ6IGJvYkludHJvSWQsXG4gICAgICAgICAgICAgICAgICAgIHNlbmRlcjogXCJhaVwiLFxuICAgICAgICAgICAgICAgIHRleHQ6IGBUb2RheSB3ZSdsbCBiZSB3b3JraW5nIG9uIGFuIGludGVyZXN0aW5nIHByb2JsZW0uIFRha2UgeW91ciB0aW1lIHRvIHVuZGVyc3RhbmQgaXQgYW5kIHRoaW5rIGFib3V0IHlvdXIgYXBwcm9hY2g6XFxuXFxuJHtzZWxlY3RlZFF1ZXN0aW9ufVxcblxcbkNvbnNpZGVyIHdoYXQgY29uY2VwdHMgbWlnaHQgYXBwbHkgaGVyZS4gRmVlbCBmcmVlIHRvIGFzayBxdWVzdGlvbnMgYXMgeW91IHdvcmsuYCxcbiAgICAgICAgICAgICAgICBhZ2VudElkOiBcImJvYlwiLFxuICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgICAgIG9uQ29tcGxldGU6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJCb2IncyBpbnRybyBjb21wbGV0ZWQsIHRyaWdnZXJpbmcgTG9naWMgQm90XCIpO1xuICAgICAgICAgICAgICAgICAgICAvLyBXaGVuIEJvYidzIGludHJvIGlzIGRvbmUgdHlwaW5nLCB0cmlnZ2VyIExvZ2ljIEJvdFxuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlQUlTdHVkZW50Q29tbWVudChcImxvZ2ljXCIsIHNlbGVjdGVkUXVlc3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICB9LCAyMDAwKTsgLy8gU2hvcnQgcGF1c2UgYWZ0ZXIgdHlwaW5nIGNvbXBsZXRlc1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHNldE1lc3NhZ2VzKFtib2JJbnRyb01lc3NhZ2VdKTtcbiAgICAgICAgICAgIHNldFR5cGluZ01lc3NhZ2VJZHMocHJldiA9PiBbLi4ucHJldiwgYm9iSW50cm9JZF0pO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBSZXNldCB0aW1lciBhbmQgb3RoZXIgc3RhdGVcbiAgICAgICAgICAgIHNldFRpbWVMZWZ0KDEyMCk7XG4gICAgICAgICAgICBzZXRJc1F1ZXN0aW9uaW5nRW5hYmxlZCh0cnVlKTtcbiAgICAgICAgICAgIHJvdW5kRW5kZWRSZWYuY3VycmVudCA9IGZhbHNlO1xuXG4gICAgICAgICAgICAvLyBBZnRlciBCb2IgaW50cm9kdWNlcyB0aGUgcHJvYmxlbSwgc2V0IGhpbSBhcyB0aGUgbGFzdCBzcGVha2VyXG4gICAgICAgICAgICBzZXRMYXN0U3BlYWtpbmdCb3QoXCJib2JcIik7XG5cbiAgICAgICAgICAgIC8vIFJlc2V0IGJvdCBxdWVzdGlvbiBjb3VudHNcbiAgICAgICAgICAgIHNldEJvdFF1ZXN0aW9uQ291bnRzKHsgbG9naWM6IDAsIHBhdHRlcm46IDAgfSk7XG5cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBzdGFydGluZyBuZXcgcm91bmQ6XCIsIGVycm9yKTtcblxuICAgICAgICAgICAgLy8gVXNlIGEgZmFsbGJhY2sgcXVlc3Rpb25cbiAgICAgICAgICAgIGNvbnN0IGZhbGxiYWNrUXVlc3Rpb24gPSBcIkluIGhvdyBtYW55IHdheXMgY2FuIDUgZGlzdGluY3QgYm9va3MgYmUgZGlzdHJpYnV0ZWQgdG8gMyBkaXN0aW5jdCBzdHVkZW50cyBzdWNoIHRoYXQgZWFjaCBzdHVkZW50IGdldHMgYXQgbGVhc3Qgb25lIGJvb2s/XCI7XG5cbiAgICAgICAgICAgIHNldEN1cnJlbnRRdWVzdGlvbihmYWxsYmFja1F1ZXN0aW9uKTtcblxuICAgICAgICAgICAgc2V0TWVzc2FnZXMoW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IDEsXG4gICAgICAgICAgICAgICAgICAgIHNlbmRlcjogXCJhaVwiLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0OiBcIlRoZXJlIHdhcyBhbiBpc3N1ZSBsb2FkaW5nIHF1ZXN0aW9ucyBmcm9tIHRoZSBzZXJ2ZXIsIGJ1dCBJIGhhdmUgYSBjb21iaW5hdG9yaWNzIHByb2JsZW0gZm9yIHVzIHRvIHdvcmsgb24uXCIsXG4gICAgICAgICAgICAgICAgICAgIGFnZW50SWQ6IFwibG9naWNcIlxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBpZDogMixcbiAgICAgICAgICAgICAgICAgICAgc2VuZGVyOiBcImFpXCIsXG4gICAgICAgICAgICAgICAgICAgIHRleHQ6IGZhbGxiYWNrUXVlc3Rpb24sXG4gICAgICAgICAgICAgICAgICAgIGFnZW50SWQ6IFwibG9naWNcIlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF0pO1xuXG4gICAgICAgICAgICAvLyBDb250aW51ZSB3aXRoIHRoZSBmYWxsYmFjayBxdWVzdGlvblxuICAgICAgICAgICAgc2V0VGltZUxlZnQoMTIwKTtcbiAgICAgICAgICAgIHNldElzUXVlc3Rpb25pbmdFbmFibGVkKHRydWUpO1xuICAgICAgICAgICAgcm91bmRFbmRlZFJlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gSW5pdGlhbGl6ZSB3aXRoIGZpcnN0IHF1ZXN0aW9uIG9uY2UgcXVlc3Rpb25zIGFyZSBsb2FkZWRcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAobG9hZGVkUXVlc3Rpb25zKSB7XG4gICAgICAgICAgICBzdGFydE5ld1JvdW5kKCk7XG4gICAgICAgIH1cbiAgICB9LCBbbG9hZGVkUXVlc3Rpb25zXSk7XG5cbiAgICAvLyBIYW5kbGUgbmV4dCBxdWVzdGlvbiBidXR0b25cbiAgICBjb25zdCBoYW5kbGVOZXh0UXVlc3Rpb24gPSAoKSA9PiB7XG4gICAgICAgIHNldEV2YWx1YXRpb25Db21wbGV0ZShmYWxzZSk7XG4gICAgICAgIHN0YXJ0TmV3Um91bmQoKTtcbiAgICB9O1xuXG4gICAgLy8gVXBkYXRlIGdlbmVyYXRlQUlTdHVkZW50Q29tbWVudCB0byBmaXggdGhlIGlzc3VlIHdpdGggQm9iIG5vdCByZXNwb25kaW5nXG4gICAgY29uc3QgZ2VuZXJhdGVBSVN0dWRlbnRDb21tZW50ID0gYXN5bmMgKGFnZW50SWQ6IHN0cmluZywgcXVlc3Rpb246IHN0cmluZykgPT4ge1xuICAgICAgICAvLyBEb24ndCBnZW5lcmF0ZSBpZiBzdHVkZW50IGFscmVhZHkgYXNrZWQgZW5vdWdoIHF1ZXN0aW9uc1xuICAgICAgICBpZiAoKGFnZW50SWQgPT09ICdsb2dpYycgJiYgYm90UXVlc3Rpb25Db3VudHMubG9naWMgPj0gMSkgfHwgXG4gICAgICAgICAgICAoYWdlbnRJZCA9PT0gJ3BhdHRlcm4nICYmIGJvdFF1ZXN0aW9uQ291bnRzLnBhdHRlcm4gPj0gMSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgY29uc3QgYWdlbnQgPSBhZ2VudHMuZmluZChhID0+IGEuaWQgPT09IGFnZW50SWQpO1xuICAgICAgICBpZiAoIWFnZW50KSByZXR1cm47XG4gICAgICAgIFxuICAgICAgICBjb25zdCBtZXNzYWdlSWQgPSBnZXRVbmlxdWVNZXNzYWdlSWQoKTtcbiAgICAgICAgXG4gICAgICAgIC8vIEFkZCB0eXBpbmcgaW5kaWNhdG9yIGZpcnN0XG4gICAgICAgIHNldE1lc3NhZ2VzKHByZXYgPT4gWy4uLnByZXYsIHtcbiAgICAgICAgICAgIGlkOiBtZXNzYWdlSWQsXG4gICAgICAgICAgICBzZW5kZXI6IFwiYWlcIixcbiAgICAgICAgICAgIHRleHQ6IFwiLi4uXCIsXG4gICAgICAgICAgICBhZ2VudElkOiBhZ2VudElkLFxuICAgICAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgICAgfV0pO1xuICAgICAgICBcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIEdlbmVyYXRlIGEgYnJpZWYgcXVlc3Rpb24gb3IgY29tbWVudCBhYm91dCB0aGUgcHJvYmxlbVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhaVNlcnZpY2UuZ2VuZXJhdGVSZXNwb25zZShcbiAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VuZGVyOiBcInVzZXJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IGBUaGUgdGVhY2hlciBqdXN0IHByZXNlbnRlZCB0aGlzIHByb2JsZW06ICR7cXVlc3Rpb259XFxuXFxuQXMgYSBzdHVkZW50LCBwcm92aWRlIGEgYnJpZWYgcXVlc3Rpb24gb3Igb2JzZXJ2YXRpb24gYWJvdXQgdGhpcyBwcm9ibGVtLiBLZWVwIGl0IGNvbmNpc2UgKDEtMyBzZW50ZW5jZXMpIGFuZCBkb24ndCBzb2x2ZSBpdC4gQXNrIHNvbWV0aGluZyBpbnNpZ2h0ZnVsIG9yIG1ha2UgYW4gb2JzZXJ2YXRpb24gdGhhdCBzaG93cyB5b3UncmUgdGhpbmtpbmcgYWJvdXQgdGhlIHByb2JsZW0uYFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHN5c3RlbVByb21wdDogYWdlbnQuc3lzdGVtUHJvbXB0ICsgXCJcXG5LZWVwIHlvdXIgcmVzcG9uc2UgdW5kZXIgMyBzZW50ZW5jZXMuIEJlIHZlcnkgY29uY2lzZS5cIixcbiAgICAgICAgICAgICAgICAgICAgbW9kZWw6IGN1cnJlbnRNb2RlbFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIFN0b3JlIHRoZSByZXNwb25zZSBmb3IgbGF0ZXIgdXNlXG4gICAgICAgICAgICBjb25zdCBzdHVkZW50UmVzcG9uc2VUZXh0ID0gcmVzcG9uc2U7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBtZXNzYWdlIHdpdGggcmVzcG9uc2UgYW5kIGFkZCBvbkNvbXBsZXRlIGNhbGxiYWNrXG4gICAgICAgICAgICBzZXRNZXNzYWdlcyhwcmV2ID0+IHByZXYubWFwKG1zZyA9PlxuICAgICAgICAgICAgICAgIG1zZy5pZCA9PT0gbWVzc2FnZUlkXG4gICAgICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4ubXNnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogc3R1ZGVudFJlc3BvbnNlVGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgICAgICAgICAgICAgb25Db21wbGV0ZTogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGAke2FnZW50SWR9J3MgY29tbWVudCBjb21wbGV0ZWQsIHRyaWdnZXJpbmcgdGVhY2hlciByZXNwb25zZWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdoZW4gc3R1ZGVudCdzIG1lc3NhZ2UgaXMgZG9uZSB0eXBpbmcsIHRyaWdnZXIgQm9iJ3MgcmVzcG9uc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVUZWFjaGVyUmVzcG9uc2UocXVlc3Rpb24sIHN0dWRlbnRSZXNwb25zZVRleHQsIGFnZW50SWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIDIwMDApOyAvLyBTaG9ydCBwYXVzZSBhZnRlciB0eXBpbmcgY29tcGxldGVzXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgOiBtc2dcbiAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBBZGQgdG8gdHlwaW5nIHN0YXRlIEFGVEVSIHNldHRpbmcgdGhlIHRleHRcbiAgICAgICAgICAgIHNldFR5cGluZ01lc3NhZ2VJZHMocHJldiA9PiBbLi4ucHJldiwgbWVzc2FnZUlkXSk7XG5cbiAgICAgICAgICAgIC8vIFVwZGF0ZSBxdWVzdGlvbiBjb3VudCBhZnRlciBnZW5lcmF0aW5nIHJlc3BvbnNlXG4gICAgICAgICAgICBpZiAoYWdlbnRJZCA9PT0gJ2xvZ2ljJykge1xuICAgICAgICAgICAgICAgIHNldEJvdFF1ZXN0aW9uQ291bnRzKHByZXYgPT4gKHsgLi4ucHJldiwgbG9naWM6IHByZXYubG9naWMgKyAxIH0pKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYWdlbnRJZCA9PT0gJ3BhdHRlcm4nKSB7XG4gICAgICAgICAgICAgICAgc2V0Qm90UXVlc3Rpb25Db3VudHMocHJldiA9PiAoeyAuLi5wcmV2LCBwYXR0ZXJuOiBwcmV2LnBhdHRlcm4gKyAxIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBnZW5lcmF0aW5nIHN0dWRlbnQgY29tbWVudDpcIiwgZXJyb3IpO1xuICAgICAgICAgICAgLy8gSGFuZGxlIGVycm9yXG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gVXBkYXRlIGdlbmVyYXRlVGVhY2hlclJlc3BvbnNlIHRvIGVuc3VyZSBwcm9wZXIgc2VxdWVuY2luZ1xuICAgIGNvbnN0IGdlbmVyYXRlVGVhY2hlclJlc3BvbnNlID0gYXN5bmMgKHF1ZXN0aW9uOiBzdHJpbmcsIHN0dWRlbnRNZXNzYWdlOiBzdHJpbmcsIHN0dWRlbnRJZDogc3RyaW5nKSA9PiB7XG4gICAgICAgIC8vIERvbid0IGdlbmVyYXRlIGlmIHJvdW5kIGVuZGVkXG4gICAgICAgIGlmIChyb3VuZEVuZGVkUmVmLmN1cnJlbnQpIHJldHVybjtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IG1lc3NhZ2VJZCA9IGdldFVuaXF1ZU1lc3NhZ2VJZCgpO1xuICAgICAgICBcbiAgICAgICAgLy8gQWRkIHR5cGluZyBpbmRpY2F0b3Igd2l0aCBvbkNvbXBsZXRlIGNhbGxiYWNrXG4gICAgICAgIGNvbnN0IHRlYWNoZXJNZXNzYWdlID0ge1xuICAgICAgICAgICAgaWQ6IG1lc3NhZ2VJZCxcbiAgICAgICAgICAgIHNlbmRlcjogXCJhaVwiLFxuICAgICAgICAgICAgdGV4dDogXCIuLi5cIixcbiAgICAgICAgICAgIGFnZW50SWQ6IFwiYm9iXCIsXG4gICAgICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgIG9uQ29tcGxldGU6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkJvYidzIHJlc3BvbnNlIGNvbXBsZXRlZCwgbWF5YmUgdHJpZ2dlcmluZyBuZXh0IHN0dWRlbnRcIik7XG4gICAgICAgICAgICAgICAgLy8gV2hlbiBCb2IncyByZXNwb25zZSBpcyBkb25lIHR5cGluZywgbWF5YmUgdHJpZ2dlciB0aGUgb3RoZXIgc3R1ZGVudFxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IGNvbnRpbnVlIHRoZSBjb252ZXJzYXRpb24gNzAlIG9mIHRoZSB0aW1lXG4gICAgICAgICAgICAgICAgICAgIGlmIChNYXRoLnJhbmRvbSgpIDwgMC43ICYmICFyb3VuZEVuZGVkUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENob29zZSB0aGUgb3RoZXIgc3R1ZGVudCB0byByZXNwb25kXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvdGhlclN0dWRlbnRJZCA9IHN0dWRlbnRJZCA9PT0gXCJsb2dpY1wiID8gXCJwYXR0ZXJuXCIgOiBcImxvZ2ljXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBHZW5lcmF0ZSBhIGZvbGxvdy11cCBjb21tZW50IGZyb20gdGhlIG90aGVyIHN0dWRlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlQUlTdHVkZW50Q29tbWVudChvdGhlclN0dWRlbnRJZCwgcXVlc3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgMjAwMCk7IC8vIFNob3J0IHBhdXNlIGFmdGVyIHR5cGluZyBjb21wbGV0ZXNcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIHNldE1lc3NhZ2VzKHByZXYgPT4gWy4uLnByZXYsIHRlYWNoZXJNZXNzYWdlXSk7XG4gICAgICAgIFxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3Qgc3R1ZGVudE5hbWUgPSBhZ2VudHMuZmluZChhID0+IGEuaWQgPT09IHN0dWRlbnRJZCk/Lm5hbWUgfHwgc3R1ZGVudElkO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBHZW5lcmF0ZSBCb2IncyByZXNwb25zZSB0byB0aGUgc3R1ZGVudFxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhaVNlcnZpY2UuZ2VuZXJhdGVSZXNwb25zZShcbiAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VuZGVyOiBcInVzZXJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IGBQcm9ibGVtOiAke3F1ZXN0aW9ufVxcblxcbiR7c3R1ZGVudE5hbWV9IGFza2VkL2NvbW1lbnRlZDogXCIke3N0dWRlbnRNZXNzYWdlfVwiXFxuXFxuQXMgdGhlIHRlYWNoZXIsIHByb3ZpZGUgYSB0aG91Z2h0ZnVsIGJ1dCBicmllZiByZXNwb25zZSB0aGF0IGd1aWRlcyB3aXRob3V0IGdpdmluZyBhd2F5IHRoZSBzb2x1dGlvbi4gQWNrbm93bGVkZ2UgZ29vZCBpbnNpZ2h0cyBvciBnZW50bHkgcmVkaXJlY3QgaWYgbmVlZGVkLmBcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBzeXN0ZW1Qcm9tcHQ6IGFnZW50cy5maW5kKGEgPT4gYS5pZCA9PT0gXCJib2JcIik/LnN5c3RlbVByb21wdCxcbiAgICAgICAgICAgICAgICAgICAgbW9kZWw6IGN1cnJlbnRNb2RlbFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBtZXNzYWdlIHdpdGggcmVzcG9uc2VcbiAgICAgICAgICAgIHNldE1lc3NhZ2VzKHByZXYgPT4gcHJldi5tYXAobXNnID0+XG4gICAgICAgICAgICAgICAgbXNnLmlkID09PSBtZXNzYWdlSWRcbiAgICAgICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5tc2csXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiByZXNwb25zZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgOiBtc2dcbiAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBBZGQgdG8gdHlwaW5nIHN0YXRlIEFGVEVSIHNldHRpbmcgdGhlIHRleHRcbiAgICAgICAgICAgIHNldFR5cGluZ01lc3NhZ2VJZHMocHJldiA9PiBbLi4ucHJldiwgbWVzc2FnZUlkXSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgZ2VuZXJhdGluZyB0ZWFjaGVyIHJlc3BvbnNlOlwiLCBlcnJvcik7XG4gICAgICAgICAgICAvLyBIYW5kbGUgZXJyb3JcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImgtc2NyZWVuIGJnLWdyYWRpZW50LXRvLWIgZnJvbS1bIzJEMDI3OF0gdG8tWyMwQTAwMURdIHAtNCBmbGV4IGZsZXgtcm93IG92ZXJmbG93LWhpZGRlblwiPlxuICAgICAgICAgICAgey8qIExFRlQgUEFORUwgLSBQcm9ibGVtLCBTdWJtaXNzaW9uLCBTY3JhdGNoYm9hcmQgKi99XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInctMS8yIHByLTIgZmxleCBmbGV4LWNvbCBoLWZ1bGwgb3ZlcmZsb3ctaGlkZGVuXCI+XG4gICAgICAgICAgICAgICAgey8qIFByb2JsZW0gRGlzcGxheSB3aXRoIFRpbWVyIGluc2lkZSAqL31cbiAgICAgICAgICAgICAgICB7Y3VycmVudFF1ZXN0aW9uICYmIChcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJiZy13aGl0ZSBiZy1vcGFjaXR5LTIwIHAtNCByb3VuZGVkLW1kIG1iLTQgYm9yZGVyLTIgYm9yZGVyLXB1cnBsZS00MDBcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBqdXN0aWZ5LWJldHdlZW4gaXRlbXMtc3RhcnQgbWItMlwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxoMiBjbGFzc05hbWU9XCJ0ZXh0LXhsIHRleHQtd2hpdGUgZm9udC1zZW1pYm9sZFwiPlByb2JsZW06PC9oMj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7LyogVGltZXIgaW50ZWdyYXRlZCBpbiBwcm9ibGVtIHN0YXRlbWVudCAqL31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17YHAtMiByb3VuZGVkLWxnICR7dGltZUxlZnQgPiAyMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/ICdiZy1ncmVlbi03MDAnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdGltZUxlZnQgPiAxMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAnYmcteWVsbG93LTYwMCBhbmltYXRlLXB1bHNlJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAnYmctcmVkLTcwMCBhbmltYXRlLXB1bHNlJ30gbWwtNGB9PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInRleHQteGwgZm9udC1tb25vIHRleHQtd2hpdGVcIj57Zm9ybWF0VGltZSh0aW1lTGVmdCl9PC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt0aW1lTGVmdCA8PSAyMCAmJiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInRleHQteHMgdGV4dC13aGl0ZSB0ZXh0LWNlbnRlclwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt0aW1lTGVmdCA8PSAxMCA/IFwiVGltZSBhbG1vc3QgdXAhXCIgOiBcIkZpbmlzaCBzb29uIVwifVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICl9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxwIGNsYXNzTmFtZT1cInRleHQtd2hpdGUgdGV4dC1sZ1wiPntjdXJyZW50UXVlc3Rpb259PC9wPlxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICApfVxuXG4gICAgICAgICAgICAgICAgey8qIEZpbmFsIEFuc3dlciAtIE5vdyBhYm92ZSBzY3JhdGNoYm9hcmQgd2l0aCBlbmhhbmNlZCBzdHlsaW5nICovfVxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYmctd2hpdGUgYmctb3BhY2l0eS0xNSByb3VuZGVkLW1kIHAtNCBtYi00IGJvcmRlci0yIGJvcmRlci1ibHVlLTQwMCBzaGFkb3ctbGdcIj5cbiAgICAgICAgICAgICAgICAgICAgPGgzIGNsYXNzTmFtZT1cInRleHQteGwgdGV4dC13aGl0ZSBmb250LXNlbWlib2xkIG1iLTJcIj5Zb3VyIEZpbmFsIEFuc3dlcjwvaDM+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBmbGV4LWNvbCBzcGFjZS15LTNcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU9XCJ0ZXh0XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZT17ZmluYWxBbnN3ZXJ9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9eyhlKSA9PiBzZXRGaW5hbEFuc3dlcihlLnRhcmdldC52YWx1ZSl9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI9XCJFbnRlciB5b3VyIGZpbmFsIGFuc3dlciBoZXJlLi4uXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJ3LWZ1bGwgYmctd2hpdGUgYmctb3BhY2l0eS0xMCB0ZXh0LXdoaXRlIGJvcmRlciBib3JkZXItZ3JheS02MDAgcm91bmRlZC1tZCBweC0zIHB5LTMgdGV4dC1sZ1wiXG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IGhhbmRsZVNlbmQoKX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNhYmxlZD17IWZpbmFsQW5zd2VyLnRyaW0oKSB8fCAhc2NyYXRjaGJvYXJkQ29udGVudC50cmltKCkgfHwgdHlwaW5nTWVzc2FnZUlkcy5sZW5ndGggPiAwfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17YHB4LTQgcHktMyByb3VuZGVkLW1kIHRleHQtbGcgZm9udC1tZWRpdW0gJHtmaW5hbEFuc3dlci50cmltKCkgJiYgc2NyYXRjaGJvYXJkQ29udGVudC50cmltKCkgJiYgdHlwaW5nTWVzc2FnZUlkcy5sZW5ndGggPT09IDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAnYmctYmx1ZS02MDAgaG92ZXI6YmctYmx1ZS03MDAgdGV4dC13aGl0ZSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAnYmctZ3JheS03MDAgdGV4dC1ncmF5LTQwMCBjdXJzb3Itbm90LWFsbG93ZWQnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1gfVxuICAgICAgICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFN1Ym1pdCBGaW5hbCBBbnN3ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgICAgICAgIHsvKiBTY3JhdGNoYm9hcmQgLSBOb3cgYmVsb3cgZmluYWwgYW5zd2VyIHdpdGggZGlmZmVyZW50IHN0eWxpbmcgKi99XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4LTEgYm9yZGVyIGJvcmRlci1ncmF5LTYwMCByb3VuZGVkLW1kIHAtMyBiZy1ibGFjayBiZy1vcGFjaXR5LTMwIG92ZXJmbG93LWF1dG9cIj5cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGp1c3RpZnktYmV0d2VlbiBtYi0yXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8aDMgY2xhc3NOYW1lPVwidGV4dC13aGl0ZSBmb250LXNlbWlib2xkXCI+Um91Z2ggV29yayAoU2NyYXRjaHBhZCk8L2gzPlxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgPHRleHRhcmVhXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZT17c2NyYXRjaGJvYXJkQ29udGVudH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXsoZSkgPT4gc2V0U2NyYXRjaGJvYXJkQ29udGVudChlLnRhcmdldC52YWx1ZSl9XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJ3LWZ1bGwgaC1bY2FsYygxMDAlLTQwcHgpXSBtaW4taC1bMjAwcHhdIGJnLWJsYWNrIGJnLW9wYWNpdHktNDAgdGV4dC13aGl0ZSBib3JkZXItbm9uZSByb3VuZGVkIHAtMlwiXG4gICAgICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcj1cIlNob3cgeW91ciB3b3JrIGhlcmUuLi4gKGNhbGN1bGF0aW9ucywgcmVhc29uaW5nLCBldGMuKVwiXG4gICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgICAgey8qIFJJR0hUIFBBTkVMIC0gQ2hhdCAqL31cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidy0xLzIgcGwtMiBmbGV4IGZsZXgtY29sIGgtZnVsbFwiPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleC0xIGJnLXdoaXRlIGJnLW9wYWNpdHktMTAgcm91bmRlZC1tZCBmbGV4IGZsZXgtY29sIG92ZXJmbG93LWhpZGRlblwiPlxuICAgICAgICAgICAgICAgICAgICB7LyogQWdlbnQgaW5mbyBmb3IgZ3JvdXAvbXVsdGkgbW9kZXMgKi99XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYmctYmxhY2sgYmctb3BhY2l0eS0zMCBwLTJcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBzcGFjZS14LTNcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7YWdlbnRzLm1hcChhZ2VudCA9PiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYga2V5PXthZ2VudC5pZH0gY2xhc3NOYW1lPVwiZmxleCBpdGVtcy1jZW50ZXJcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxJbWFnZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNyYz17YWdlbnQuYXZhdGFyfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsdD17YWdlbnQubmFtZX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aD17NDB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0PXs0MH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJyb3VuZGVkLWZ1bGwgYm9yZGVyLTIgYm9yZGVyLXdoaXRlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJ0ZXh0LXhzIHRleHQtd2hpdGUgbWwtMlwiPnthZ2VudC5uYW1lfTwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKSl9XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICAgICAgICAgICAgey8qIENoYXQgbWVzc2FnZXMgLSBTY3JvbGxhYmxlICovfVxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXgtMSBwLTQgb3ZlcmZsb3cteS1hdXRvXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZj17Y2hhdENvbnRhaW5lclJlZn1cbiAgICAgICAgICAgICAgICAgICAgICAgIG9uU2Nyb2xsPXtoYW5kbGVTY3JvbGx9PlxuICAgICAgICAgICAgICAgICAgICAgICAge21lc3NhZ2VzLm1hcCgobXNnKSA9PiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXk9e21zZy5pZH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtgbWItNCBmbGV4ICR7bXNnLnNlbmRlciA9PT0gJ3VzZXInID8gJ2p1c3RpZnktZW5kJyA6ICdqdXN0aWZ5LXN0YXJ0J31gfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge21zZy5zZW5kZXIgPT09ICdhaScgJiYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJtci0yIGZsZXgtc2hyaW5rLTBcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8SW1hZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3JjPXthZ2VudHMuZmluZChhID0+IGEuaWQgPT09IG1zZy5hZ2VudElkKT8uYXZhdGFyIHx8ICcvbG9naWNfYXZhdGFyLnBuZyd9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsdD17YWdlbnRzLmZpbmQoYSA9PiBhLmlkID09PSBtc2cuYWdlbnRJZCk/Lm5hbWUgfHwgJ0FJJ31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg9ezQwfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ9ezQwfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJyb3VuZGVkLWZ1bGwgYm9yZGVyLTIgYm9yZGVyLXdoaXRlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICl9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtgbWF4LXctWzc1JV0gcm91bmRlZC1sZyBwLTMgJHttc2cuc2VuZGVyID09PSAndXNlcidcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/ICdiZy1ibHVlLTYwMCB0ZXh0LXdoaXRlJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogbXNnLnNlbmRlciA9PT0gJ3N5c3RlbSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAnYmctcHVycGxlLTcwMCB0ZXh0LXdoaXRlJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6ICdiZy13aGl0ZSBiZy1vcGFjaXR5LTEwIHRleHQtd2hpdGUnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfWB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHttc2cuc2VuZGVyID09PSAnYWknICYmIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInRleHQtc20gdGV4dC1ncmF5LTMwMCBtYi0xIGZvbnQtYm9sZFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7YWdlbnRzLmZpbmQoYSA9PiBhLmlkID09PSBtc2cuYWdlbnRJZCk/Lm5hbWUgfHwgJ0FJJ31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICl9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHttc2cuc2VuZGVyID09PSAnc3lzdGVtJyAmJiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ0ZXh0LXNtIHRleHQtZ3JheS0zMDAgbWItMSBmb250LWJvbGRcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT2ZmaWNpYWwgU29sdXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICl9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt0eXBpbmdNZXNzYWdlSWRzLmluY2x1ZGVzKG1zZy5pZCkgPyAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPFR5cGV3cml0ZXJUZXh0V3JhcHBlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXk9e2B0eXBld3JpdGVyLSR7bXNnLmlkfWB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ9e21zZy50ZXh0fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcGVlZD17MjB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VJZD17bXNnLmlkfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvblR5cGluZ1Byb2dyZXNzPXsocHJvZ3Jlc3MpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdXNlckhhc1Njcm9sbGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsVG9Cb3R0b20oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25UeXBpbmdDb21wbGV0ZT17KCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYE1lc3NhZ2UgJHttc2cuaWR9IGNvbXBsZXRlZCB0eXBpbmdgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGluZ01lc3NhZ2VJZHMuaW5jbHVkZXMobXNnLmlkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRUeXBpbmdNZXNzYWdlSWRzKHByZXYgPT4gcHJldi5maWx0ZXIoaWQgPT4gaWQgIT09IG1zZy5pZCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRDb21wbGV0ZWRNZXNzYWdlSWRzKHByZXYgPT4gWy4uLnByZXYsIG1zZy5pZF0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtc2cub25Db21wbGV0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbXNnLm9uQ29tcGxldGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdXNlckhhc1Njcm9sbGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxUb0JvdHRvbSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgMTAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKSA6IChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIndoaXRlc3BhY2UtcHJlLXdyYXBcIj57bXNnLnRleHR9PC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICkpfVxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBrZXk9XCJtZXNzYWdlcy1lbmRcIiAvPlxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgICAgICAgICAgICB7LyogQ2hhdCBpbnB1dCAoZm9yIHF1ZXN0aW9ucyBvbmx5LCBzZXBhcmF0ZSBmcm9tIGZpbmFsIGFuc3dlcikgKi99XG4gICAgICAgICAgICAgICAgICAgIHtpc1F1ZXN0aW9uaW5nRW5hYmxlZCAmJiAoXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInAtMyBiZy1ibGFjayBiZy1vcGFjaXR5LTMwXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IHNwYWNlLXgtMlwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU9XCJ0ZXh0XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlPXtpbnB1dH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXsoZSkgPT4gc2V0SW5wdXQoZS50YXJnZXQudmFsdWUpfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI9XCJBc2sgYWJvdXQgdGhlIHByb2JsZW0gKG1lbnRpb24gQm9iLCBMb2dpYyBCb3QsIG9yIFBhdHRlcm4gQm90IHNwZWNpZmljYWxseSBpZiBuZWVkZWQpLi4uXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cImZsZXgtMSBiZy13aGl0ZSBiZy1vcGFjaXR5LTEwIHRleHQtd2hpdGUgYm9yZGVyIGJvcmRlci1ncmF5LTcwMCByb3VuZGVkLW1kIHB4LTMgcHktMlwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbktleURvd249eyhlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUua2V5ID09PSAnRW50ZXInICYmICFlLnNoaWZ0S2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlVXNlclF1ZXN0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17aGFuZGxlVXNlclF1ZXN0aW9ufVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWQ9eyFpbnB1dC50cmltKCkgfHwgdHlwaW5nTWVzc2FnZUlkcy5sZW5ndGggPiAwfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtgcHgtNCBweS0yIHJvdW5kZWQtbWQgJHtpbnB1dC50cmltKCkgJiYgdHlwaW5nTWVzc2FnZUlkcy5sZW5ndGggPT09IDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/ICdiZy1ibHVlLTYwMCBob3ZlcjpiZy1ibHVlLTcwMCB0ZXh0LXdoaXRlJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogJ2JnLWdyYXktNzAwIHRleHQtZ3JheS00MDAgY3Vyc29yLW5vdC1hbGxvd2VkJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1gfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBc2tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgKX1cblxuICAgICAgICAgICAgICAgICAgICB7LyogTmV4dCBxdWVzdGlvbiBidXR0b24gKHdoZW4gdGltZSdzIHVwKSAqL31cbiAgICAgICAgICAgICAgICAgICAgeyFpc1F1ZXN0aW9uaW5nRW5hYmxlZCAmJiBldmFsdWF0aW9uQ29tcGxldGUgJiYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJwLTMgYmctYmxhY2sgYmctb3BhY2l0eS0zMCBmbGV4IGp1c3RpZnktY2VudGVyXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXtoYW5kbGVOZXh0UXVlc3Rpb259XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cInB4LTQgcHktMiBiZy1wdXJwbGUtNjAwIGhvdmVyOmJnLXB1cnBsZS03MDAgdGV4dC13aGl0ZSByb3VuZGVkLW1kXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE5leHQgUXVlc3Rpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICk7XG59Il0sIm5hbWVzIjpbInVzZVN0YXRlIiwidXNlRWZmZWN0IiwidXNlUmVmIiwidXNlUm91dGVyIiwiSW1hZ2UiLCJhaVNlcnZpY2UiLCJBSV9NT0RFTFMiLCJUeXBld3JpdGVyVGV4dFdyYXBwZXIiLCJNdWx0aVBhZ2UiLCJyb3V0ZXIiLCJtZXNzYWdlcyIsInNldE1lc3NhZ2VzIiwiY29tcGxldGVkTWVzc2FnZUlkcyIsInNldENvbXBsZXRlZE1lc3NhZ2VJZHMiLCJzY3JhdGNoYm9hcmRDb250ZW50Iiwic2V0U2NyYXRjaGJvYXJkQ29udGVudCIsImlucHV0Iiwic2V0SW5wdXQiLCJmaW5hbEFuc3dlciIsInNldEZpbmFsQW5zd2VyIiwibmV4dE1lc3NhZ2VJZCIsInNldE5leHRNZXNzYWdlSWQiLCJ0eXBpbmdNZXNzYWdlSWRzIiwic2V0VHlwaW5nTWVzc2FnZUlkcyIsImlzUXVlc3Rpb25pbmdFbmFibGVkIiwic2V0SXNRdWVzdGlvbmluZ0VuYWJsZWQiLCJldmFsdWF0aW9uQ29tcGxldGUiLCJzZXRFdmFsdWF0aW9uQ29tcGxldGUiLCJib3RUaGlua2luZyIsInNldEJvdFRoaW5raW5nIiwidXNlckhhc1Njcm9sbGVkIiwic2V0VXNlckhhc1Njcm9sbGVkIiwiY2hhdENvbnRhaW5lclJlZiIsImN1cnJlbnRNb2RlbCIsIkNMQVVERV9IQUlLVSIsImlkIiwibGFzdFVzZXJBY3Rpdml0eVRpbWUiLCJzZXRMYXN0VXNlckFjdGl2aXR5VGltZSIsIkRhdGUiLCJub3ciLCJhbGxRdWVzdGlvbnMiLCJzZXRBbGxRdWVzdGlvbnMiLCJsb2FkZWRRdWVzdGlvbnMiLCJzZXRMb2FkZWRRdWVzdGlvbnMiLCJ0aW1lTGVmdCIsInNldFRpbWVMZWZ0Iiwicm91bmRFbmRlZFJlZiIsImN1cnJlbnRRdWVzdGlvbkluZGV4Iiwic2V0Q3VycmVudFF1ZXN0aW9uSW5kZXgiLCJ1c2VkUXVlc3Rpb25JbmRpY2VzIiwic2V0VXNlZFF1ZXN0aW9uSW5kaWNlcyIsImN1cnJlbnRRdWVzdGlvbiIsInNldEN1cnJlbnRRdWVzdGlvbiIsImFnZW50cyIsIm5hbWUiLCJhdmF0YXIiLCJzeXN0ZW1Qcm9tcHQiLCJib3RRdWVzdGlvbkNvdW50cyIsInNldEJvdFF1ZXN0aW9uQ291bnRzIiwibG9naWMiLCJwYXR0ZXJuIiwiZmV0Y2hRdWVzdGlvbnMiLCJyZXNwb25zZSIsImZldGNoIiwib2siLCJFcnJvciIsImRhdGEiLCJqc29uIiwicXVlc3Rpb25zIiwiT2JqZWN0IiwidmFsdWVzIiwiZmxhdCIsImNvbnNvbGUiLCJsb2ciLCJlcnJvciIsIm5leHRNZXNzYWdlSWRSZWYiLCJnZXRVbmlxdWVNZXNzYWdlSWQiLCJjdXJyZW50IiwiZW5zdXJlTm9UeXBpbmdJblByb2dyZXNzIiwiY2FsbGJhY2siLCJtYXhEZWxheSIsInN0YXJ0VGltZSIsInRyeUNhbGxiYWNrIiwid2FybiIsImxlbmd0aCIsImpvaW4iLCJzZXRUaW1lb3V0IiwiY3VycmVudE1lc3NhZ2VTY3JvbGxPdmVycmlkZVJlZiIsImxhc3RNYW51YWxTY3JvbGxUaW1lUmVmIiwiZm9yY2VTY3JvbGxUb0JvdHRvbVJlZiIsIm1hbnVhbFNjcm9sbE92ZXJyaWRlUmVmIiwic2Nyb2xsVG9Cb3R0b20iLCJmb3JjZSIsImNoYXRDb250YWluZXIiLCJzY3JvbGxUb3AiLCJzY3JvbGxIZWlnaHQiLCJoYW5kbGVTY3JvbGwiLCJpc1Byb2dyYW1tYXRpY1Njcm9sbCIsImlzTmVhckJvdHRvbSIsIk1hdGgiLCJhYnMiLCJjbGllbnRIZWlnaHQiLCJsYXRlc3RNZXNzYWdlIiwic2VuZGVyIiwic2Nyb2xsVGltZSIsImZvcm1hdFRpbWUiLCJzZWNvbmRzIiwibWlucyIsImZsb29yIiwic2VjcyIsImNoZWNrRm9yQm90TWVudGlvbiIsIm1lc3NhZ2UiLCJib2JNZW50aW9uZWQiLCJpbmNsdWRlcyIsImxvZ2ljTWVudGlvbmVkIiwicGF0dGVybk1lbnRpb25lZCIsImF1dG9TdWJtaXRUaW1lb3V0QW5zd2VyIiwic3VibWlzc2lvblRleHQiLCJ0cmltIiwidXNlckZpbmFsQW5zd2VyIiwidGV4dCIsInRpbWVzdGFtcCIsInRvSVNPU3RyaW5nIiwicHJldiIsImdlbmVyYXRlRXZhbHVhdGlvbiIsImdlbmVyYXRlT2ZmaWNpYWxTb2x1dGlvbiIsInF1ZXN0aW9uIiwidGltZW91dE1lc3NhZ2VJZCIsInNvbHV0aW9uTWVzc2FnZUlkIiwic29sdXRpb25Qcm9tcHQiLCJnZW5lcmF0ZVJlc3BvbnNlIiwibW9kZWwiLCJtYXAiLCJtc2ciLCJ0aW1lcklkIiwicHJldlRpbWUiLCJjbGVhclRpbWVvdXQiLCJoYW5kbGVVc2VyUXVlc3Rpb24iLCJ1c2VyTWVzc2FnZSIsIm1lbnRpb25lZEJvdCIsImdlbmVyYXRlQUlSZXNwb25zZSIsImhhbmRsZVNlbmQiLCJzZWxlY3RlZEFnZW50SW5kZXgiLCJzZWxlY3RlZEFnZW50IiwidGVtcE1lc3NhZ2VJZCIsImFnZW50SWQiLCJyYW5kb20iLCJvdGhlckFnZW50SW5kZXgiLCJvdGhlckFnZW50IiwiZ2VuZXJhdGVGb2xsb3dVcFJlc3BvbnNlIiwiZmlsdGVyIiwiYWdlbnQiLCJmaXJzdEFnZW50UmVzcG9uc2UiLCJnZW5lcmF0ZUFJU3R1ZGVudEZpbmFsQW5zd2VycyIsIlByb21pc2UiLCJyZXNvbHZlIiwibG9naWNNZXNzYWdlSWQiLCJsb2dpY1Jlc3BvbnNlIiwiZm9ybWF0dGVkTG9naWNSZXNwb25zZSIsInN0YXJ0c1dpdGgiLCJsb2dpY0ZpbmFsQW5zd2VyIiwib25Db21wbGV0ZSIsInBhdHRlcm5NZXNzYWdlSWQiLCJwYXR0ZXJuUmVzcG9uc2UiLCJmb3JtYXR0ZWRQYXR0ZXJuUmVzcG9uc2UiLCJwYXR0ZXJuRmluYWxBbnN3ZXIiLCJsb2dpY0Fuc3dlciIsInBhdHRlcm5BbnN3ZXIiLCJib2JNZXNzYWdlSWQiLCJsYXN0U3BlYWtpbmdCb3QiLCJzZXRMYXN0U3BlYWtpbmdCb3QiLCJwZW5kaW5nQm90SW50ZXJhY3Rpb25zUmVmIiwic3RhcnROZXdSb3VuZCIsInB1c2giLCJuZXdJbmRleCIsInNlbGVjdGVkUXVlc3Rpb24iLCJib2JJbnRyb0lkIiwiYm9iSW50cm9NZXNzYWdlIiwiZ2VuZXJhdGVBSVN0dWRlbnRDb21tZW50IiwiZmFsbGJhY2tRdWVzdGlvbiIsImhhbmRsZU5leHRRdWVzdGlvbiIsImZpbmQiLCJhIiwibWVzc2FnZUlkIiwic3R1ZGVudFJlc3BvbnNlVGV4dCIsImdlbmVyYXRlVGVhY2hlclJlc3BvbnNlIiwic3R1ZGVudE1lc3NhZ2UiLCJzdHVkZW50SWQiLCJ0ZWFjaGVyTWVzc2FnZSIsIm90aGVyU3R1ZGVudElkIiwic3R1ZGVudE5hbWUiLCJkaXYiLCJjbGFzc05hbWUiLCJoMiIsInAiLCJoMyIsInR5cGUiLCJ2YWx1ZSIsIm9uQ2hhbmdlIiwiZSIsInRhcmdldCIsInBsYWNlaG9sZGVyIiwiYnV0dG9uIiwib25DbGljayIsImRpc2FibGVkIiwidGV4dGFyZWEiLCJzcmMiLCJhbHQiLCJ3aWR0aCIsImhlaWdodCIsInNwYW4iLCJyZWYiLCJvblNjcm9sbCIsInNwZWVkIiwib25UeXBpbmdQcm9ncmVzcyIsInByb2dyZXNzIiwib25UeXBpbmdDb21wbGV0ZSIsIm9uS2V5RG93biIsImtleSIsInNoaWZ0S2V5IiwicHJldmVudERlZmF1bHQiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/multi/page.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/TypewriterText.tsx":
/*!*******************************************!*\
  !*** ./src/components/TypewriterText.tsx ***!
  \*******************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ TypewriterText)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n\nvar _s = $RefreshSig$();\n\nfunction TypewriterText(param) {\n    let { text, speed = 30, onComplete, onCharacterTyped } = param;\n    _s();\n    const [displayText, setDisplayText] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)('');\n    const [isComplete, setIsComplete] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    // Use refs to handle animation state\n    const animationRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const isMountedRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(true);\n    const chunkIndexRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(0);\n    // Store the original text to prevent animation restarts\n    const textRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(text);\n    // Split the text into chunks properly\n    const chunksRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)([]);\n    // Create natural, LLM-like chunks that preserve coherence\n    const createNaturalChunks = (text)=>{\n        // First, create a token-by-token representation\n        // This simulates how an LLM would actually generate text\n        const words = text.split(/(\\s+)/);\n        const chunks = [];\n        // Begin with reasonable chunk size (can be adjusted)\n        let currentChunkSize = 1;\n        let currentChunk = '';\n        let wordIndex = 0;\n        while(wordIndex < words.length){\n            // Determine how many words to include in this burst\n            // This creates a natural rhythm of faster/slower generation\n            if (wordIndex > 0 && wordIndex % 15 === 0) {\n                // Occasionally pause briefly at natural boundaries by creating a small chunk\n                currentChunkSize = 1;\n            } else {\n                // Vary the chunk size to simulate natural generation rhythm\n                // LLMs sometimes generate a burst of words, then slow down at complex points\n                currentChunkSize = Math.floor(Math.random() * 4) + 1;\n            }\n            // Build the current chunk\n            currentChunk += words[wordIndex];\n            // If the current chunk is full, add it to the chunks array\n            if (currentChunk.length >= currentChunkSize) {\n                chunks.push(currentChunk);\n                currentChunk = '';\n            }\n            wordIndex++;\n        }\n        // If there's any remaining text, add it as the last chunk\n        if (currentChunk.length > 0) {\n            chunks.push(currentChunk);\n        }\n        return chunks;\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"TypewriterText.useEffect\": ()=>{\n            // Store the text in ref to make it stable\n            textRef.current = text;\n            // Create chunks for LLM-like generation\n            chunksRef.current = createNaturalChunks(text);\n            // Set mounted flag\n            isMountedRef.current = true;\n            chunkIndexRef.current = 0;\n            setDisplayText('');\n            setIsComplete(false);\n            // Start animation\n            startAnimation();\n            return ({\n                \"TypewriterText.useEffect\": ()=>{\n                    // Clean up animation on unmount\n                    isMountedRef.current = false;\n                    if (animationRef.current) {\n                        cancelAnimationFrame(animationRef.current);\n                    }\n                }\n            })[\"TypewriterText.useEffect\"];\n        }\n    }[\"TypewriterText.useEffect\"], [\n        text\n    ]); // Only restart animation when text actually changes\n    const startAnimation = ()=>{\n        let lastTime = performance.now();\n        const animate = (time)=>{\n            if (!isMountedRef.current) return;\n            const elapsed = time - lastTime;\n            // Randomize the intervals to simulate natural LLM generation\n            // Shorter chunks appear faster, longer chunks need more time\n            const chunk = chunksRef.current[chunkIndexRef.current] || '';\n            const chunkLength = chunk.length;\n            // Base interval on chunk length and add randomness\n            // Faster overall, with variability for natural flow\n            const randomFactor = Math.random() * 0.5 + 0.5; // 0.5 to 1.0\n            const baseInterval = Math.max(20, 100 - speed * 2); // Faster base speed\n            const interval = baseInterval * randomFactor * (chunkLength > 15 ? 1.2 : 0.8);\n            if (elapsed > interval) {\n                lastTime = time;\n                if (chunkIndexRef.current < chunksRef.current.length) {\n                    const nextChunk = chunksRef.current[chunkIndexRef.current];\n                    setDisplayText((prev)=>prev + nextChunk);\n                    chunkIndexRef.current++;\n                    // Call callback for progress tracking\n                    if (onCharacterTyped) {\n                        onCharacterTyped();\n                    }\n                } else if (!isComplete) {\n                    setIsComplete(true);\n                    if (onComplete) {\n                        onComplete();\n                    }\n                    return; // Stop animation\n                }\n            }\n            animationRef.current = requestAnimationFrame(animate);\n        };\n        animationRef.current = requestAnimationFrame(animate);\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"whitespace-pre-wrap\",\n        children: displayText\n    }, void 0, false, {\n        fileName: \"/Users/jonathanvincentius/Documents/UofT/Projects/cowriting-llm-agent/src/components/TypewriterText.tsx\",\n        lineNumber: 145,\n        columnNumber: 10\n    }, this);\n}\n_s(TypewriterText, \"bSvIDq+NMKSaTODgJn1lp1KdzZQ=\");\n_c = TypewriterText;\nvar _c;\n$RefreshReg$(_c, \"TypewriterText\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL1R5cGV3cml0ZXJUZXh0LnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBMkQ7QUFTNUMsU0FBU0ksZUFBZSxLQUtqQjtRQUxpQixFQUNyQ0MsSUFBSSxFQUNKQyxRQUFRLEVBQUUsRUFDVkMsVUFBVSxFQUNWQyxnQkFBZ0IsRUFDSSxHQUxpQjs7SUFNckMsTUFBTSxDQUFDQyxhQUFhQyxlQUFlLEdBQUdULCtDQUFRQSxDQUFDO0lBQy9DLE1BQU0sQ0FBQ1UsWUFBWUMsY0FBYyxHQUFHWCwrQ0FBUUEsQ0FBQztJQUU3QyxxQ0FBcUM7SUFDckMsTUFBTVksZUFBZVYsNkNBQU1BLENBQWdCO0lBQzNDLE1BQU1XLGVBQWVYLDZDQUFNQSxDQUFDO0lBQzVCLE1BQU1ZLGdCQUFnQlosNkNBQU1BLENBQUM7SUFFN0Isd0RBQXdEO0lBQ3hELE1BQU1hLFVBQVViLDZDQUFNQSxDQUFDRTtJQUV2QixzQ0FBc0M7SUFDdEMsTUFBTVksWUFBWWQsNkNBQU1BLENBQVcsRUFBRTtJQUVyQywwREFBMEQ7SUFDMUQsTUFBTWUsc0JBQXNCLENBQUNiO1FBQzNCLGdEQUFnRDtRQUNoRCx5REFBeUQ7UUFDekQsTUFBTWMsUUFBUWQsS0FBS2UsS0FBSyxDQUFDO1FBQ3pCLE1BQU1DLFNBQW1CLEVBQUU7UUFFM0IscURBQXFEO1FBQ3JELElBQUlDLG1CQUFtQjtRQUN2QixJQUFJQyxlQUFlO1FBQ25CLElBQUlDLFlBQVk7UUFFaEIsTUFBT0EsWUFBWUwsTUFBTU0sTUFBTSxDQUFFO1lBQy9CLG9EQUFvRDtZQUNwRCw0REFBNEQ7WUFDNUQsSUFBSUQsWUFBWSxLQUFLQSxZQUFZLE9BQU8sR0FBRztnQkFDekMsNkVBQTZFO2dCQUM3RUYsbUJBQW1CO1lBQ3JCLE9BQU87Z0JBQ0wsNERBQTREO2dCQUM1RCw2RUFBNkU7Z0JBQzdFQSxtQkFBbUJJLEtBQUtDLEtBQUssQ0FBQ0QsS0FBS0UsTUFBTSxLQUFLLEtBQUs7WUFDckQ7WUFFQSwwQkFBMEI7WUFDMUJMLGdCQUFnQkosS0FBSyxDQUFDSyxVQUFVO1lBRWhDLDJEQUEyRDtZQUMzRCxJQUFJRCxhQUFhRSxNQUFNLElBQUlILGtCQUFrQjtnQkFDM0NELE9BQU9RLElBQUksQ0FBQ047Z0JBQ1pBLGVBQWU7WUFDakI7WUFFQUM7UUFDRjtRQUVBLDBEQUEwRDtRQUMxRCxJQUFJRCxhQUFhRSxNQUFNLEdBQUcsR0FBRztZQUMzQkosT0FBT1EsSUFBSSxDQUFDTjtRQUNkO1FBRUEsT0FBT0Y7SUFDVDtJQUVBbkIsZ0RBQVNBO29DQUFDO1lBQ1IsMENBQTBDO1lBQzFDYyxRQUFRYyxPQUFPLEdBQUd6QjtZQUVsQix3Q0FBd0M7WUFDeENZLFVBQVVhLE9BQU8sR0FBR1osb0JBQW9CYjtZQUV4QyxtQkFBbUI7WUFDbkJTLGFBQWFnQixPQUFPLEdBQUc7WUFDdkJmLGNBQWNlLE9BQU8sR0FBRztZQUN4QnBCLGVBQWU7WUFDZkUsY0FBYztZQUVkLGtCQUFrQjtZQUNsQm1CO1lBRUE7NENBQU87b0JBQ0wsZ0NBQWdDO29CQUNoQ2pCLGFBQWFnQixPQUFPLEdBQUc7b0JBQ3ZCLElBQUlqQixhQUFhaUIsT0FBTyxFQUFFO3dCQUN4QkUscUJBQXFCbkIsYUFBYWlCLE9BQU87b0JBQzNDO2dCQUNGOztRQUNGO21DQUFHO1FBQUN6QjtLQUFLLEdBQUcsb0RBQW9EO0lBRWhFLE1BQU0wQixpQkFBaUI7UUFDckIsSUFBSUUsV0FBV0MsWUFBWUMsR0FBRztRQUU5QixNQUFNQyxVQUFVLENBQUNDO1lBQ2YsSUFBSSxDQUFDdkIsYUFBYWdCLE9BQU8sRUFBRTtZQUUzQixNQUFNUSxVQUFVRCxPQUFPSjtZQUV2Qiw2REFBNkQ7WUFDN0QsNkRBQTZEO1lBQzdELE1BQU1NLFFBQVF0QixVQUFVYSxPQUFPLENBQUNmLGNBQWNlLE9BQU8sQ0FBQyxJQUFJO1lBQzFELE1BQU1VLGNBQWNELE1BQU1kLE1BQU07WUFFaEMsbURBQW1EO1lBQ25ELG9EQUFvRDtZQUNwRCxNQUFNZ0IsZUFBZWYsS0FBS0UsTUFBTSxLQUFLLE1BQU0sS0FBSyxhQUFhO1lBQzdELE1BQU1jLGVBQWVoQixLQUFLaUIsR0FBRyxDQUFDLElBQUksTUFBT3JDLFFBQVEsSUFBSyxvQkFBb0I7WUFDMUUsTUFBTXNDLFdBQVdGLGVBQWVELGVBQWdCRCxDQUFBQSxjQUFjLEtBQUssTUFBTSxHQUFFO1lBRTNFLElBQUlGLFVBQVVNLFVBQVU7Z0JBQ3RCWCxXQUFXSTtnQkFFWCxJQUFJdEIsY0FBY2UsT0FBTyxHQUFHYixVQUFVYSxPQUFPLENBQUNMLE1BQU0sRUFBRTtvQkFDcEQsTUFBTW9CLFlBQVk1QixVQUFVYSxPQUFPLENBQUNmLGNBQWNlLE9BQU8sQ0FBQztvQkFDMURwQixlQUFlb0MsQ0FBQUEsT0FBUUEsT0FBT0Q7b0JBQzlCOUIsY0FBY2UsT0FBTztvQkFFckIsc0NBQXNDO29CQUN0QyxJQUFJdEIsa0JBQWtCO3dCQUNwQkE7b0JBQ0Y7Z0JBQ0YsT0FBTyxJQUFJLENBQUNHLFlBQVk7b0JBQ3RCQyxjQUFjO29CQUNkLElBQUlMLFlBQVk7d0JBQ2RBO29CQUNGO29CQUNBLFFBQVEsaUJBQWlCO2dCQUMzQjtZQUNGO1lBRUFNLGFBQWFpQixPQUFPLEdBQUdpQixzQkFBc0JYO1FBQy9DO1FBRUF2QixhQUFhaUIsT0FBTyxHQUFHaUIsc0JBQXNCWDtJQUMvQztJQUVBLHFCQUFPLDhEQUFDWTtRQUFJQyxXQUFVO2tCQUF1QnhDOzs7Ozs7QUFDL0M7R0F4SXdCTDtLQUFBQSIsInNvdXJjZXMiOlsiL1VzZXJzL2pvbmF0aGFudmluY2VudGl1cy9Eb2N1bWVudHMvVW9mVC9Qcm9qZWN0cy9jb3dyaXRpbmctbGxtLWFnZW50L3NyYy9jb21wb25lbnRzL1R5cGV3cml0ZXJUZXh0LnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHsgdXNlU3RhdGUsIHVzZUVmZmVjdCwgdXNlUmVmIH0gZnJvbSAncmVhY3QnO1xuXG5pbnRlcmZhY2UgVHlwZXdyaXRlclRleHRQcm9wcyB7XG4gIHRleHQ6IHN0cmluZztcbiAgc3BlZWQ/OiBudW1iZXI7XG4gIG9uQ29tcGxldGU/OiAoKSA9PiB2b2lkO1xuICBvbkNoYXJhY3RlclR5cGVkPzogKCkgPT4gdm9pZDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gVHlwZXdyaXRlclRleHQoe1xuICB0ZXh0LFxuICBzcGVlZCA9IDMwLFxuICBvbkNvbXBsZXRlLFxuICBvbkNoYXJhY3RlclR5cGVkXG59OiBUeXBld3JpdGVyVGV4dFByb3BzKSB7XG4gIGNvbnN0IFtkaXNwbGF5VGV4dCwgc2V0RGlzcGxheVRleHRdID0gdXNlU3RhdGUoJycpO1xuICBjb25zdCBbaXNDb21wbGV0ZSwgc2V0SXNDb21wbGV0ZV0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIFxuICAvLyBVc2UgcmVmcyB0byBoYW5kbGUgYW5pbWF0aW9uIHN0YXRlXG4gIGNvbnN0IGFuaW1hdGlvblJlZiA9IHVzZVJlZjxudW1iZXIgfCBudWxsPihudWxsKTtcbiAgY29uc3QgaXNNb3VudGVkUmVmID0gdXNlUmVmKHRydWUpO1xuICBjb25zdCBjaHVua0luZGV4UmVmID0gdXNlUmVmKDApO1xuICBcbiAgLy8gU3RvcmUgdGhlIG9yaWdpbmFsIHRleHQgdG8gcHJldmVudCBhbmltYXRpb24gcmVzdGFydHNcbiAgY29uc3QgdGV4dFJlZiA9IHVzZVJlZih0ZXh0KTtcbiAgXG4gIC8vIFNwbGl0IHRoZSB0ZXh0IGludG8gY2h1bmtzIHByb3Blcmx5XG4gIGNvbnN0IGNodW5rc1JlZiA9IHVzZVJlZjxzdHJpbmdbXT4oW10pO1xuICBcbiAgLy8gQ3JlYXRlIG5hdHVyYWwsIExMTS1saWtlIGNodW5rcyB0aGF0IHByZXNlcnZlIGNvaGVyZW5jZVxuICBjb25zdCBjcmVhdGVOYXR1cmFsQ2h1bmtzID0gKHRleHQ6IHN0cmluZyk6IHN0cmluZ1tdID0+IHtcbiAgICAvLyBGaXJzdCwgY3JlYXRlIGEgdG9rZW4tYnktdG9rZW4gcmVwcmVzZW50YXRpb25cbiAgICAvLyBUaGlzIHNpbXVsYXRlcyBob3cgYW4gTExNIHdvdWxkIGFjdHVhbGx5IGdlbmVyYXRlIHRleHRcbiAgICBjb25zdCB3b3JkcyA9IHRleHQuc3BsaXQoLyhcXHMrKS8pO1xuICAgIGNvbnN0IGNodW5rczogc3RyaW5nW10gPSBbXTtcbiAgICBcbiAgICAvLyBCZWdpbiB3aXRoIHJlYXNvbmFibGUgY2h1bmsgc2l6ZSAoY2FuIGJlIGFkanVzdGVkKVxuICAgIGxldCBjdXJyZW50Q2h1bmtTaXplID0gMTtcbiAgICBsZXQgY3VycmVudENodW5rID0gJyc7XG4gICAgbGV0IHdvcmRJbmRleCA9IDA7XG4gICAgXG4gICAgd2hpbGUgKHdvcmRJbmRleCA8IHdvcmRzLmxlbmd0aCkge1xuICAgICAgLy8gRGV0ZXJtaW5lIGhvdyBtYW55IHdvcmRzIHRvIGluY2x1ZGUgaW4gdGhpcyBidXJzdFxuICAgICAgLy8gVGhpcyBjcmVhdGVzIGEgbmF0dXJhbCByaHl0aG0gb2YgZmFzdGVyL3Nsb3dlciBnZW5lcmF0aW9uXG4gICAgICBpZiAod29yZEluZGV4ID4gMCAmJiB3b3JkSW5kZXggJSAxNSA9PT0gMCkge1xuICAgICAgICAvLyBPY2Nhc2lvbmFsbHkgcGF1c2UgYnJpZWZseSBhdCBuYXR1cmFsIGJvdW5kYXJpZXMgYnkgY3JlYXRpbmcgYSBzbWFsbCBjaHVua1xuICAgICAgICBjdXJyZW50Q2h1bmtTaXplID0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFZhcnkgdGhlIGNodW5rIHNpemUgdG8gc2ltdWxhdGUgbmF0dXJhbCBnZW5lcmF0aW9uIHJoeXRobVxuICAgICAgICAvLyBMTE1zIHNvbWV0aW1lcyBnZW5lcmF0ZSBhIGJ1cnN0IG9mIHdvcmRzLCB0aGVuIHNsb3cgZG93biBhdCBjb21wbGV4IHBvaW50c1xuICAgICAgICBjdXJyZW50Q2h1bmtTaXplID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogNCkgKyAxO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBCdWlsZCB0aGUgY3VycmVudCBjaHVua1xuICAgICAgY3VycmVudENodW5rICs9IHdvcmRzW3dvcmRJbmRleF07XG4gICAgICBcbiAgICAgIC8vIElmIHRoZSBjdXJyZW50IGNodW5rIGlzIGZ1bGwsIGFkZCBpdCB0byB0aGUgY2h1bmtzIGFycmF5XG4gICAgICBpZiAoY3VycmVudENodW5rLmxlbmd0aCA+PSBjdXJyZW50Q2h1bmtTaXplKSB7XG4gICAgICAgIGNodW5rcy5wdXNoKGN1cnJlbnRDaHVuayk7XG4gICAgICAgIGN1cnJlbnRDaHVuayA9ICcnO1xuICAgICAgfVxuICAgICAgXG4gICAgICB3b3JkSW5kZXgrKztcbiAgICB9XG4gICAgXG4gICAgLy8gSWYgdGhlcmUncyBhbnkgcmVtYWluaW5nIHRleHQsIGFkZCBpdCBhcyB0aGUgbGFzdCBjaHVua1xuICAgIGlmIChjdXJyZW50Q2h1bmsubGVuZ3RoID4gMCkge1xuICAgICAgY2h1bmtzLnB1c2goY3VycmVudENodW5rKTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIGNodW5rcztcbiAgfTtcbiAgXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgLy8gU3RvcmUgdGhlIHRleHQgaW4gcmVmIHRvIG1ha2UgaXQgc3RhYmxlXG4gICAgdGV4dFJlZi5jdXJyZW50ID0gdGV4dDtcbiAgICBcbiAgICAvLyBDcmVhdGUgY2h1bmtzIGZvciBMTE0tbGlrZSBnZW5lcmF0aW9uXG4gICAgY2h1bmtzUmVmLmN1cnJlbnQgPSBjcmVhdGVOYXR1cmFsQ2h1bmtzKHRleHQpO1xuICAgIFxuICAgIC8vIFNldCBtb3VudGVkIGZsYWdcbiAgICBpc01vdW50ZWRSZWYuY3VycmVudCA9IHRydWU7XG4gICAgY2h1bmtJbmRleFJlZi5jdXJyZW50ID0gMDtcbiAgICBzZXREaXNwbGF5VGV4dCgnJyk7XG4gICAgc2V0SXNDb21wbGV0ZShmYWxzZSk7XG4gICAgXG4gICAgLy8gU3RhcnQgYW5pbWF0aW9uXG4gICAgc3RhcnRBbmltYXRpb24oKTtcbiAgICBcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgLy8gQ2xlYW4gdXAgYW5pbWF0aW9uIG9uIHVubW91bnRcbiAgICAgIGlzTW91bnRlZFJlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICBpZiAoYW5pbWF0aW9uUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUoYW5pbWF0aW9uUmVmLmN1cnJlbnQpO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFt0ZXh0XSk7IC8vIE9ubHkgcmVzdGFydCBhbmltYXRpb24gd2hlbiB0ZXh0IGFjdHVhbGx5IGNoYW5nZXNcbiAgXG4gIGNvbnN0IHN0YXJ0QW5pbWF0aW9uID0gKCkgPT4ge1xuICAgIGxldCBsYXN0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgIFxuICAgIGNvbnN0IGFuaW1hdGUgPSAodGltZTogbnVtYmVyKSA9PiB7XG4gICAgICBpZiAoIWlzTW91bnRlZFJlZi5jdXJyZW50KSByZXR1cm47XG4gICAgICBcbiAgICAgIGNvbnN0IGVsYXBzZWQgPSB0aW1lIC0gbGFzdFRpbWU7XG4gICAgICBcbiAgICAgIC8vIFJhbmRvbWl6ZSB0aGUgaW50ZXJ2YWxzIHRvIHNpbXVsYXRlIG5hdHVyYWwgTExNIGdlbmVyYXRpb25cbiAgICAgIC8vIFNob3J0ZXIgY2h1bmtzIGFwcGVhciBmYXN0ZXIsIGxvbmdlciBjaHVua3MgbmVlZCBtb3JlIHRpbWVcbiAgICAgIGNvbnN0IGNodW5rID0gY2h1bmtzUmVmLmN1cnJlbnRbY2h1bmtJbmRleFJlZi5jdXJyZW50XSB8fCAnJztcbiAgICAgIGNvbnN0IGNodW5rTGVuZ3RoID0gY2h1bmsubGVuZ3RoO1xuICAgICAgXG4gICAgICAvLyBCYXNlIGludGVydmFsIG9uIGNodW5rIGxlbmd0aCBhbmQgYWRkIHJhbmRvbW5lc3NcbiAgICAgIC8vIEZhc3RlciBvdmVyYWxsLCB3aXRoIHZhcmlhYmlsaXR5IGZvciBuYXR1cmFsIGZsb3dcbiAgICAgIGNvbnN0IHJhbmRvbUZhY3RvciA9IE1hdGgucmFuZG9tKCkgKiAwLjUgKyAwLjU7IC8vIDAuNSB0byAxLjBcbiAgICAgIGNvbnN0IGJhc2VJbnRlcnZhbCA9IE1hdGgubWF4KDIwLCAxMDAgLSAoc3BlZWQgKiAyKSk7IC8vIEZhc3RlciBiYXNlIHNwZWVkXG4gICAgICBjb25zdCBpbnRlcnZhbCA9IGJhc2VJbnRlcnZhbCAqIHJhbmRvbUZhY3RvciAqIChjaHVua0xlbmd0aCA+IDE1ID8gMS4yIDogMC44KTtcbiAgICAgIFxuICAgICAgaWYgKGVsYXBzZWQgPiBpbnRlcnZhbCkge1xuICAgICAgICBsYXN0VGltZSA9IHRpbWU7XG4gICAgICAgIFxuICAgICAgICBpZiAoY2h1bmtJbmRleFJlZi5jdXJyZW50IDwgY2h1bmtzUmVmLmN1cnJlbnQubGVuZ3RoKSB7XG4gICAgICAgICAgY29uc3QgbmV4dENodW5rID0gY2h1bmtzUmVmLmN1cnJlbnRbY2h1bmtJbmRleFJlZi5jdXJyZW50XTtcbiAgICAgICAgICBzZXREaXNwbGF5VGV4dChwcmV2ID0+IHByZXYgKyBuZXh0Q2h1bmspO1xuICAgICAgICAgIGNodW5rSW5kZXhSZWYuY3VycmVudCsrO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIENhbGwgY2FsbGJhY2sgZm9yIHByb2dyZXNzIHRyYWNraW5nXG4gICAgICAgICAgaWYgKG9uQ2hhcmFjdGVyVHlwZWQpIHtcbiAgICAgICAgICAgIG9uQ2hhcmFjdGVyVHlwZWQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoIWlzQ29tcGxldGUpIHtcbiAgICAgICAgICBzZXRJc0NvbXBsZXRlKHRydWUpO1xuICAgICAgICAgIGlmIChvbkNvbXBsZXRlKSB7XG4gICAgICAgICAgICBvbkNvbXBsZXRlKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjsgLy8gU3RvcCBhbmltYXRpb25cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICBhbmltYXRpb25SZWYuY3VycmVudCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShhbmltYXRlKTtcbiAgICB9O1xuICAgIFxuICAgIGFuaW1hdGlvblJlZi5jdXJyZW50ID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGUpO1xuICB9O1xuICBcbiAgcmV0dXJuIDxkaXYgY2xhc3NOYW1lPVwid2hpdGVzcGFjZS1wcmUtd3JhcFwiPntkaXNwbGF5VGV4dH08L2Rpdj47XG59Il0sIm5hbWVzIjpbIlJlYWN0IiwidXNlU3RhdGUiLCJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJUeXBld3JpdGVyVGV4dCIsInRleHQiLCJzcGVlZCIsIm9uQ29tcGxldGUiLCJvbkNoYXJhY3RlclR5cGVkIiwiZGlzcGxheVRleHQiLCJzZXREaXNwbGF5VGV4dCIsImlzQ29tcGxldGUiLCJzZXRJc0NvbXBsZXRlIiwiYW5pbWF0aW9uUmVmIiwiaXNNb3VudGVkUmVmIiwiY2h1bmtJbmRleFJlZiIsInRleHRSZWYiLCJjaHVua3NSZWYiLCJjcmVhdGVOYXR1cmFsQ2h1bmtzIiwid29yZHMiLCJzcGxpdCIsImNodW5rcyIsImN1cnJlbnRDaHVua1NpemUiLCJjdXJyZW50Q2h1bmsiLCJ3b3JkSW5kZXgiLCJsZW5ndGgiLCJNYXRoIiwiZmxvb3IiLCJyYW5kb20iLCJwdXNoIiwiY3VycmVudCIsInN0YXJ0QW5pbWF0aW9uIiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJsYXN0VGltZSIsInBlcmZvcm1hbmNlIiwibm93IiwiYW5pbWF0ZSIsInRpbWUiLCJlbGFwc2VkIiwiY2h1bmsiLCJjaHVua0xlbmd0aCIsInJhbmRvbUZhY3RvciIsImJhc2VJbnRlcnZhbCIsIm1heCIsImludGVydmFsIiwibmV4dENodW5rIiwicHJldiIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImRpdiIsImNsYXNzTmFtZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/TypewriterText.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/TypewriterTextWrapper.tsx":
/*!**************************************************!*\
  !*** ./src/components/TypewriterTextWrapper.tsx ***!
  \**************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _TypewriterText__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./TypewriterText */ \"(app-pages-browser)/./src/components/TypewriterText.tsx\");\n\nvar _s = $RefreshSig$();\n\n\n// This component \"locks in\" the text and prevents parent re-renders from restarting the animation\nconst TypewriterTextWrapper = (param)=>{\n    let { text, content, speed = 50, messageId, onTypingProgress, onTypingComplete } = param;\n    _s();\n    // Use refs to track animation state to prevent race conditions\n    const isTypingRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(true);\n    const isCompletedRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n    const isMountedRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(true);\n    // Ensure text is a string - prioritize content if both are provided\n    const displayText = content || text || \"\";\n    const safeText = typeof displayText === 'string' ? displayText : \"\";\n    // Use a ref to store the original text to prevent animation restart on re-renders\n    const textRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(safeText);\n    // Track progress for callbacks\n    const [progress, setProgress] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);\n    const totalLengthRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(safeText.length);\n    const progressCounterRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(0);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"TypewriterTextWrapper.useEffect\": ()=>{\n            // Store original text reference\n            textRef.current = safeText;\n            totalLengthRef.current = safeText.length;\n            // Set mounted flag\n            isMountedRef.current = true;\n            isTypingRef.current = true;\n            isCompletedRef.current = false;\n            progressCounterRef.current = 0;\n            return ({\n                \"TypewriterTextWrapper.useEffect\": ()=>{\n                    // Cleanup on unmount\n                    isMountedRef.current = false;\n                }\n            })[\"TypewriterTextWrapper.useEffect\"];\n        }\n    }[\"TypewriterTextWrapper.useEffect\"], [\n        safeText\n    ]);\n    const handleChunkTyped = ()=>{\n        if (!isMountedRef.current || !isTypingRef.current) return;\n        // Increment progress counter - estimate based on chunks\n        // We'll increment by approx. 5-10% each time a chunk is typed\n        progressCounterRef.current += Math.min(10, Math.floor(totalLengthRef.current * 0.08));\n        // Calculate progress as a percentage and clamp it to 100%\n        const newProgress = Math.min(100, Math.floor(progressCounterRef.current * 100 / totalLengthRef.current));\n        setProgress(newProgress);\n        // Call progress callback\n        if (onTypingProgress) {\n            onTypingProgress(newProgress);\n        }\n    };\n    const handleComplete = ()=>{\n        if (!isMountedRef.current || isCompletedRef.current) return;\n        // Mark as completed to prevent duplicate callbacks\n        isTypingRef.current = false;\n        isCompletedRef.current = true;\n        // Update progress to 100%\n        setProgress(100);\n        // Call complete callback\n        if (onTypingComplete) {\n            onTypingComplete();\n        }\n    };\n    // Use the original text to prevent animation restart\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_TypewriterText__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n        text: textRef.current,\n        speed: speed,\n        onComplete: handleComplete,\n        onCharacterTyped: handleChunkTyped\n    }, \"typewriter-\".concat(messageId), false, {\n        fileName: \"/Users/jonathanvincentius/Documents/UofT/Projects/cowriting-llm-agent/src/components/TypewriterTextWrapper.tsx\",\n        lineNumber: 91,\n        columnNumber: 9\n    }, undefined);\n};\n_s(TypewriterTextWrapper, \"LfiCSIGlQCFg8zlTTFL0nHyyg/o=\");\n_c = TypewriterTextWrapper;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (TypewriterTextWrapper);\nvar _c;\n$RefreshReg$(_c, \"TypewriterTextWrapper\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL1R5cGV3cml0ZXJUZXh0V3JhcHBlci50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFpRTtBQUNuQjtBQVc5QyxrR0FBa0c7QUFDbEcsTUFBTUssd0JBQXdCO1FBQUMsRUFDM0JDLElBQUksRUFDSkMsT0FBTyxFQUNQQyxRQUFRLEVBQUUsRUFDVkMsU0FBUyxFQUNUQyxnQkFBZ0IsRUFDaEJDLGdCQUFnQixFQUNTOztJQUN6QiwrREFBK0Q7SUFDL0QsTUFBTUMsY0FBY1QsNkNBQU1BLENBQUM7SUFDM0IsTUFBTVUsaUJBQWlCViw2Q0FBTUEsQ0FBQztJQUM5QixNQUFNVyxlQUFlWCw2Q0FBTUEsQ0FBQztJQUU1QixvRUFBb0U7SUFDcEUsTUFBTVksY0FBY1IsV0FBV0QsUUFBUTtJQUN2QyxNQUFNVSxXQUFXLE9BQU9ELGdCQUFnQixXQUFXQSxjQUFjO0lBRWpFLGtGQUFrRjtJQUNsRixNQUFNRSxVQUFVZCw2Q0FBTUEsQ0FBQ2E7SUFFdkIsK0JBQStCO0lBQy9CLE1BQU0sQ0FBQ0UsVUFBVUMsWUFBWSxHQUFHakIsK0NBQVFBLENBQUM7SUFDekMsTUFBTWtCLGlCQUFpQmpCLDZDQUFNQSxDQUFDYSxTQUFTSyxNQUFNO0lBQzdDLE1BQU1DLHFCQUFxQm5CLDZDQUFNQSxDQUFDO0lBRWxDRixnREFBU0E7MkNBQUM7WUFDTixnQ0FBZ0M7WUFDaENnQixRQUFRTSxPQUFPLEdBQUdQO1lBQ2xCSSxlQUFlRyxPQUFPLEdBQUdQLFNBQVNLLE1BQU07WUFFeEMsbUJBQW1CO1lBQ25CUCxhQUFhUyxPQUFPLEdBQUc7WUFDdkJYLFlBQVlXLE9BQU8sR0FBRztZQUN0QlYsZUFBZVUsT0FBTyxHQUFHO1lBQ3pCRCxtQkFBbUJDLE9BQU8sR0FBRztZQUU3QjttREFBTztvQkFDSCxxQkFBcUI7b0JBQ3JCVCxhQUFhUyxPQUFPLEdBQUc7Z0JBQzNCOztRQUNKOzBDQUFHO1FBQUNQO0tBQVM7SUFFYixNQUFNUSxtQkFBbUI7UUFDckIsSUFBSSxDQUFDVixhQUFhUyxPQUFPLElBQUksQ0FBQ1gsWUFBWVcsT0FBTyxFQUFFO1FBRW5ELHdEQUF3RDtRQUN4RCw4REFBOEQ7UUFDOURELG1CQUFtQkMsT0FBTyxJQUFJRSxLQUFLQyxHQUFHLENBQUMsSUFBSUQsS0FBS0UsS0FBSyxDQUFDUCxlQUFlRyxPQUFPLEdBQUc7UUFFL0UsMERBQTBEO1FBQzFELE1BQU1LLGNBQWNILEtBQUtDLEdBQUcsQ0FBQyxLQUFLRCxLQUFLRSxLQUFLLENBQUNMLG1CQUFtQkMsT0FBTyxHQUFHLE1BQU1ILGVBQWVHLE9BQU87UUFDdEdKLFlBQVlTO1FBRVoseUJBQXlCO1FBQ3pCLElBQUlsQixrQkFBa0I7WUFDbEJBLGlCQUFpQmtCO1FBQ3JCO0lBQ0o7SUFFQSxNQUFNQyxpQkFBaUI7UUFDbkIsSUFBSSxDQUFDZixhQUFhUyxPQUFPLElBQUlWLGVBQWVVLE9BQU8sRUFBRTtRQUVyRCxtREFBbUQ7UUFDbkRYLFlBQVlXLE9BQU8sR0FBRztRQUN0QlYsZUFBZVUsT0FBTyxHQUFHO1FBRXpCLDBCQUEwQjtRQUMxQkosWUFBWTtRQUVaLHlCQUF5QjtRQUN6QixJQUFJUixrQkFBa0I7WUFDbEJBO1FBQ0o7SUFDSjtJQUVBLHFEQUFxRDtJQUNyRCxxQkFDSSw4REFBQ1AsdURBQWNBO1FBRVhFLE1BQU1XLFFBQVFNLE9BQU87UUFDckJmLE9BQU9BO1FBQ1BzQixZQUFZRDtRQUNaRSxrQkFBa0JQO09BSmIsY0FBd0IsT0FBVmY7Ozs7O0FBTy9CO0dBckZNSjtLQUFBQTtBQXVGTixpRUFBZUEscUJBQXFCQSxFQUFDIiwic291cmNlcyI6WyIvVXNlcnMvam9uYXRoYW52aW5jZW50aXVzL0RvY3VtZW50cy9Vb2ZUL1Byb2plY3RzL2Nvd3JpdGluZy1sbG0tYWdlbnQvc3JjL2NvbXBvbmVudHMvVHlwZXdyaXRlclRleHRXcmFwcGVyLnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHsgdXNlRWZmZWN0LCB1c2VTdGF0ZSwgdXNlUmVmLCBtZW1vIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IFR5cGV3cml0ZXJUZXh0IGZyb20gJy4vVHlwZXdyaXRlclRleHQnO1xuXG5pbnRlcmZhY2UgVHlwZXdyaXRlclRleHRXcmFwcGVyUHJvcHMge1xuICAgIHRleHQ/OiBzdHJpbmc7XG4gICAgY29udGVudD86IHN0cmluZzsgLy8gQWRkIGNvbnRlbnQgYXMgYW4gYWx0ZXJuYXRpdmUgdG8gdGV4dFxuICAgIHNwZWVkPzogbnVtYmVyO1xuICAgIG1lc3NhZ2VJZDogbnVtYmVyO1xuICAgIG9uVHlwaW5nUHJvZ3Jlc3M/OiAocHJvZ3Jlc3M6IG51bWJlcikgPT4gdm9pZDtcbiAgICBvblR5cGluZ0NvbXBsZXRlPzogKCkgPT4gdm9pZDtcbn1cblxuLy8gVGhpcyBjb21wb25lbnQgXCJsb2NrcyBpblwiIHRoZSB0ZXh0IGFuZCBwcmV2ZW50cyBwYXJlbnQgcmUtcmVuZGVycyBmcm9tIHJlc3RhcnRpbmcgdGhlIGFuaW1hdGlvblxuY29uc3QgVHlwZXdyaXRlclRleHRXcmFwcGVyID0gKHtcbiAgICB0ZXh0LFxuICAgIGNvbnRlbnQsXG4gICAgc3BlZWQgPSA1MCwgLy8gTXVjaCBmYXN0ZXIgc3BlZWQgZm9yIExMTS1saWtlIGdlbmVyYXRpb25cbiAgICBtZXNzYWdlSWQsXG4gICAgb25UeXBpbmdQcm9ncmVzcyxcbiAgICBvblR5cGluZ0NvbXBsZXRlXG59OiBUeXBld3JpdGVyVGV4dFdyYXBwZXJQcm9wcykgPT4ge1xuICAgIC8vIFVzZSByZWZzIHRvIHRyYWNrIGFuaW1hdGlvbiBzdGF0ZSB0byBwcmV2ZW50IHJhY2UgY29uZGl0aW9uc1xuICAgIGNvbnN0IGlzVHlwaW5nUmVmID0gdXNlUmVmKHRydWUpO1xuICAgIGNvbnN0IGlzQ29tcGxldGVkUmVmID0gdXNlUmVmKGZhbHNlKTtcbiAgICBjb25zdCBpc01vdW50ZWRSZWYgPSB1c2VSZWYodHJ1ZSk7XG4gICAgXG4gICAgLy8gRW5zdXJlIHRleHQgaXMgYSBzdHJpbmcgLSBwcmlvcml0aXplIGNvbnRlbnQgaWYgYm90aCBhcmUgcHJvdmlkZWRcbiAgICBjb25zdCBkaXNwbGF5VGV4dCA9IGNvbnRlbnQgfHwgdGV4dCB8fCBcIlwiO1xuICAgIGNvbnN0IHNhZmVUZXh0ID0gdHlwZW9mIGRpc3BsYXlUZXh0ID09PSAnc3RyaW5nJyA/IGRpc3BsYXlUZXh0IDogXCJcIjtcbiAgICBcbiAgICAvLyBVc2UgYSByZWYgdG8gc3RvcmUgdGhlIG9yaWdpbmFsIHRleHQgdG8gcHJldmVudCBhbmltYXRpb24gcmVzdGFydCBvbiByZS1yZW5kZXJzXG4gICAgY29uc3QgdGV4dFJlZiA9IHVzZVJlZihzYWZlVGV4dCk7XG4gICAgXG4gICAgLy8gVHJhY2sgcHJvZ3Jlc3MgZm9yIGNhbGxiYWNrc1xuICAgIGNvbnN0IFtwcm9ncmVzcywgc2V0UHJvZ3Jlc3NdID0gdXNlU3RhdGUoMCk7XG4gICAgY29uc3QgdG90YWxMZW5ndGhSZWYgPSB1c2VSZWYoc2FmZVRleHQubGVuZ3RoKTtcbiAgICBjb25zdCBwcm9ncmVzc0NvdW50ZXJSZWYgPSB1c2VSZWYoMCk7XG4gICAgXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgLy8gU3RvcmUgb3JpZ2luYWwgdGV4dCByZWZlcmVuY2VcbiAgICAgICAgdGV4dFJlZi5jdXJyZW50ID0gc2FmZVRleHQ7XG4gICAgICAgIHRvdGFsTGVuZ3RoUmVmLmN1cnJlbnQgPSBzYWZlVGV4dC5sZW5ndGg7XG4gICAgICAgIFxuICAgICAgICAvLyBTZXQgbW91bnRlZCBmbGFnXG4gICAgICAgIGlzTW91bnRlZFJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgaXNUeXBpbmdSZWYuY3VycmVudCA9IHRydWU7XG4gICAgICAgIGlzQ29tcGxldGVkUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgcHJvZ3Jlc3NDb3VudGVyUmVmLmN1cnJlbnQgPSAwO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIC8vIENsZWFudXAgb24gdW5tb3VudFxuICAgICAgICAgICAgaXNNb3VudGVkUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgfTtcbiAgICB9LCBbc2FmZVRleHRdKTtcbiAgICBcbiAgICBjb25zdCBoYW5kbGVDaHVua1R5cGVkID0gKCkgPT4ge1xuICAgICAgICBpZiAoIWlzTW91bnRlZFJlZi5jdXJyZW50IHx8ICFpc1R5cGluZ1JlZi5jdXJyZW50KSByZXR1cm47XG4gICAgICAgIFxuICAgICAgICAvLyBJbmNyZW1lbnQgcHJvZ3Jlc3MgY291bnRlciAtIGVzdGltYXRlIGJhc2VkIG9uIGNodW5rc1xuICAgICAgICAvLyBXZSdsbCBpbmNyZW1lbnQgYnkgYXBwcm94LiA1LTEwJSBlYWNoIHRpbWUgYSBjaHVuayBpcyB0eXBlZFxuICAgICAgICBwcm9ncmVzc0NvdW50ZXJSZWYuY3VycmVudCArPSBNYXRoLm1pbigxMCwgTWF0aC5mbG9vcih0b3RhbExlbmd0aFJlZi5jdXJyZW50ICogMC4wOCkpO1xuICAgICAgICBcbiAgICAgICAgLy8gQ2FsY3VsYXRlIHByb2dyZXNzIGFzIGEgcGVyY2VudGFnZSBhbmQgY2xhbXAgaXQgdG8gMTAwJVxuICAgICAgICBjb25zdCBuZXdQcm9ncmVzcyA9IE1hdGgubWluKDEwMCwgTWF0aC5mbG9vcihwcm9ncmVzc0NvdW50ZXJSZWYuY3VycmVudCAqIDEwMCAvIHRvdGFsTGVuZ3RoUmVmLmN1cnJlbnQpKTtcbiAgICAgICAgc2V0UHJvZ3Jlc3MobmV3UHJvZ3Jlc3MpO1xuICAgICAgICBcbiAgICAgICAgLy8gQ2FsbCBwcm9ncmVzcyBjYWxsYmFja1xuICAgICAgICBpZiAob25UeXBpbmdQcm9ncmVzcykge1xuICAgICAgICAgICAgb25UeXBpbmdQcm9ncmVzcyhuZXdQcm9ncmVzcyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFxuICAgIGNvbnN0IGhhbmRsZUNvbXBsZXRlID0gKCkgPT4ge1xuICAgICAgICBpZiAoIWlzTW91bnRlZFJlZi5jdXJyZW50IHx8IGlzQ29tcGxldGVkUmVmLmN1cnJlbnQpIHJldHVybjtcbiAgICAgICAgXG4gICAgICAgIC8vIE1hcmsgYXMgY29tcGxldGVkIHRvIHByZXZlbnQgZHVwbGljYXRlIGNhbGxiYWNrc1xuICAgICAgICBpc1R5cGluZ1JlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgIGlzQ29tcGxldGVkUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICBcbiAgICAgICAgLy8gVXBkYXRlIHByb2dyZXNzIHRvIDEwMCVcbiAgICAgICAgc2V0UHJvZ3Jlc3MoMTAwKTtcbiAgICAgICAgXG4gICAgICAgIC8vIENhbGwgY29tcGxldGUgY2FsbGJhY2tcbiAgICAgICAgaWYgKG9uVHlwaW5nQ29tcGxldGUpIHtcbiAgICAgICAgICAgIG9uVHlwaW5nQ29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgXG4gICAgLy8gVXNlIHRoZSBvcmlnaW5hbCB0ZXh0IHRvIHByZXZlbnQgYW5pbWF0aW9uIHJlc3RhcnRcbiAgICByZXR1cm4gKFxuICAgICAgICA8VHlwZXdyaXRlclRleHRcbiAgICAgICAgICAgIGtleT17YHR5cGV3cml0ZXItJHttZXNzYWdlSWR9YH0gLy8gU3RhYmxlIGtleSBiYXNlZCBvbiBtZXNzYWdlIElEXG4gICAgICAgICAgICB0ZXh0PXt0ZXh0UmVmLmN1cnJlbnR9XG4gICAgICAgICAgICBzcGVlZD17c3BlZWR9IFxuICAgICAgICAgICAgb25Db21wbGV0ZT17aGFuZGxlQ29tcGxldGV9XG4gICAgICAgICAgICBvbkNoYXJhY3RlclR5cGVkPXtoYW5kbGVDaHVua1R5cGVkfSAvLyBOb3cgdGhpcyBpcyBjYWxsZWQgZm9yIGVhY2ggY2h1bmtcbiAgICAgICAgLz5cbiAgICApO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgVHlwZXdyaXRlclRleHRXcmFwcGVyOyJdLCJuYW1lcyI6WyJSZWFjdCIsInVzZUVmZmVjdCIsInVzZVN0YXRlIiwidXNlUmVmIiwiVHlwZXdyaXRlclRleHQiLCJUeXBld3JpdGVyVGV4dFdyYXBwZXIiLCJ0ZXh0IiwiY29udGVudCIsInNwZWVkIiwibWVzc2FnZUlkIiwib25UeXBpbmdQcm9ncmVzcyIsIm9uVHlwaW5nQ29tcGxldGUiLCJpc1R5cGluZ1JlZiIsImlzQ29tcGxldGVkUmVmIiwiaXNNb3VudGVkUmVmIiwiZGlzcGxheVRleHQiLCJzYWZlVGV4dCIsInRleHRSZWYiLCJwcm9ncmVzcyIsInNldFByb2dyZXNzIiwidG90YWxMZW5ndGhSZWYiLCJsZW5ndGgiLCJwcm9ncmVzc0NvdW50ZXJSZWYiLCJjdXJyZW50IiwiaGFuZGxlQ2h1bmtUeXBlZCIsIk1hdGgiLCJtaW4iLCJmbG9vciIsIm5ld1Byb2dyZXNzIiwiaGFuZGxlQ29tcGxldGUiLCJvbkNvbXBsZXRlIiwib25DaGFyYWN0ZXJUeXBlZCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/TypewriterTextWrapper.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/services/AI.ts":
/*!****************************!*\
  !*** ./src/services/AI.ts ***!
  \****************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AI_MODELS: () => (/* binding */ AI_MODELS),\n/* harmony export */   DEFAULT_MODEL: () => (/* binding */ DEFAULT_MODEL),\n/* harmony export */   aiService: () => (/* binding */ aiService)\n/* harmony export */ });\n// Define AI models with their configuration\nconst AI_MODELS = {\n    CLAUDE_HAIKU: {\n        id: 'claude-3-haiku-20240307',\n        name: 'Claude Haiku',\n        provider: 'claude',\n        maxTokens: 1000,\n        temperature: 0.7\n    },\n    CLAUDE_SONNET: {\n        id: 'claude-3-sonnet-20240229',\n        name: 'Claude Sonnet',\n        provider: 'claude',\n        maxTokens: 4000,\n        temperature: 0.7\n    },\n    CLAUDE_OPUS: {\n        id: 'claude-3-opus-20240229',\n        name: 'Claude Opus',\n        provider: 'claude',\n        maxTokens: 4000,\n        temperature: 0.7\n    },\n    // Add Claude 2 as a fallback\n    CLAUDE_2: {\n        id: 'claude-2.0',\n        name: 'Claude 2',\n        provider: 'claude',\n        maxTokens: 4000,\n        temperature: 0.7\n    }\n};\nconst DEFAULT_MODEL = AI_MODELS.CLAUDE_HAIKU;\n// Updated backward compatibility mapping\nconst MODEL_ID_MAPPING = {\n    'claude-haiku': 'claude-3-haiku-20240307',\n    'claude-sonnet': 'claude-3-sonnet-20240229',\n    'claude-opus': 'claude-3-opus-20240229',\n    // Add any other aliases that might be used\n    'claude-3-sonnet': 'claude-3-sonnet-20240229',\n    'claude-3-haiku': 'claude-3-haiku-20240307',\n    'claude-3-opus': 'claude-3-opus-20240229'\n};\n/**\n * AI service for generating responses from different AI providers\n */ const aiService = {\n    generateResponse: async function(messages) {\n        let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n        // Get the model or default to Claude Haiku\n        const rawModelId = options.model || AI_MODELS.CLAUDE_HAIKU.id;\n        // Handle old model IDs with backward compatibility\n        const modelId = rawModelId in MODEL_ID_MAPPING ? MODEL_ID_MAPPING[rawModelId] : rawModelId;\n        const modelConfig = Object.values(AI_MODELS).find((m)=>m.id === modelId);\n        if (!modelConfig) {\n            console.error(\"Model ID lookup failed: \".concat(rawModelId, \" -> \").concat(modelId));\n            // Fall back to default model instead of crashing\n            const defaultConfig = Object.values(AI_MODELS).find((m)=>m.id === AI_MODELS.CLAUDE_HAIKU.id);\n            if (!defaultConfig) {\n                throw new Error(\"Model \".concat(modelId, \" not found and default model is invalid\"));\n            }\n            console.log(\"Falling back to default model: \".concat(defaultConfig.id));\n            return aiService.generateResponse(messages, {\n                ...options,\n                model: defaultConfig.id\n            });\n        }\n        // Rest of your code remains the same\n        const formattedMessages = messages.map((msg)=>({\n                role: msg.sender === 'user' ? 'user' : 'assistant',\n                content: msg.text\n            }));\n        // Ensure there's at least one message and it's from the user\n        if (formattedMessages.length === 0 || formattedMessages.every((m)=>m.role !== 'user')) {\n            // Add a default user message if needed\n            formattedMessages.unshift({\n                role: 'user',\n                content: 'Please help with this.'\n            });\n        }\n        try {\n            // Call the appropriate API endpoint based on provider\n            if (modelConfig.provider === 'claude') {\n                const response = await fetch('/api/claude', {\n                    method: 'POST',\n                    headers: {\n                        'Content-Type': 'application/json'\n                    },\n                    body: JSON.stringify({\n                        messages: formattedMessages,\n                        systemPrompt: options.systemPrompt || '',\n                        model: modelId // Use the resolved model ID\n                    })\n                });\n                if (!response.ok) {\n                    const errorText = await response.text();\n                    throw new Error(\"API error \".concat(response.status, \": \").concat(errorText));\n                }\n                const data = await response.json();\n                return data.message;\n            } else {\n                throw new Error(\"Provider \".concat(modelConfig.provider, \" not supported\"));\n            }\n        } catch (error) {\n            console.error('Error generating AI response:', error);\n            throw error;\n        }\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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N0IsT0FBT0MsUUFBUSw0QkFBNEI7b0JBQy9DO2dCQUNKO2dCQUVBLElBQUksQ0FBQ3FCLFNBQVNRLEVBQUUsRUFBRTtvQkFDZCxNQUFNQyxZQUFZLE1BQU1ULFNBQVNKLElBQUk7b0JBQ3JDLE1BQU0sSUFBSVIsTUFBTSxhQUFpQ3FCLE9BQXBCVCxTQUFTVSxNQUFNLEVBQUMsTUFBYyxPQUFWRDtnQkFDckQ7Z0JBRUEsTUFBTUUsT0FBTyxNQUFNWCxTQUFTWSxJQUFJO2dCQUNoQyxPQUFPRCxLQUFLRSxPQUFPO1lBQ3ZCLE9BQU87Z0JBQ0gsTUFBTSxJQUFJekIsTUFBTSxZQUFpQyxPQUFyQlIsWUFBWWYsUUFBUSxFQUFDO1lBQ3JEO1FBQ0osRUFBRSxPQUFPcUIsT0FBTztZQUNaRCxRQUFRQyxLQUFLLENBQUMsaUNBQWlDQTtZQUMvQyxNQUFNQTtRQUNWO0lBQ0o7QUFDSixFQUFFIiwic291cmNlcyI6WyIvVXNlcnMvam9uYXRoYW52aW5jZW50aXVzL0RvY3VtZW50cy9Vb2ZUL1Byb2plY3RzL2Nvd3JpdGluZy1sbG0tYWdlbnQvc3JjL3NlcnZpY2VzL0FJLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE1lc3NhZ2UgfSBmcm9tICdAL3V0aWxzL3R5cGVzJztcblxuLy8gRGVmaW5lIEFJIG1vZGVscyB3aXRoIHRoZWlyIGNvbmZpZ3VyYXRpb25cbmV4cG9ydCBjb25zdCBBSV9NT0RFTFMgPSB7XG4gICAgQ0xBVURFX0hBSUtVOiB7XG4gICAgICAgIGlkOiAnY2xhdWRlLTMtaGFpa3UtMjAyNDAzMDcnLFxuICAgICAgICBuYW1lOiAnQ2xhdWRlIEhhaWt1JyxcbiAgICAgICAgcHJvdmlkZXI6ICdjbGF1ZGUnLFxuICAgICAgICBtYXhUb2tlbnM6IDEwMDAsXG4gICAgICAgIHRlbXBlcmF0dXJlOiAwLjdcbiAgICB9LFxuICAgIENMQVVERV9TT05ORVQ6IHtcbiAgICAgICAgaWQ6ICdjbGF1ZGUtMy1zb25uZXQtMjAyNDAyMjknLFxuICAgICAgICBuYW1lOiAnQ2xhdWRlIFNvbm5ldCcsXG4gICAgICAgIHByb3ZpZGVyOiAnY2xhdWRlJyxcbiAgICAgICAgbWF4VG9rZW5zOiA0MDAwLFxuICAgICAgICB0ZW1wZXJhdHVyZTogMC43XG4gICAgfSxcbiAgICBDTEFVREVfT1BVUzoge1xuICAgICAgICBpZDogJ2NsYXVkZS0zLW9wdXMtMjAyNDAyMjknLFxuICAgICAgICBuYW1lOiAnQ2xhdWRlIE9wdXMnLFxuICAgICAgICBwcm92aWRlcjogJ2NsYXVkZScsXG4gICAgICAgIG1heFRva2VuczogNDAwMCxcbiAgICAgICAgdGVtcGVyYXR1cmU6IDAuN1xuICAgIH0sXG4gICAgLy8gQWRkIENsYXVkZSAyIGFzIGEgZmFsbGJhY2tcbiAgICBDTEFVREVfMjoge1xuICAgICAgICBpZDogJ2NsYXVkZS0yLjAnLFxuICAgICAgICBuYW1lOiAnQ2xhdWRlIDInLFxuICAgICAgICBwcm92aWRlcjogJ2NsYXVkZScsXG4gICAgICAgIG1heFRva2VuczogNDAwMCxcbiAgICAgICAgdGVtcGVyYXR1cmU6IDAuN1xuICAgIH1cbn07XG5cbmV4cG9ydCBjb25zdCBERUZBVUxUX01PREVMID0gQUlfTU9ERUxTLkNMQVVERV9IQUlLVTtcblxuLy8gVXBkYXRlZCBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IG1hcHBpbmdcbmNvbnN0IE1PREVMX0lEX01BUFBJTkcgPSB7XG4gICAgJ2NsYXVkZS1oYWlrdSc6ICdjbGF1ZGUtMy1oYWlrdS0yMDI0MDMwNycsXG4gICAgJ2NsYXVkZS1zb25uZXQnOiAnY2xhdWRlLTMtc29ubmV0LTIwMjQwMjI5JyxcbiAgICAnY2xhdWRlLW9wdXMnOiAnY2xhdWRlLTMtb3B1cy0yMDI0MDIyOScsXG4gICAgLy8gQWRkIGFueSBvdGhlciBhbGlhc2VzIHRoYXQgbWlnaHQgYmUgdXNlZFxuICAgICdjbGF1ZGUtMy1zb25uZXQnOiAnY2xhdWRlLTMtc29ubmV0LTIwMjQwMjI5JyxcbiAgICAnY2xhdWRlLTMtaGFpa3UnOiAnY2xhdWRlLTMtaGFpa3UtMjAyNDAzMDcnLFxuICAgICdjbGF1ZGUtMy1vcHVzJzogJ2NsYXVkZS0zLW9wdXMtMjAyNDAyMjknXG59O1xuXG5pbnRlcmZhY2UgQUlTZXJ2aWNlT3B0aW9ucyB7XG4gICAgc3lzdGVtUHJvbXB0Pzogc3RyaW5nO1xuICAgIG1vZGVsPzogc3RyaW5nO1xufVxuXG4vKipcbiAqIEFJIHNlcnZpY2UgZm9yIGdlbmVyYXRpbmcgcmVzcG9uc2VzIGZyb20gZGlmZmVyZW50IEFJIHByb3ZpZGVyc1xuICovXG5leHBvcnQgY29uc3QgYWlTZXJ2aWNlID0ge1xuICAgIGdlbmVyYXRlUmVzcG9uc2U6IGFzeW5jIChcbiAgICAgICAgbWVzc2FnZXM6IE1lc3NhZ2VbXSxcbiAgICAgICAgb3B0aW9uczogQUlTZXJ2aWNlT3B0aW9ucyA9IHt9XG4gICAgKTogUHJvbWlzZTxzdHJpbmc+ID0+IHtcbiAgICAgICAgLy8gR2V0IHRoZSBtb2RlbCBvciBkZWZhdWx0IHRvIENsYXVkZSBIYWlrdVxuICAgICAgICBjb25zdCByYXdNb2RlbElkID0gb3B0aW9ucy5tb2RlbCB8fCBBSV9NT0RFTFMuQ0xBVURFX0hBSUtVLmlkO1xuICAgICAgICBcbiAgICAgICAgLy8gSGFuZGxlIG9sZCBtb2RlbCBJRHMgd2l0aCBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG4gICAgICAgIGNvbnN0IG1vZGVsSWQgPSAocmF3TW9kZWxJZCBpbiBNT0RFTF9JRF9NQVBQSU5HKVxuICAgICAgICAgICAgPyBNT0RFTF9JRF9NQVBQSU5HW3Jhd01vZGVsSWQgYXMga2V5b2YgdHlwZW9mIE1PREVMX0lEX01BUFBJTkddXG4gICAgICAgICAgICA6IHJhd01vZGVsSWQ7XG5cbiAgICAgICAgY29uc3QgbW9kZWxDb25maWcgPSBPYmplY3QudmFsdWVzKEFJX01PREVMUykuZmluZChtID0+IG0uaWQgPT09IG1vZGVsSWQpO1xuXG4gICAgICAgIGlmICghbW9kZWxDb25maWcpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYE1vZGVsIElEIGxvb2t1cCBmYWlsZWQ6ICR7cmF3TW9kZWxJZH0gLT4gJHttb2RlbElkfWApO1xuICAgICAgICAgICAgLy8gRmFsbCBiYWNrIHRvIGRlZmF1bHQgbW9kZWwgaW5zdGVhZCBvZiBjcmFzaGluZ1xuICAgICAgICAgICAgY29uc3QgZGVmYXVsdENvbmZpZyA9IE9iamVjdC52YWx1ZXMoQUlfTU9ERUxTKS5maW5kKG0gPT4gbS5pZCA9PT0gQUlfTU9ERUxTLkNMQVVERV9IQUlLVS5pZCk7XG4gICAgICAgICAgICBpZiAoIWRlZmF1bHRDb25maWcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE1vZGVsICR7bW9kZWxJZH0gbm90IGZvdW5kIGFuZCBkZWZhdWx0IG1vZGVsIGlzIGludmFsaWRgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBGYWxsaW5nIGJhY2sgdG8gZGVmYXVsdCBtb2RlbDogJHtkZWZhdWx0Q29uZmlnLmlkfWApO1xuICAgICAgICAgICAgcmV0dXJuIGFpU2VydmljZS5nZW5lcmF0ZVJlc3BvbnNlKG1lc3NhZ2VzLCB7XG4gICAgICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgICAgICBtb2RlbDogZGVmYXVsdENvbmZpZy5pZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZXN0IG9mIHlvdXIgY29kZSByZW1haW5zIHRoZSBzYW1lXG4gICAgICAgIGNvbnN0IGZvcm1hdHRlZE1lc3NhZ2VzID0gbWVzc2FnZXMubWFwKG1zZyA9PiAoe1xuICAgICAgICAgICAgcm9sZTogbXNnLnNlbmRlciA9PT0gJ3VzZXInID8gJ3VzZXInIDogJ2Fzc2lzdGFudCcsXG4gICAgICAgICAgICBjb250ZW50OiBtc2cudGV4dFxuICAgICAgICB9KSk7XG5cbiAgICAgICAgLy8gRW5zdXJlIHRoZXJlJ3MgYXQgbGVhc3Qgb25lIG1lc3NhZ2UgYW5kIGl0J3MgZnJvbSB0aGUgdXNlclxuICAgICAgICBpZiAoZm9ybWF0dGVkTWVzc2FnZXMubGVuZ3RoID09PSAwIHx8IGZvcm1hdHRlZE1lc3NhZ2VzLmV2ZXJ5KG0gPT4gbS5yb2xlICE9PSAndXNlcicpKSB7XG4gICAgICAgICAgICAvLyBBZGQgYSBkZWZhdWx0IHVzZXIgbWVzc2FnZSBpZiBuZWVkZWRcbiAgICAgICAgICAgIGZvcm1hdHRlZE1lc3NhZ2VzLnVuc2hpZnQoe1xuICAgICAgICAgICAgICAgIHJvbGU6ICd1c2VyJyxcbiAgICAgICAgICAgICAgICBjb250ZW50OiAnUGxlYXNlIGhlbHAgd2l0aCB0aGlzLidcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIENhbGwgdGhlIGFwcHJvcHJpYXRlIEFQSSBlbmRwb2ludCBiYXNlZCBvbiBwcm92aWRlclxuICAgICAgICAgICAgaWYgKG1vZGVsQ29uZmlnLnByb3ZpZGVyID09PSAnY2xhdWRlJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goJy9hcGkvY2xhdWRlJywge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZXM6IGZvcm1hdHRlZE1lc3NhZ2VzLCAvLyBVc2UgZm9ybWF0dGVkTWVzc2FnZXMgaW5zdGVhZCBvZiBtZXNzYWdlc1xuICAgICAgICAgICAgICAgICAgICAgICAgc3lzdGVtUHJvbXB0OiBvcHRpb25zLnN5c3RlbVByb21wdCB8fCAnJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsOiBtb2RlbElkIC8vIFVzZSB0aGUgcmVzb2x2ZWQgbW9kZWwgSURcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yVGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBUEkgZXJyb3IgJHtyZXNwb25zZS5zdGF0dXN9OiAke2Vycm9yVGV4dH1gKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgICAgIHJldHVybiBkYXRhLm1lc3NhZ2U7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUHJvdmlkZXIgJHttb2RlbENvbmZpZy5wcm92aWRlcn0gbm90IHN1cHBvcnRlZGApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2VuZXJhdGluZyBBSSByZXNwb25zZTonLCBlcnJvcik7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbn07Il0sIm5hbWVzIjpbIkFJX01PREVMUyIsIkNMQVVERV9IQUlLVSIsImlkIiwibmFtZSIsInByb3ZpZGVyIiwibWF4VG9rZW5zIiwidGVtcGVyYXR1cmUiLCJDTEFVREVfU09OTkVUIiwiQ0xBVURFX09QVVMiLCJDTEFVREVfMiIsIkRFRkFVTFRfTU9ERUwiLCJNT0RFTF9JRF9NQVBQSU5HIiwiYWlTZXJ2aWNlIiwiZ2VuZXJhdGVSZXNwb25zZSIsIm1lc3NhZ2VzIiwib3B0aW9ucyIsInJhd01vZGVsSWQiLCJtb2RlbCIsIm1vZGVsSWQiLCJtb2RlbENvbmZpZyIsIk9iamVjdCIsInZhbHVlcyIsImZpbmQiLCJtIiwiY29uc29sZSIsImVycm9yIiwiZGVmYXVsdENvbmZpZyIsIkVycm9yIiwibG9nIiwiZm9ybWF0dGVkTWVzc2FnZXMiLCJtYXAiLCJtc2ciLCJyb2xlIiwic2VuZGVyIiwiY29udGVudCIsInRleHQiLCJsZW5ndGgiLCJldmVyeSIsInVuc2hpZnQiLCJyZXNwb25zZSIsImZldGNoIiwibWV0aG9kIiwiaGVhZGVycyIsImJvZHkiLCJKU09OIiwic3RyaW5naWZ5Iiwic3lzdGVtUHJvbXB0Iiwib2siLCJlcnJvclRleHQiLCJzdGF0dXMiLCJkYXRhIiwianNvbiIsIm1lc3NhZ2UiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/services/AI.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-jsx-dev-runtime.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n true &&\n  (function () {\n    function getComponentNameFromType(type) {\n      if (null == type) return null;\n      if (\"function\" === typeof type)\n        return type.$$typeof === REACT_CLIENT_REFERENCE$2\n          ? null\n          : type.displayName || type.name || null;\n      if (\"string\" === typeof type) return type;\n      switch (type) {\n        case REACT_FRAGMENT_TYPE:\n          return \"Fragment\";\n        case REACT_PORTAL_TYPE:\n          return \"Portal\";\n        case REACT_PROFILER_TYPE:\n          return \"Profiler\";\n        case REACT_STRICT_MODE_TYPE:\n          return \"StrictMode\";\n        case REACT_SUSPENSE_TYPE:\n          return \"Suspense\";\n        case REACT_SUSPENSE_LIST_TYPE:\n          return \"SuspenseList\";\n      }\n      if (\"object\" === typeof type)\n        switch (\n          (\"number\" === typeof type.tag &&\n            console.error(\n              \"Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.\"\n            ),\n          type.$$typeof)\n        ) {\n          case REACT_CONTEXT_TYPE:\n            return (type.displayName || \"Context\") + \".Provider\";\n          case REACT_CONSUMER_TYPE:\n            return (type._context.displayName || \"Context\") + \".Consumer\";\n          case REACT_FORWARD_REF_TYPE:\n            var innerType = type.render;\n            type = type.displayName;\n            type ||\n              ((type = innerType.displayName || innerType.name || \"\"),\n              (type = \"\" !== type ? \"ForwardRef(\" + type + \")\" : \"ForwardRef\"));\n            return type;\n          case REACT_MEMO_TYPE:\n            return (\n              (innerType = type.displayName || null),\n              null !== innerType\n                ? innerType\n                : getComponentNameFromType(type.type) || \"Memo\"\n            );\n          case REACT_LAZY_TYPE:\n            innerType = type._payload;\n            type = type._init;\n            try {\n              return getComponentNameFromType(type(innerType));\n            } catch (x) {}\n        }\n      return null;\n    }\n    function testStringCoercion(value) {\n      return \"\" + value;\n    }\n    function checkKeyStringCoercion(value) {\n      try {\n        testStringCoercion(value);\n        var JSCompiler_inline_result = !1;\n      } catch (e) {\n        JSCompiler_inline_result = !0;\n      }\n      if (JSCompiler_inline_result) {\n        JSCompiler_inline_result = console;\n        var JSCompiler_temp_const = JSCompiler_inline_result.error;\n        var JSCompiler_inline_result$jscomp$0 =\n          (\"function\" === typeof Symbol &&\n            Symbol.toStringTag &&\n            value[Symbol.toStringTag]) ||\n          value.constructor.name ||\n          \"Object\";\n        JSCompiler_temp_const.call(\n          JSCompiler_inline_result,\n          \"The provided key is an unsupported type %s. This value must be coerced to a string before using it here.\",\n          JSCompiler_inline_result$jscomp$0\n        );\n        return testStringCoercion(value);\n      }\n    }\n    function disabledLog() {}\n    function disableLogs() {\n      if (0 === disabledDepth) {\n        prevLog = console.log;\n        prevInfo = console.info;\n        prevWarn = console.warn;\n        prevError = console.error;\n        prevGroup = console.group;\n        prevGroupCollapsed = console.groupCollapsed;\n        prevGroupEnd = console.groupEnd;\n        var props = {\n          configurable: !0,\n          enumerable: !0,\n          value: disabledLog,\n          writable: !0\n        };\n        Object.defineProperties(console, {\n          info: props,\n          log: props,\n          warn: props,\n          error: props,\n          group: props,\n          groupCollapsed: props,\n          groupEnd: props\n        });\n      }\n      disabledDepth++;\n    }\n    function reenableLogs() {\n      disabledDepth--;\n      if (0 === disabledDepth) {\n        var props = { configurable: !0, enumerable: !0, writable: !0 };\n        Object.defineProperties(console, {\n          log: assign({}, props, { value: prevLog }),\n          info: assign({}, props, { value: prevInfo }),\n          warn: assign({}, props, { value: prevWarn }),\n          error: assign({}, props, { value: prevError }),\n          group: assign({}, props, { value: prevGroup }),\n          groupCollapsed: assign({}, props, { value: prevGroupCollapsed }),\n          groupEnd: assign({}, props, { value: prevGroupEnd })\n        });\n      }\n      0 > disabledDepth &&\n        console.error(\n          \"disabledDepth fell below zero. This is a bug in React. Please file an issue.\"\n        );\n    }\n    function describeBuiltInComponentFrame(name) {\n      if (void 0 === prefix)\n        try {\n          throw Error();\n        } catch (x) {\n          var match = x.stack.trim().match(/\\n( *(at )?)/);\n          prefix = (match && match[1]) || \"\";\n          suffix =\n            -1 < x.stack.indexOf(\"\\n    at\")\n              ? \" (<anonymous>)\"\n              : -1 < x.stack.indexOf(\"@\")\n                ? \"@unknown:0:0\"\n                : \"\";\n        }\n      return \"\\n\" + prefix + name + suffix;\n    }\n    function describeNativeComponentFrame(fn, construct) {\n      if (!fn || reentry) return \"\";\n      var frame = componentFrameCache.get(fn);\n      if (void 0 !== frame) return frame;\n      reentry = !0;\n      frame = Error.prepareStackTrace;\n      Error.prepareStackTrace = void 0;\n      var previousDispatcher = null;\n      previousDispatcher = ReactSharedInternals.H;\n      ReactSharedInternals.H = null;\n      disableLogs();\n      try {\n        var RunInRootFrame = {\n          DetermineComponentFrameRoot: function () {\n            try {\n              if (construct) {\n                var Fake = function () {\n                  throw Error();\n                };\n                Object.defineProperty(Fake.prototype, \"props\", {\n                  set: function () {\n                    throw Error();\n                  }\n                });\n                if (\"object\" === typeof Reflect && Reflect.construct) {\n                  try {\n                    Reflect.construct(Fake, []);\n                  } catch (x) {\n                    var control = x;\n                  }\n                  Reflect.construct(fn, [], Fake);\n                } else {\n                  try {\n                    Fake.call();\n                  } catch (x$0) {\n                    control = x$0;\n                  }\n                  fn.call(Fake.prototype);\n                }\n              } else {\n                try {\n                  throw Error();\n                } catch (x$1) {\n                  control = x$1;\n                }\n                (Fake = fn()) &&\n                  \"function\" === typeof Fake.catch &&\n                  Fake.catch(function () {});\n              }\n            } catch (sample) {\n              if (sample && control && \"string\" === typeof sample.stack)\n                return [sample.stack, control.stack];\n            }\n            return [null, null];\n          }\n        };\n        RunInRootFrame.DetermineComponentFrameRoot.displayName =\n          \"DetermineComponentFrameRoot\";\n        var namePropDescriptor = Object.getOwnPropertyDescriptor(\n          RunInRootFrame.DetermineComponentFrameRoot,\n          \"name\"\n        );\n        namePropDescriptor &&\n          namePropDescriptor.configurable &&\n          Object.defineProperty(\n            RunInRootFrame.DetermineComponentFrameRoot,\n            \"name\",\n            { value: \"DetermineComponentFrameRoot\" }\n          );\n        var _RunInRootFrame$Deter =\n            RunInRootFrame.DetermineComponentFrameRoot(),\n          sampleStack = _RunInRootFrame$Deter[0],\n          controlStack = _RunInRootFrame$Deter[1];\n        if (sampleStack && controlStack) {\n          var sampleLines = sampleStack.split(\"\\n\"),\n            controlLines = controlStack.split(\"\\n\");\n          for (\n            _RunInRootFrame$Deter = namePropDescriptor = 0;\n            namePropDescriptor < sampleLines.length &&\n            !sampleLines[namePropDescriptor].includes(\n              \"DetermineComponentFrameRoot\"\n            );\n\n          )\n            namePropDescriptor++;\n          for (\n            ;\n            _RunInRootFrame$Deter < controlLines.length &&\n            !controlLines[_RunInRootFrame$Deter].includes(\n              \"DetermineComponentFrameRoot\"\n            );\n\n          )\n            _RunInRootFrame$Deter++;\n          if (\n            namePropDescriptor === sampleLines.length ||\n            _RunInRootFrame$Deter === controlLines.length\n          )\n            for (\n              namePropDescriptor = sampleLines.length - 1,\n                _RunInRootFrame$Deter = controlLines.length - 1;\n              1 <= namePropDescriptor &&\n              0 <= _RunInRootFrame$Deter &&\n              sampleLines[namePropDescriptor] !==\n                controlLines[_RunInRootFrame$Deter];\n\n            )\n              _RunInRootFrame$Deter--;\n          for (\n            ;\n            1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter;\n            namePropDescriptor--, _RunInRootFrame$Deter--\n          )\n            if (\n              sampleLines[namePropDescriptor] !==\n              controlLines[_RunInRootFrame$Deter]\n            ) {\n              if (1 !== namePropDescriptor || 1 !== _RunInRootFrame$Deter) {\n                do\n                  if (\n                    (namePropDescriptor--,\n                    _RunInRootFrame$Deter--,\n                    0 > _RunInRootFrame$Deter ||\n                      sampleLines[namePropDescriptor] !==\n                        controlLines[_RunInRootFrame$Deter])\n                  ) {\n                    var _frame =\n                      \"\\n\" +\n                      sampleLines[namePropDescriptor].replace(\n                        \" at new \",\n                        \" at \"\n                      );\n                    fn.displayName &&\n                      _frame.includes(\"<anonymous>\") &&\n                      (_frame = _frame.replace(\"<anonymous>\", fn.displayName));\n                    \"function\" === typeof fn &&\n                      componentFrameCache.set(fn, _frame);\n                    return _frame;\n                  }\n                while (1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter);\n              }\n              break;\n            }\n        }\n      } finally {\n        (reentry = !1),\n          (ReactSharedInternals.H = previousDispatcher),\n          reenableLogs(),\n          (Error.prepareStackTrace = frame);\n      }\n      sampleLines = (sampleLines = fn ? fn.displayName || fn.name : \"\")\n        ? describeBuiltInComponentFrame(sampleLines)\n        : \"\";\n      \"function\" === typeof fn && componentFrameCache.set(fn, sampleLines);\n      return sampleLines;\n    }\n    function describeUnknownElementTypeFrameInDEV(type) {\n      if (null == type) return \"\";\n      if (\"function\" === typeof type) {\n        var prototype = type.prototype;\n        return describeNativeComponentFrame(\n          type,\n          !(!prototype || !prototype.isReactComponent)\n        );\n      }\n      if (\"string\" === typeof type) return describeBuiltInComponentFrame(type);\n      switch (type) {\n        case REACT_SUSPENSE_TYPE:\n          return describeBuiltInComponentFrame(\"Suspense\");\n        case REACT_SUSPENSE_LIST_TYPE:\n          return describeBuiltInComponentFrame(\"SuspenseList\");\n      }\n      if (\"object\" === typeof type)\n        switch (type.$$typeof) {\n          case REACT_FORWARD_REF_TYPE:\n            return (type = describeNativeComponentFrame(type.render, !1)), type;\n          case REACT_MEMO_TYPE:\n            return describeUnknownElementTypeFrameInDEV(type.type);\n          case REACT_LAZY_TYPE:\n            prototype = type._payload;\n            type = type._init;\n            try {\n              return describeUnknownElementTypeFrameInDEV(type(prototype));\n            } catch (x) {}\n        }\n      return \"\";\n    }\n    function getOwner() {\n      var dispatcher = ReactSharedInternals.A;\n      return null === dispatcher ? null : dispatcher.getOwner();\n    }\n    function hasValidKey(config) {\n      if (hasOwnProperty.call(config, \"key\")) {\n        var getter = Object.getOwnPropertyDescriptor(config, \"key\").get;\n        if (getter && getter.isReactWarning) return !1;\n      }\n      return void 0 !== config.key;\n    }\n    function defineKeyPropWarningGetter(props, displayName) {\n      function warnAboutAccessingKey() {\n        specialPropKeyWarningShown ||\n          ((specialPropKeyWarningShown = !0),\n          console.error(\n            \"%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)\",\n            displayName\n          ));\n      }\n      warnAboutAccessingKey.isReactWarning = !0;\n      Object.defineProperty(props, \"key\", {\n        get: warnAboutAccessingKey,\n        configurable: !0\n      });\n    }\n    function elementRefGetterWithDeprecationWarning() {\n      var componentName = getComponentNameFromType(this.type);\n      didWarnAboutElementRef[componentName] ||\n        ((didWarnAboutElementRef[componentName] = !0),\n        console.error(\n          \"Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release.\"\n        ));\n      componentName = this.props.ref;\n      return void 0 !== componentName ? componentName : null;\n    }\n    function ReactElement(type, key, self, source, owner, props) {\n      self = props.ref;\n      type = {\n        $$typeof: REACT_ELEMENT_TYPE,\n        type: type,\n        key: key,\n        props: props,\n        _owner: owner\n      };\n      null !== (void 0 !== self ? self : null)\n        ? Object.defineProperty(type, \"ref\", {\n            enumerable: !1,\n            get: elementRefGetterWithDeprecationWarning\n          })\n        : Object.defineProperty(type, \"ref\", { enumerable: !1, value: null });\n      type._store = {};\n      Object.defineProperty(type._store, \"validated\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: 0\n      });\n      Object.defineProperty(type, \"_debugInfo\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: null\n      });\n      Object.freeze && (Object.freeze(type.props), Object.freeze(type));\n      return type;\n    }\n    function jsxDEVImpl(\n      type,\n      config,\n      maybeKey,\n      isStaticChildren,\n      source,\n      self\n    ) {\n      if (\n        \"string\" === typeof type ||\n        \"function\" === typeof type ||\n        type === REACT_FRAGMENT_TYPE ||\n        type === REACT_PROFILER_TYPE ||\n        type === REACT_STRICT_MODE_TYPE ||\n        type === REACT_SUSPENSE_TYPE ||\n        type === REACT_SUSPENSE_LIST_TYPE ||\n        type === REACT_OFFSCREEN_TYPE ||\n        (\"object\" === typeof type &&\n          null !== type &&\n          (type.$$typeof === REACT_LAZY_TYPE ||\n            type.$$typeof === REACT_MEMO_TYPE ||\n            type.$$typeof === REACT_CONTEXT_TYPE ||\n            type.$$typeof === REACT_CONSUMER_TYPE ||\n            type.$$typeof === REACT_FORWARD_REF_TYPE ||\n            type.$$typeof === REACT_CLIENT_REFERENCE$1 ||\n            void 0 !== type.getModuleId))\n      ) {\n        var children = config.children;\n        if (void 0 !== children)\n          if (isStaticChildren)\n            if (isArrayImpl(children)) {\n              for (\n                isStaticChildren = 0;\n                isStaticChildren < children.length;\n                isStaticChildren++\n              )\n                validateChildKeys(children[isStaticChildren], type);\n              Object.freeze && Object.freeze(children);\n            } else\n              console.error(\n                \"React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.\"\n              );\n          else validateChildKeys(children, type);\n      } else {\n        children = \"\";\n        if (\n          void 0 === type ||\n          (\"object\" === typeof type &&\n            null !== type &&\n            0 === Object.keys(type).length)\n        )\n          children +=\n            \" You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.\";\n        null === type\n          ? (isStaticChildren = \"null\")\n          : isArrayImpl(type)\n            ? (isStaticChildren = \"array\")\n            : void 0 !== type && type.$$typeof === REACT_ELEMENT_TYPE\n              ? ((isStaticChildren =\n                  \"<\" +\n                  (getComponentNameFromType(type.type) || \"Unknown\") +\n                  \" />\"),\n                (children =\n                  \" Did you accidentally export a JSX literal instead of a component?\"))\n              : (isStaticChildren = typeof type);\n        console.error(\n          \"React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s\",\n          isStaticChildren,\n          children\n        );\n      }\n      if (hasOwnProperty.call(config, \"key\")) {\n        children = getComponentNameFromType(type);\n        var keys = Object.keys(config).filter(function (k) {\n          return \"key\" !== k;\n        });\n        isStaticChildren =\n          0 < keys.length\n            ? \"{key: someKey, \" + keys.join(\": ..., \") + \": ...}\"\n            : \"{key: someKey}\";\n        didWarnAboutKeySpread[children + isStaticChildren] ||\n          ((keys =\n            0 < keys.length ? \"{\" + keys.join(\": ..., \") + \": ...}\" : \"{}\"),\n          console.error(\n            'A props object containing a \"key\" prop is being spread into JSX:\\n  let props = %s;\\n  <%s {...props} />\\nReact keys must be passed directly to JSX without using spread:\\n  let props = %s;\\n  <%s key={someKey} {...props} />',\n            isStaticChildren,\n            children,\n            keys,\n            children\n          ),\n          (didWarnAboutKeySpread[children + isStaticChildren] = !0));\n      }\n      children = null;\n      void 0 !== maybeKey &&\n        (checkKeyStringCoercion(maybeKey), (children = \"\" + maybeKey));\n      hasValidKey(config) &&\n        (checkKeyStringCoercion(config.key), (children = \"\" + config.key));\n      if (\"key\" in config) {\n        maybeKey = {};\n        for (var propName in config)\n          \"key\" !== propName && (maybeKey[propName] = config[propName]);\n      } else maybeKey = config;\n      children &&\n        defineKeyPropWarningGetter(\n          maybeKey,\n          \"function\" === typeof type\n            ? type.displayName || type.name || \"Unknown\"\n            : type\n        );\n      return ReactElement(type, children, self, source, getOwner(), maybeKey);\n    }\n    function validateChildKeys(node, parentType) {\n      if (\n        \"object\" === typeof node &&\n        node &&\n        node.$$typeof !== REACT_CLIENT_REFERENCE\n      )\n        if (isArrayImpl(node))\n          for (var i = 0; i < node.length; i++) {\n            var child = node[i];\n            isValidElement(child) && validateExplicitKey(child, parentType);\n          }\n        else if (isValidElement(node))\n          node._store && (node._store.validated = 1);\n        else if (\n          (null === node || \"object\" !== typeof node\n            ? (i = null)\n            : ((i =\n                (MAYBE_ITERATOR_SYMBOL && node[MAYBE_ITERATOR_SYMBOL]) ||\n                node[\"@@iterator\"]),\n              (i = \"function\" === typeof i ? i : null)),\n          \"function\" === typeof i &&\n            i !== node.entries &&\n            ((i = i.call(node)), i !== node))\n        )\n          for (; !(node = i.next()).done; )\n            isValidElement(node.value) &&\n              validateExplicitKey(node.value, parentType);\n    }\n    function isValidElement(object) {\n      return (\n        \"object\" === typeof object &&\n        null !== object &&\n        object.$$typeof === REACT_ELEMENT_TYPE\n      );\n    }\n    function validateExplicitKey(element, parentType) {\n      if (\n        element._store &&\n        !element._store.validated &&\n        null == element.key &&\n        ((element._store.validated = 1),\n        (parentType = getCurrentComponentErrorInfo(parentType)),\n        !ownerHasKeyUseWarning[parentType])\n      ) {\n        ownerHasKeyUseWarning[parentType] = !0;\n        var childOwner = \"\";\n        element &&\n          null != element._owner &&\n          element._owner !== getOwner() &&\n          ((childOwner = null),\n          \"number\" === typeof element._owner.tag\n            ? (childOwner = getComponentNameFromType(element._owner.type))\n            : \"string\" === typeof element._owner.name &&\n              (childOwner = element._owner.name),\n          (childOwner = \" It was passed a child from \" + childOwner + \".\"));\n        var prevGetCurrentStack = ReactSharedInternals.getCurrentStack;\n        ReactSharedInternals.getCurrentStack = function () {\n          var stack = describeUnknownElementTypeFrameInDEV(element.type);\n          prevGetCurrentStack && (stack += prevGetCurrentStack() || \"\");\n          return stack;\n        };\n        console.error(\n          'Each child in a list should have a unique \"key\" prop.%s%s See https://react.dev/link/warning-keys for more information.',\n          parentType,\n          childOwner\n        );\n        ReactSharedInternals.getCurrentStack = prevGetCurrentStack;\n      }\n    }\n    function getCurrentComponentErrorInfo(parentType) {\n      var info = \"\",\n        owner = getOwner();\n      owner &&\n        (owner = getComponentNameFromType(owner.type)) &&\n        (info = \"\\n\\nCheck the render method of `\" + owner + \"`.\");\n      info ||\n        ((parentType = getComponentNameFromType(parentType)) &&\n          (info =\n            \"\\n\\nCheck the top-level render call using <\" + parentType + \">.\"));\n      return info;\n    }\n    var React = __webpack_require__(/*! next/dist/compiled/react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"),\n      REACT_ELEMENT_TYPE = Symbol.for(\"react.transitional.element\"),\n      REACT_PORTAL_TYPE = Symbol.for(\"react.portal\"),\n      REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\"),\n      REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\"),\n      REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\");\n    Symbol.for(\"react.provider\");\n    var REACT_CONSUMER_TYPE = Symbol.for(\"react.consumer\"),\n      REACT_CONTEXT_TYPE = Symbol.for(\"react.context\"),\n      REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\"),\n      REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\"),\n      REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\"),\n      REACT_MEMO_TYPE = Symbol.for(\"react.memo\"),\n      REACT_LAZY_TYPE = Symbol.for(\"react.lazy\"),\n      REACT_OFFSCREEN_TYPE = Symbol.for(\"react.offscreen\"),\n      MAYBE_ITERATOR_SYMBOL = Symbol.iterator,\n      REACT_CLIENT_REFERENCE$2 = Symbol.for(\"react.client.reference\"),\n      ReactSharedInternals =\n        React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,\n      hasOwnProperty = Object.prototype.hasOwnProperty,\n      assign = Object.assign,\n      REACT_CLIENT_REFERENCE$1 = Symbol.for(\"react.client.reference\"),\n      isArrayImpl = Array.isArray,\n      disabledDepth = 0,\n      prevLog,\n      prevInfo,\n      prevWarn,\n      prevError,\n      prevGroup,\n      prevGroupCollapsed,\n      prevGroupEnd;\n    disabledLog.__reactDisabledLog = !0;\n    var prefix,\n      suffix,\n      reentry = !1;\n    var componentFrameCache = new (\n      \"function\" === typeof WeakMap ? WeakMap : Map\n    )();\n    var REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\"),\n      specialPropKeyWarningShown;\n    var didWarnAboutElementRef = {};\n    var didWarnAboutKeySpread = {},\n      ownerHasKeyUseWarning = {};\n    exports.Fragment = REACT_FRAGMENT_TYPE;\n    exports.jsxDEV = function (\n      type,\n      config,\n      maybeKey,\n      isStaticChildren,\n      source,\n      self\n    ) {\n      return jsxDEVImpl(type, config, maybeKey, isStaticChildren, source, self);\n    };\n  })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7QUFDYixLQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLHdCQUF3QixXQUFXLGdCQUFnQjtBQUNuRCx5QkFBeUIsV0FBVyxpQkFBaUI7QUFDckQseUJBQXlCLFdBQVcsaUJBQWlCO0FBQ3JELDBCQUEwQixXQUFXLGtCQUFrQjtBQUN2RCwwQkFBMEIsV0FBVyxrQkFBa0I7QUFDdkQsbUNBQW1DLFdBQVcsMkJBQTJCO0FBQ3pFLDZCQUE2QixXQUFXLHFCQUFxQjtBQUM3RCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsK0NBQStDLDZCQUE2QjtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxnQkFBZ0IsZ0RBQWdEO0FBQ2hFLGdCQUFnQixhQUFhO0FBQzdCO0FBQ0E7QUFDQSxnQ0FBZ0Msa0NBQWtDLE9BQU87QUFDekU7QUFDQSxnR0FBZ0csU0FBUyxVQUFVLHNGQUFzRixhQUFhLFVBQVUsVUFBVTtBQUMxTztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixpQkFBaUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIseUJBQXlCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQyxzR0FBMEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQSxJQUFJLGdCQUFnQjtBQUNwQixJQUFJLGNBQWM7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyIsInNvdXJjZXMiOlsiL1VzZXJzL2pvbmF0aGFudmluY2VudGl1cy9Eb2N1bWVudHMvVW9mVC9Qcm9qZWN0cy9jb3dyaXRpbmctbGxtLWFnZW50L25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WICYmXG4gIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHtcbiAgICAgIGlmIChudWxsID09IHR5cGUpIHJldHVybiBudWxsO1xuICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHR5cGUpXG4gICAgICAgIHJldHVybiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDJcbiAgICAgICAgICA/IG51bGxcbiAgICAgICAgICA6IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IG51bGw7XG4gICAgICBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHR5cGUpIHJldHVybiB0eXBlO1xuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJGcmFnbWVudFwiO1xuICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlBvcnRhbFwiO1xuICAgICAgICBjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiUHJvZmlsZXJcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlN0cmljdE1vZGVcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlN1c3BlbnNlXCI7XG4gICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlN1c3BlbnNlTGlzdFwiO1xuICAgICAgfVxuICAgICAgaWYgKFwib2JqZWN0XCIgPT09IHR5cGVvZiB0eXBlKVxuICAgICAgICBzd2l0Y2ggKFxuICAgICAgICAgIChcIm51bWJlclwiID09PSB0eXBlb2YgdHlwZS50YWcgJiZcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKCkuIFRoaXMgaXMgbGlrZWx5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgICAgICAgKSxcbiAgICAgICAgICB0eXBlLiQkdHlwZW9mKVxuICAgICAgICApIHtcbiAgICAgICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiAodHlwZS5kaXNwbGF5TmFtZSB8fCBcIkNvbnRleHRcIikgKyBcIi5Qcm92aWRlclwiO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OU1VNRVJfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiAodHlwZS5fY29udGV4dC5kaXNwbGF5TmFtZSB8fCBcIkNvbnRleHRcIikgKyBcIi5Db25zdW1lclwiO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgICAgIHZhciBpbm5lclR5cGUgPSB0eXBlLnJlbmRlcjtcbiAgICAgICAgICAgIHR5cGUgPSB0eXBlLmRpc3BsYXlOYW1lO1xuICAgICAgICAgICAgdHlwZSB8fFxuICAgICAgICAgICAgICAoKHR5cGUgPSBpbm5lclR5cGUuZGlzcGxheU5hbWUgfHwgaW5uZXJUeXBlLm5hbWUgfHwgXCJcIiksXG4gICAgICAgICAgICAgICh0eXBlID0gXCJcIiAhPT0gdHlwZSA/IFwiRm9yd2FyZFJlZihcIiArIHR5cGUgKyBcIilcIiA6IFwiRm9yd2FyZFJlZlwiKSk7XG4gICAgICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIChpbm5lclR5cGUgPSB0eXBlLmRpc3BsYXlOYW1lIHx8IG51bGwpLFxuICAgICAgICAgICAgICBudWxsICE9PSBpbm5lclR5cGVcbiAgICAgICAgICAgICAgICA/IGlubmVyVHlwZVxuICAgICAgICAgICAgICAgIDogZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUudHlwZSkgfHwgXCJNZW1vXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICBpbm5lclR5cGUgPSB0eXBlLl9wYXlsb2FkO1xuICAgICAgICAgICAgdHlwZSA9IHR5cGUuX2luaXQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUoaW5uZXJUeXBlKSk7XG4gICAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gXCJcIiArIHZhbHVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjaGVja0tleVN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gICAgICB0cnkge1xuICAgICAgICB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpO1xuICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gITE7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9ICEwO1xuICAgICAgfVxuICAgICAgaWYgKEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCkge1xuICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSBjb25zb2xlO1xuICAgICAgICB2YXIgSlNDb21waWxlcl90ZW1wX2NvbnN0ID0gSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0LmVycm9yO1xuICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQwID1cbiAgICAgICAgICAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgU3ltYm9sICYmXG4gICAgICAgICAgICBTeW1ib2wudG9TdHJpbmdUYWcgJiZcbiAgICAgICAgICAgIHZhbHVlW1N5bWJvbC50b1N0cmluZ1RhZ10pIHx8XG4gICAgICAgICAgdmFsdWUuY29uc3RydWN0b3IubmFtZSB8fFxuICAgICAgICAgIFwiT2JqZWN0XCI7XG4gICAgICAgIEpTQ29tcGlsZXJfdGVtcF9jb25zdC5jYWxsKFxuICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCxcbiAgICAgICAgICBcIlRoZSBwcm92aWRlZCBrZXkgaXMgYW4gdW5zdXBwb3J0ZWQgdHlwZSAlcy4gVGhpcyB2YWx1ZSBtdXN0IGJlIGNvZXJjZWQgdG8gYSBzdHJpbmcgYmVmb3JlIHVzaW5nIGl0IGhlcmUuXCIsXG4gICAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQwXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBkaXNhYmxlZExvZygpIHt9XG4gICAgZnVuY3Rpb24gZGlzYWJsZUxvZ3MoKSB7XG4gICAgICBpZiAoMCA9PT0gZGlzYWJsZWREZXB0aCkge1xuICAgICAgICBwcmV2TG9nID0gY29uc29sZS5sb2c7XG4gICAgICAgIHByZXZJbmZvID0gY29uc29sZS5pbmZvO1xuICAgICAgICBwcmV2V2FybiA9IGNvbnNvbGUud2FybjtcbiAgICAgICAgcHJldkVycm9yID0gY29uc29sZS5lcnJvcjtcbiAgICAgICAgcHJldkdyb3VwID0gY29uc29sZS5ncm91cDtcbiAgICAgICAgcHJldkdyb3VwQ29sbGFwc2VkID0gY29uc29sZS5ncm91cENvbGxhcHNlZDtcbiAgICAgICAgcHJldkdyb3VwRW5kID0gY29uc29sZS5ncm91cEVuZDtcbiAgICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICAgICAgdmFsdWU6IGRpc2FibGVkTG9nLFxuICAgICAgICAgIHdyaXRhYmxlOiAhMFxuICAgICAgICB9O1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgICAgaW5mbzogcHJvcHMsXG4gICAgICAgICAgbG9nOiBwcm9wcyxcbiAgICAgICAgICB3YXJuOiBwcm9wcyxcbiAgICAgICAgICBlcnJvcjogcHJvcHMsXG4gICAgICAgICAgZ3JvdXA6IHByb3BzLFxuICAgICAgICAgIGdyb3VwQ29sbGFwc2VkOiBwcm9wcyxcbiAgICAgICAgICBncm91cEVuZDogcHJvcHNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBkaXNhYmxlZERlcHRoKys7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlZW5hYmxlTG9ncygpIHtcbiAgICAgIGRpc2FibGVkRGVwdGgtLTtcbiAgICAgIGlmICgwID09PSBkaXNhYmxlZERlcHRoKSB7XG4gICAgICAgIHZhciBwcm9wcyA9IHsgY29uZmlndXJhYmxlOiAhMCwgZW51bWVyYWJsZTogITAsIHdyaXRhYmxlOiAhMCB9O1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgICAgbG9nOiBhc3NpZ24oe30sIHByb3BzLCB7IHZhbHVlOiBwcmV2TG9nIH0pLFxuICAgICAgICAgIGluZm86IGFzc2lnbih7fSwgcHJvcHMsIHsgdmFsdWU6IHByZXZJbmZvIH0pLFxuICAgICAgICAgIHdhcm46IGFzc2lnbih7fSwgcHJvcHMsIHsgdmFsdWU6IHByZXZXYXJuIH0pLFxuICAgICAgICAgIGVycm9yOiBhc3NpZ24oe30sIHByb3BzLCB7IHZhbHVlOiBwcmV2RXJyb3IgfSksXG4gICAgICAgICAgZ3JvdXA6IGFzc2lnbih7fSwgcHJvcHMsIHsgdmFsdWU6IHByZXZHcm91cCB9KSxcbiAgICAgICAgICBncm91cENvbGxhcHNlZDogYXNzaWduKHt9LCBwcm9wcywgeyB2YWx1ZTogcHJldkdyb3VwQ29sbGFwc2VkIH0pLFxuICAgICAgICAgIGdyb3VwRW5kOiBhc3NpZ24oe30sIHByb3BzLCB7IHZhbHVlOiBwcmV2R3JvdXBFbmQgfSlcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICAwID4gZGlzYWJsZWREZXB0aCAmJlxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiZGlzYWJsZWREZXB0aCBmZWxsIGJlbG93IHplcm8uIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUpIHtcbiAgICAgIGlmICh2b2lkIDAgPT09IHByZWZpeClcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgdmFyIG1hdGNoID0geC5zdGFjay50cmltKCkubWF0Y2goL1xcbiggKihhdCApPykvKTtcbiAgICAgICAgICBwcmVmaXggPSAobWF0Y2ggJiYgbWF0Y2hbMV0pIHx8IFwiXCI7XG4gICAgICAgICAgc3VmZml4ID1cbiAgICAgICAgICAgIC0xIDwgeC5zdGFjay5pbmRleE9mKFwiXFxuICAgIGF0XCIpXG4gICAgICAgICAgICAgID8gXCIgKDxhbm9ueW1vdXM+KVwiXG4gICAgICAgICAgICAgIDogLTEgPCB4LnN0YWNrLmluZGV4T2YoXCJAXCIpXG4gICAgICAgICAgICAgICAgPyBcIkB1bmtub3duOjA6MFwiXG4gICAgICAgICAgICAgICAgOiBcIlwiO1xuICAgICAgICB9XG4gICAgICByZXR1cm4gXCJcXG5cIiArIHByZWZpeCArIG5hbWUgKyBzdWZmaXg7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGNvbnN0cnVjdCkge1xuICAgICAgaWYgKCFmbiB8fCByZWVudHJ5KSByZXR1cm4gXCJcIjtcbiAgICAgIHZhciBmcmFtZSA9IGNvbXBvbmVudEZyYW1lQ2FjaGUuZ2V0KGZuKTtcbiAgICAgIGlmICh2b2lkIDAgIT09IGZyYW1lKSByZXR1cm4gZnJhbWU7XG4gICAgICByZWVudHJ5ID0gITA7XG4gICAgICBmcmFtZSA9IEVycm9yLnByZXBhcmVTdGFja1RyYWNlO1xuICAgICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSB2b2lkIDA7XG4gICAgICB2YXIgcHJldmlvdXNEaXNwYXRjaGVyID0gbnVsbDtcbiAgICAgIHByZXZpb3VzRGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkg7XG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gbnVsbDtcbiAgICAgIGRpc2FibGVMb2dzKCk7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgUnVuSW5Sb290RnJhbWUgPSB7XG4gICAgICAgICAgRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBpZiAoY29uc3RydWN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIEZha2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZha2UucHJvdG90eXBlLCBcInByb3BzXCIsIHtcbiAgICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChcIm9iamVjdFwiID09PSB0eXBlb2YgUmVmbGVjdCAmJiBSZWZsZWN0LmNvbnN0cnVjdCkge1xuICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoRmFrZSwgW10pO1xuICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29udHJvbCA9IHg7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChmbiwgW10sIEZha2UpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBGYWtlLmNhbGwoKTtcbiAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKHgkMCkge1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sID0geCQwO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZm4uY2FsbChGYWtlLnByb3RvdHlwZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKHgkMSkge1xuICAgICAgICAgICAgICAgICAgY29udHJvbCA9IHgkMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKEZha2UgPSBmbigpKSAmJlxuICAgICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgRmFrZS5jYXRjaCAmJlxuICAgICAgICAgICAgICAgICAgRmFrZS5jYXRjaChmdW5jdGlvbiAoKSB7fSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKHNhbXBsZSkge1xuICAgICAgICAgICAgICBpZiAoc2FtcGxlICYmIGNvbnRyb2wgJiYgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHNhbXBsZS5zdGFjaylcbiAgICAgICAgICAgICAgICByZXR1cm4gW3NhbXBsZS5zdGFjaywgY29udHJvbC5zdGFja107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW251bGwsIG51bGxdO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290LmRpc3BsYXlOYW1lID1cbiAgICAgICAgICBcIkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdFwiO1xuICAgICAgICB2YXIgbmFtZVByb3BEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihcbiAgICAgICAgICBSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QsXG4gICAgICAgICAgXCJuYW1lXCJcbiAgICAgICAgKTtcbiAgICAgICAgbmFtZVByb3BEZXNjcmlwdG9yICYmXG4gICAgICAgICAgbmFtZVByb3BEZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSAmJlxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShcbiAgICAgICAgICAgIFJ1bkluUm9vdEZyYW1lLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCxcbiAgICAgICAgICAgIFwibmFtZVwiLFxuICAgICAgICAgICAgeyB2YWx1ZTogXCJEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3RcIiB9XG4gICAgICAgICAgKTtcbiAgICAgICAgdmFyIF9SdW5JblJvb3RGcmFtZSREZXRlciA9XG4gICAgICAgICAgICBSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QoKSxcbiAgICAgICAgICBzYW1wbGVTdGFjayA9IF9SdW5JblJvb3RGcmFtZSREZXRlclswXSxcbiAgICAgICAgICBjb250cm9sU3RhY2sgPSBfUnVuSW5Sb290RnJhbWUkRGV0ZXJbMV07XG4gICAgICAgIGlmIChzYW1wbGVTdGFjayAmJiBjb250cm9sU3RhY2spIHtcbiAgICAgICAgICB2YXIgc2FtcGxlTGluZXMgPSBzYW1wbGVTdGFjay5zcGxpdChcIlxcblwiKSxcbiAgICAgICAgICAgIGNvbnRyb2xMaW5lcyA9IGNvbnRyb2xTdGFjay5zcGxpdChcIlxcblwiKTtcbiAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgX1J1bkluUm9vdEZyYW1lJERldGVyID0gbmFtZVByb3BEZXNjcmlwdG9yID0gMDtcbiAgICAgICAgICAgIG5hbWVQcm9wRGVzY3JpcHRvciA8IHNhbXBsZUxpbmVzLmxlbmd0aCAmJlxuICAgICAgICAgICAgIXNhbXBsZUxpbmVzW25hbWVQcm9wRGVzY3JpcHRvcl0uaW5jbHVkZXMoXG4gICAgICAgICAgICAgIFwiRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290XCJcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICApXG4gICAgICAgICAgICBuYW1lUHJvcERlc2NyaXB0b3IrKztcbiAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgO1xuICAgICAgICAgICAgX1J1bkluUm9vdEZyYW1lJERldGVyIDwgY29udHJvbExpbmVzLmxlbmd0aCAmJlxuICAgICAgICAgICAgIWNvbnRyb2xMaW5lc1tfUnVuSW5Sb290RnJhbWUkRGV0ZXJdLmluY2x1ZGVzKFxuICAgICAgICAgICAgICBcIkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdFwiXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgKVxuICAgICAgICAgICAgX1J1bkluUm9vdEZyYW1lJERldGVyKys7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgbmFtZVByb3BEZXNjcmlwdG9yID09PSBzYW1wbGVMaW5lcy5sZW5ndGggfHxcbiAgICAgICAgICAgIF9SdW5JblJvb3RGcmFtZSREZXRlciA9PT0gY29udHJvbExpbmVzLmxlbmd0aFxuICAgICAgICAgIClcbiAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgIG5hbWVQcm9wRGVzY3JpcHRvciA9IHNhbXBsZUxpbmVzLmxlbmd0aCAtIDEsXG4gICAgICAgICAgICAgICAgX1J1bkluUm9vdEZyYW1lJERldGVyID0gY29udHJvbExpbmVzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgIDEgPD0gbmFtZVByb3BEZXNjcmlwdG9yICYmXG4gICAgICAgICAgICAgIDAgPD0gX1J1bkluUm9vdEZyYW1lJERldGVyICYmXG4gICAgICAgICAgICAgIHNhbXBsZUxpbmVzW25hbWVQcm9wRGVzY3JpcHRvcl0gIT09XG4gICAgICAgICAgICAgICAgY29udHJvbExpbmVzW19SdW5JblJvb3RGcmFtZSREZXRlcl07XG5cbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgX1J1bkluUm9vdEZyYW1lJERldGVyLS07XG4gICAgICAgICAgZm9yIChcbiAgICAgICAgICAgIDtcbiAgICAgICAgICAgIDEgPD0gbmFtZVByb3BEZXNjcmlwdG9yICYmIDAgPD0gX1J1bkluUm9vdEZyYW1lJERldGVyO1xuICAgICAgICAgICAgbmFtZVByb3BEZXNjcmlwdG9yLS0sIF9SdW5JblJvb3RGcmFtZSREZXRlci0tXG4gICAgICAgICAgKVxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBzYW1wbGVMaW5lc1tuYW1lUHJvcERlc2NyaXB0b3JdICE9PVxuICAgICAgICAgICAgICBjb250cm9sTGluZXNbX1J1bkluUm9vdEZyYW1lJERldGVyXVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIGlmICgxICE9PSBuYW1lUHJvcERlc2NyaXB0b3IgfHwgMSAhPT0gX1J1bkluUm9vdEZyYW1lJERldGVyKSB7XG4gICAgICAgICAgICAgICAgZG9cbiAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgKG5hbWVQcm9wRGVzY3JpcHRvci0tLFxuICAgICAgICAgICAgICAgICAgICBfUnVuSW5Sb290RnJhbWUkRGV0ZXItLSxcbiAgICAgICAgICAgICAgICAgICAgMCA+IF9SdW5JblJvb3RGcmFtZSREZXRlciB8fFxuICAgICAgICAgICAgICAgICAgICAgIHNhbXBsZUxpbmVzW25hbWVQcm9wRGVzY3JpcHRvcl0gIT09XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sTGluZXNbX1J1bkluUm9vdEZyYW1lJERldGVyXSlcbiAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2ZyYW1lID1cbiAgICAgICAgICAgICAgICAgICAgICBcIlxcblwiICtcbiAgICAgICAgICAgICAgICAgICAgICBzYW1wbGVMaW5lc1tuYW1lUHJvcERlc2NyaXB0b3JdLnJlcGxhY2UoXG4gICAgICAgICAgICAgICAgICAgICAgICBcIiBhdCBuZXcgXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcIiBhdCBcIlxuICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGZuLmRpc3BsYXlOYW1lICYmXG4gICAgICAgICAgICAgICAgICAgICAgX2ZyYW1lLmluY2x1ZGVzKFwiPGFub255bW91cz5cIikgJiZcbiAgICAgICAgICAgICAgICAgICAgICAoX2ZyYW1lID0gX2ZyYW1lLnJlcGxhY2UoXCI8YW5vbnltb3VzPlwiLCBmbi5kaXNwbGF5TmFtZSkpO1xuICAgICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBmbiAmJlxuICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBfZnJhbWUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2ZyYW1lO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdoaWxlICgxIDw9IG5hbWVQcm9wRGVzY3JpcHRvciAmJiAwIDw9IF9SdW5JblJvb3RGcmFtZSREZXRlcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIChyZWVudHJ5ID0gITEpLFxuICAgICAgICAgIChSZWFjdFNoYXJlZEludGVybmFscy5IID0gcHJldmlvdXNEaXNwYXRjaGVyKSxcbiAgICAgICAgICByZWVuYWJsZUxvZ3MoKSxcbiAgICAgICAgICAoRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBmcmFtZSk7XG4gICAgICB9XG4gICAgICBzYW1wbGVMaW5lcyA9IChzYW1wbGVMaW5lcyA9IGZuID8gZm4uZGlzcGxheU5hbWUgfHwgZm4ubmFtZSA6IFwiXCIpXG4gICAgICAgID8gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoc2FtcGxlTGluZXMpXG4gICAgICAgIDogXCJcIjtcbiAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGZuICYmIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBzYW1wbGVMaW5lcyk7XG4gICAgICByZXR1cm4gc2FtcGxlTGluZXM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlKSB7XG4gICAgICBpZiAobnVsbCA9PSB0eXBlKSByZXR1cm4gXCJcIjtcbiAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB0eXBlKSB7XG4gICAgICAgIHZhciBwcm90b3R5cGUgPSB0eXBlLnByb3RvdHlwZTtcbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoXG4gICAgICAgICAgdHlwZSxcbiAgICAgICAgICAhKCFwcm90b3R5cGUgfHwgIXByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiB0eXBlKSByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUodHlwZSk7XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShcIlN1c3BlbnNlXCIpO1xuICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoXCJTdXNwZW5zZUxpc3RcIik7XG4gICAgICB9XG4gICAgICBpZiAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIHR5cGUpXG4gICAgICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiAodHlwZSA9IGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUodHlwZS5yZW5kZXIsICExKSksIHR5cGU7XG4gICAgICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUudHlwZSk7XG4gICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICBwcm90b3R5cGUgPSB0eXBlLl9wYXlsb2FkO1xuICAgICAgICAgICAgdHlwZSA9IHR5cGUuX2luaXQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUocHJvdG90eXBlKSk7XG4gICAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0T3duZXIoKSB7XG4gICAgICB2YXIgZGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkE7XG4gICAgICByZXR1cm4gbnVsbCA9PT0gZGlzcGF0Y2hlciA/IG51bGwgOiBkaXNwYXRjaGVyLmdldE93bmVyKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhc1ZhbGlkS2V5KGNvbmZpZykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBcImtleVwiKSkge1xuICAgICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsIFwia2V5XCIpLmdldDtcbiAgICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHJldHVybiAhMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2b2lkIDAgIT09IGNvbmZpZy5rZXk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICAgICAgZnVuY3Rpb24gd2FybkFib3V0QWNjZXNzaW5nS2V5KCkge1xuICAgICAgICBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biB8fFxuICAgICAgICAgICgoc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24gPSAhMCksXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiJXM6IGBrZXlgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSB2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50IHByb3AuIChodHRwczovL3JlYWN0LmRldi9saW5rL3NwZWNpYWwtcHJvcHMpXCIsXG4gICAgICAgICAgICBkaXNwbGF5TmFtZVxuICAgICAgICAgICkpO1xuICAgICAgfVxuICAgICAgd2FybkFib3V0QWNjZXNzaW5nS2V5LmlzUmVhY3RXYXJuaW5nID0gITA7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsIFwia2V5XCIsIHtcbiAgICAgICAgZ2V0OiB3YXJuQWJvdXRBY2Nlc3NpbmdLZXksXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlbGVtZW50UmVmR2V0dGVyV2l0aERlcHJlY2F0aW9uV2FybmluZygpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHRoaXMudHlwZSk7XG4gICAgICBkaWRXYXJuQWJvdXRFbGVtZW50UmVmW2NvbXBvbmVudE5hbWVdIHx8XG4gICAgICAgICgoZGlkV2FybkFib3V0RWxlbWVudFJlZltjb21wb25lbnROYW1lXSA9ICEwKSxcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIkFjY2Vzc2luZyBlbGVtZW50LnJlZiB3YXMgcmVtb3ZlZCBpbiBSZWFjdCAxOS4gcmVmIGlzIG5vdyBhIHJlZ3VsYXIgcHJvcC4gSXQgd2lsbCBiZSByZW1vdmVkIGZyb20gdGhlIEpTWCBFbGVtZW50IHR5cGUgaW4gYSBmdXR1cmUgcmVsZWFzZS5cIlxuICAgICAgICApKTtcbiAgICAgIGNvbXBvbmVudE5hbWUgPSB0aGlzLnByb3BzLnJlZjtcbiAgICAgIHJldHVybiB2b2lkIDAgIT09IGNvbXBvbmVudE5hbWUgPyBjb21wb25lbnROYW1lIDogbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gUmVhY3RFbGVtZW50KHR5cGUsIGtleSwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpIHtcbiAgICAgIHNlbGYgPSBwcm9wcy5yZWY7XG4gICAgICB0eXBlID0ge1xuICAgICAgICAkJHR5cGVvZjogUkVBQ1RfRUxFTUVOVF9UWVBFLFxuICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgcHJvcHM6IHByb3BzLFxuICAgICAgICBfb3duZXI6IG93bmVyXG4gICAgICB9O1xuICAgICAgbnVsbCAhPT0gKHZvaWQgMCAhPT0gc2VsZiA/IHNlbGYgOiBudWxsKVxuICAgICAgICA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0eXBlLCBcInJlZlwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgICAgIGdldDogZWxlbWVudFJlZkdldHRlcldpdGhEZXByZWNhdGlvbldhcm5pbmdcbiAgICAgICAgICB9KVxuICAgICAgICA6IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0eXBlLCBcInJlZlwiLCB7IGVudW1lcmFibGU6ICExLCB2YWx1ZTogbnVsbCB9KTtcbiAgICAgIHR5cGUuX3N0b3JlID0ge307XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodHlwZS5fc3RvcmUsIFwidmFsaWRhdGVkXCIsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMSxcbiAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgIHdyaXRhYmxlOiAhMCxcbiAgICAgICAgdmFsdWU6IDBcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHR5cGUsIFwiX2RlYnVnSW5mb1wiLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITEsXG4gICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICB3cml0YWJsZTogITAsXG4gICAgICAgIHZhbHVlOiBudWxsXG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5mcmVlemUgJiYgKE9iamVjdC5mcmVlemUodHlwZS5wcm9wcyksIE9iamVjdC5mcmVlemUodHlwZSkpO1xuICAgICAgcmV0dXJuIHR5cGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGpzeERFVkltcGwoXG4gICAgICB0eXBlLFxuICAgICAgY29uZmlnLFxuICAgICAgbWF5YmVLZXksXG4gICAgICBpc1N0YXRpY0NoaWxkcmVuLFxuICAgICAgc291cmNlLFxuICAgICAgc2VsZlxuICAgICkge1xuICAgICAgaWYgKFxuICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgdHlwZSB8fFxuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB0eXBlIHx8XG4gICAgICAgIHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUgfHxcbiAgICAgICAgdHlwZSA9PT0gUkVBQ1RfUFJPRklMRVJfVFlQRSB8fFxuICAgICAgICB0eXBlID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIHx8XG4gICAgICAgIHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX1RZUEUgfHxcbiAgICAgICAgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFIHx8XG4gICAgICAgIHR5cGUgPT09IFJFQUNUX09GRlNDUkVFTl9UWVBFIHx8XG4gICAgICAgIChcIm9iamVjdFwiID09PSB0eXBlb2YgdHlwZSAmJlxuICAgICAgICAgIG51bGwgIT09IHR5cGUgJiZcbiAgICAgICAgICAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFIHx8XG4gICAgICAgICAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUgfHxcbiAgICAgICAgICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSB8fFxuICAgICAgICAgICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OU1VNRVJfVFlQRSB8fFxuICAgICAgICAgICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fFxuICAgICAgICAgICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSQxIHx8XG4gICAgICAgICAgICB2b2lkIDAgIT09IHR5cGUuZ2V0TW9kdWxlSWQpKVxuICAgICAgKSB7XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IGNvbmZpZy5jaGlsZHJlbjtcbiAgICAgICAgaWYgKHZvaWQgMCAhPT0gY2hpbGRyZW4pXG4gICAgICAgICAgaWYgKGlzU3RhdGljQ2hpbGRyZW4pXG4gICAgICAgICAgICBpZiAoaXNBcnJheUltcGwoY2hpbGRyZW4pKSB7XG4gICAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgICAgaXNTdGF0aWNDaGlsZHJlbiA9IDA7XG4gICAgICAgICAgICAgICAgaXNTdGF0aWNDaGlsZHJlbiA8IGNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpc1N0YXRpY0NoaWxkcmVuKytcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuW2lzU3RhdGljQ2hpbGRyZW5dLCB0eXBlKTtcbiAgICAgICAgICAgICAgT2JqZWN0LmZyZWV6ZSAmJiBPYmplY3QuZnJlZXplKGNoaWxkcmVuKTtcbiAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgIFwiUmVhY3QuanN4OiBTdGF0aWMgY2hpbGRyZW4gc2hvdWxkIGFsd2F5cyBiZSBhbiBhcnJheS4gWW91IGFyZSBsaWtlbHkgZXhwbGljaXRseSBjYWxsaW5nIFJlYWN0LmpzeHMgb3IgUmVhY3QuanN4REVWLiBVc2UgdGhlIEJhYmVsIHRyYW5zZm9ybSBpbnN0ZWFkLlwiXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgZWxzZSB2YWxpZGF0ZUNoaWxkS2V5cyhjaGlsZHJlbiwgdHlwZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjaGlsZHJlbiA9IFwiXCI7XG4gICAgICAgIGlmIChcbiAgICAgICAgICB2b2lkIDAgPT09IHR5cGUgfHxcbiAgICAgICAgICAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIHR5cGUgJiZcbiAgICAgICAgICAgIG51bGwgIT09IHR5cGUgJiZcbiAgICAgICAgICAgIDAgPT09IE9iamVjdC5rZXlzKHR5cGUpLmxlbmd0aClcbiAgICAgICAgKVxuICAgICAgICAgIGNoaWxkcmVuICs9XG4gICAgICAgICAgICBcIiBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSBpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIG5hbWVkIGltcG9ydHMuXCI7XG4gICAgICAgIG51bGwgPT09IHR5cGVcbiAgICAgICAgICA/IChpc1N0YXRpY0NoaWxkcmVuID0gXCJudWxsXCIpXG4gICAgICAgICAgOiBpc0FycmF5SW1wbCh0eXBlKVxuICAgICAgICAgICAgPyAoaXNTdGF0aWNDaGlsZHJlbiA9IFwiYXJyYXlcIilcbiAgICAgICAgICAgIDogdm9pZCAwICE9PSB0eXBlICYmIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRVxuICAgICAgICAgICAgICA/ICgoaXNTdGF0aWNDaGlsZHJlbiA9XG4gICAgICAgICAgICAgICAgICBcIjxcIiArXG4gICAgICAgICAgICAgICAgICAoZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUudHlwZSkgfHwgXCJVbmtub3duXCIpICtcbiAgICAgICAgICAgICAgICAgIFwiIC8+XCIpLFxuICAgICAgICAgICAgICAgIChjaGlsZHJlbiA9XG4gICAgICAgICAgICAgICAgICBcIiBEaWQgeW91IGFjY2lkZW50YWxseSBleHBvcnQgYSBKU1ggbGl0ZXJhbCBpbnN0ZWFkIG9mIGEgY29tcG9uZW50P1wiKSlcbiAgICAgICAgICAgICAgOiAoaXNTdGF0aWNDaGlsZHJlbiA9IHR5cGVvZiB0eXBlKTtcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIlJlYWN0LmpzeDogdHlwZSBpcyBpbnZhbGlkIC0tIGV4cGVjdGVkIGEgc3RyaW5nIChmb3IgYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSBjb21wb25lbnRzKSBidXQgZ290OiAlcy4lc1wiLFxuICAgICAgICAgIGlzU3RhdGljQ2hpbGRyZW4sXG4gICAgICAgICAgY2hpbGRyZW5cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgXCJrZXlcIikpIHtcbiAgICAgICAgY2hpbGRyZW4gPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSk7XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoY29uZmlnKS5maWx0ZXIoZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICByZXR1cm4gXCJrZXlcIiAhPT0gaztcbiAgICAgICAgfSk7XG4gICAgICAgIGlzU3RhdGljQ2hpbGRyZW4gPVxuICAgICAgICAgIDAgPCBrZXlzLmxlbmd0aFxuICAgICAgICAgICAgPyBcIntrZXk6IHNvbWVLZXksIFwiICsga2V5cy5qb2luKFwiOiAuLi4sIFwiKSArIFwiOiAuLi59XCJcbiAgICAgICAgICAgIDogXCJ7a2V5OiBzb21lS2V5fVwiO1xuICAgICAgICBkaWRXYXJuQWJvdXRLZXlTcHJlYWRbY2hpbGRyZW4gKyBpc1N0YXRpY0NoaWxkcmVuXSB8fFxuICAgICAgICAgICgoa2V5cyA9XG4gICAgICAgICAgICAwIDwga2V5cy5sZW5ndGggPyBcIntcIiArIGtleXMuam9pbihcIjogLi4uLCBcIikgKyBcIjogLi4ufVwiIDogXCJ7fVwiKSxcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgJ0EgcHJvcHMgb2JqZWN0IGNvbnRhaW5pbmcgYSBcImtleVwiIHByb3AgaXMgYmVpbmcgc3ByZWFkIGludG8gSlNYOlxcbiAgbGV0IHByb3BzID0gJXM7XFxuICA8JXMgey4uLnByb3BzfSAvPlxcblJlYWN0IGtleXMgbXVzdCBiZSBwYXNzZWQgZGlyZWN0bHkgdG8gSlNYIHdpdGhvdXQgdXNpbmcgc3ByZWFkOlxcbiAgbGV0IHByb3BzID0gJXM7XFxuICA8JXMga2V5PXtzb21lS2V5fSB7Li4ucHJvcHN9IC8+JyxcbiAgICAgICAgICAgIGlzU3RhdGljQ2hpbGRyZW4sXG4gICAgICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgICAgIGtleXMsXG4gICAgICAgICAgICBjaGlsZHJlblxuICAgICAgICAgICksXG4gICAgICAgICAgKGRpZFdhcm5BYm91dEtleVNwcmVhZFtjaGlsZHJlbiArIGlzU3RhdGljQ2hpbGRyZW5dID0gITApKTtcbiAgICAgIH1cbiAgICAgIGNoaWxkcmVuID0gbnVsbDtcbiAgICAgIHZvaWQgMCAhPT0gbWF5YmVLZXkgJiZcbiAgICAgICAgKGNoZWNrS2V5U3RyaW5nQ29lcmNpb24obWF5YmVLZXkpLCAoY2hpbGRyZW4gPSBcIlwiICsgbWF5YmVLZXkpKTtcbiAgICAgIGhhc1ZhbGlkS2V5KGNvbmZpZykgJiZcbiAgICAgICAgKGNoZWNrS2V5U3RyaW5nQ29lcmNpb24oY29uZmlnLmtleSksIChjaGlsZHJlbiA9IFwiXCIgKyBjb25maWcua2V5KSk7XG4gICAgICBpZiAoXCJrZXlcIiBpbiBjb25maWcpIHtcbiAgICAgICAgbWF5YmVLZXkgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gY29uZmlnKVxuICAgICAgICAgIFwia2V5XCIgIT09IHByb3BOYW1lICYmIChtYXliZUtleVtwcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdKTtcbiAgICAgIH0gZWxzZSBtYXliZUtleSA9IGNvbmZpZztcbiAgICAgIGNoaWxkcmVuICYmXG4gICAgICAgIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKFxuICAgICAgICAgIG1heWJlS2V5LFxuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHR5cGVcbiAgICAgICAgICAgID8gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgXCJVbmtub3duXCJcbiAgICAgICAgICAgIDogdHlwZVxuICAgICAgICApO1xuICAgICAgcmV0dXJuIFJlYWN0RWxlbWVudCh0eXBlLCBjaGlsZHJlbiwgc2VsZiwgc291cmNlLCBnZXRPd25lcigpLCBtYXliZUtleSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlQ2hpbGRLZXlzKG5vZGUsIHBhcmVudFR5cGUpIHtcbiAgICAgIGlmIChcbiAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIG5vZGUgJiZcbiAgICAgICAgbm9kZSAmJlxuICAgICAgICBub2RlLiQkdHlwZW9mICE9PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFXG4gICAgICApXG4gICAgICAgIGlmIChpc0FycmF5SW1wbChub2RlKSlcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjaGlsZCA9IG5vZGVbaV07XG4gICAgICAgICAgICBpc1ZhbGlkRWxlbWVudChjaGlsZCkgJiYgdmFsaWRhdGVFeHBsaWNpdEtleShjaGlsZCwgcGFyZW50VHlwZSk7XG4gICAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1ZhbGlkRWxlbWVudChub2RlKSlcbiAgICAgICAgICBub2RlLl9zdG9yZSAmJiAobm9kZS5fc3RvcmUudmFsaWRhdGVkID0gMSk7XG4gICAgICAgIGVsc2UgaWYgKFxuICAgICAgICAgIChudWxsID09PSBub2RlIHx8IFwib2JqZWN0XCIgIT09IHR5cGVvZiBub2RlXG4gICAgICAgICAgICA/IChpID0gbnVsbClcbiAgICAgICAgICAgIDogKChpID1cbiAgICAgICAgICAgICAgICAoTUFZQkVfSVRFUkFUT1JfU1lNQk9MICYmIG5vZGVbTUFZQkVfSVRFUkFUT1JfU1lNQk9MXSkgfHxcbiAgICAgICAgICAgICAgICBub2RlW1wiQEBpdGVyYXRvclwiXSksXG4gICAgICAgICAgICAgIChpID0gXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaSA/IGkgOiBudWxsKSksXG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaSAmJlxuICAgICAgICAgICAgaSAhPT0gbm9kZS5lbnRyaWVzICYmXG4gICAgICAgICAgICAoKGkgPSBpLmNhbGwobm9kZSkpLCBpICE9PSBub2RlKSlcbiAgICAgICAgKVxuICAgICAgICAgIGZvciAoOyAhKG5vZGUgPSBpLm5leHQoKSkuZG9uZTsgKVxuICAgICAgICAgICAgaXNWYWxpZEVsZW1lbnQobm9kZS52YWx1ZSkgJiZcbiAgICAgICAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShub2RlLnZhbHVlLCBwYXJlbnRUeXBlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnQob2JqZWN0KSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2Ygb2JqZWN0ICYmXG4gICAgICAgIG51bGwgIT09IG9iamVjdCAmJlxuICAgICAgICBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRVxuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdmFsaWRhdGVFeHBsaWNpdEtleShlbGVtZW50LCBwYXJlbnRUeXBlKSB7XG4gICAgICBpZiAoXG4gICAgICAgIGVsZW1lbnQuX3N0b3JlICYmXG4gICAgICAgICFlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgJiZcbiAgICAgICAgbnVsbCA9PSBlbGVtZW50LmtleSAmJlxuICAgICAgICAoKGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IDEpLFxuICAgICAgICAocGFyZW50VHlwZSA9IGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSkpLFxuICAgICAgICAhb3duZXJIYXNLZXlVc2VXYXJuaW5nW3BhcmVudFR5cGVdKVxuICAgICAgKSB7XG4gICAgICAgIG93bmVySGFzS2V5VXNlV2FybmluZ1twYXJlbnRUeXBlXSA9ICEwO1xuICAgICAgICB2YXIgY2hpbGRPd25lciA9IFwiXCI7XG4gICAgICAgIGVsZW1lbnQgJiZcbiAgICAgICAgICBudWxsICE9IGVsZW1lbnQuX293bmVyICYmXG4gICAgICAgICAgZWxlbWVudC5fb3duZXIgIT09IGdldE93bmVyKCkgJiZcbiAgICAgICAgICAoKGNoaWxkT3duZXIgPSBudWxsKSxcbiAgICAgICAgICBcIm51bWJlclwiID09PSB0eXBlb2YgZWxlbWVudC5fb3duZXIudGFnXG4gICAgICAgICAgICA/IChjaGlsZE93bmVyID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGVsZW1lbnQuX293bmVyLnR5cGUpKVxuICAgICAgICAgICAgOiBcInN0cmluZ1wiID09PSB0eXBlb2YgZWxlbWVudC5fb3duZXIubmFtZSAmJlxuICAgICAgICAgICAgICAoY2hpbGRPd25lciA9IGVsZW1lbnQuX293bmVyLm5hbWUpLFxuICAgICAgICAgIChjaGlsZE93bmVyID0gXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyBjaGlsZE93bmVyICsgXCIuXCIpKTtcbiAgICAgICAgdmFyIHByZXZHZXRDdXJyZW50U3RhY2sgPSBSZWFjdFNoYXJlZEludGVybmFscy5nZXRDdXJyZW50U3RhY2s7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLmdldEN1cnJlbnRTdGFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgc3RhY2sgPSBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoZWxlbWVudC50eXBlKTtcbiAgICAgICAgICBwcmV2R2V0Q3VycmVudFN0YWNrICYmIChzdGFjayArPSBwcmV2R2V0Q3VycmVudFN0YWNrKCkgfHwgXCJcIik7XG4gICAgICAgICAgcmV0dXJuIHN0YWNrO1xuICAgICAgICB9O1xuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJXMlcyBTZWUgaHR0cHM6Ly9yZWFjdC5kZXYvbGluay93YXJuaW5nLWtleXMgZm9yIG1vcmUgaW5mb3JtYXRpb24uJyxcbiAgICAgICAgICBwYXJlbnRUeXBlLFxuICAgICAgICAgIGNoaWxkT3duZXJcbiAgICAgICAgKTtcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuZ2V0Q3VycmVudFN0YWNrID0gcHJldkdldEN1cnJlbnRTdGFjaztcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyhwYXJlbnRUeXBlKSB7XG4gICAgICB2YXIgaW5mbyA9IFwiXCIsXG4gICAgICAgIG93bmVyID0gZ2V0T3duZXIoKTtcbiAgICAgIG93bmVyICYmXG4gICAgICAgIChvd25lciA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShvd25lci50eXBlKSkgJiZcbiAgICAgICAgKGluZm8gPSBcIlxcblxcbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGBcIiArIG93bmVyICsgXCJgLlwiKTtcbiAgICAgIGluZm8gfHxcbiAgICAgICAgKChwYXJlbnRUeXBlID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHBhcmVudFR5cGUpKSAmJlxuICAgICAgICAgIChpbmZvID1cbiAgICAgICAgICAgIFwiXFxuXFxuQ2hlY2sgdGhlIHRvcC1sZXZlbCByZW5kZXIgY2FsbCB1c2luZyA8XCIgKyBwYXJlbnRUeXBlICsgXCI+LlwiKSk7XG4gICAgICByZXR1cm4gaW5mbztcbiAgICB9XG4gICAgdmFyIFJlYWN0ID0gcmVxdWlyZShcIm5leHQvZGlzdC9jb21waWxlZC9yZWFjdFwiKSxcbiAgICAgIFJFQUNUX0VMRU1FTlRfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC50cmFuc2l0aW9uYWwuZWxlbWVudFwiKSxcbiAgICAgIFJFQUNUX1BPUlRBTF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnBvcnRhbFwiKSxcbiAgICAgIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuZnJhZ21lbnRcIiksXG4gICAgICBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnN0cmljdF9tb2RlXCIpLFxuICAgICAgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5wcm9maWxlclwiKTtcbiAgICBTeW1ib2wuZm9yKFwicmVhY3QucHJvdmlkZXJcIik7XG4gICAgdmFyIFJFQUNUX0NPTlNVTUVSX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuY29uc3VtZXJcIiksXG4gICAgICBSRUFDVF9DT05URVhUX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuY29udGV4dFwiKSxcbiAgICAgIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuZm9yd2FyZF9yZWZcIiksXG4gICAgICBSRUFDVF9TVVNQRU5TRV9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlXCIpLFxuICAgICAgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlX2xpc3RcIiksXG4gICAgICBSRUFDVF9NRU1PX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QubWVtb1wiKSxcbiAgICAgIFJFQUNUX0xBWllfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5sYXp5XCIpLFxuICAgICAgUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Qub2Zmc2NyZWVuXCIpLFxuICAgICAgTUFZQkVfSVRFUkFUT1JfU1lNQk9MID0gU3ltYm9sLml0ZXJhdG9yLFxuICAgICAgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSQyID0gU3ltYm9sLmZvcihcInJlYWN0LmNsaWVudC5yZWZlcmVuY2VcIiksXG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscyA9XG4gICAgICAgIFJlYWN0Ll9fQ0xJRU5UX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1dBUk5fVVNFUlNfVEhFWV9DQU5OT1RfVVBHUkFERSxcbiAgICAgIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSxcbiAgICAgIGFzc2lnbiA9IE9iamVjdC5hc3NpZ24sXG4gICAgICBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDEgPSBTeW1ib2wuZm9yKFwicmVhY3QuY2xpZW50LnJlZmVyZW5jZVwiKSxcbiAgICAgIGlzQXJyYXlJbXBsID0gQXJyYXkuaXNBcnJheSxcbiAgICAgIGRpc2FibGVkRGVwdGggPSAwLFxuICAgICAgcHJldkxvZyxcbiAgICAgIHByZXZJbmZvLFxuICAgICAgcHJldldhcm4sXG4gICAgICBwcmV2RXJyb3IsXG4gICAgICBwcmV2R3JvdXAsXG4gICAgICBwcmV2R3JvdXBDb2xsYXBzZWQsXG4gICAgICBwcmV2R3JvdXBFbmQ7XG4gICAgZGlzYWJsZWRMb2cuX19yZWFjdERpc2FibGVkTG9nID0gITA7XG4gICAgdmFyIHByZWZpeCxcbiAgICAgIHN1ZmZpeCxcbiAgICAgIHJlZW50cnkgPSAhMTtcbiAgICB2YXIgY29tcG9uZW50RnJhbWVDYWNoZSA9IG5ldyAoXG4gICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBXZWFrTWFwID8gV2Vha01hcCA6IE1hcFxuICAgICkoKTtcbiAgICB2YXIgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jbGllbnQucmVmZXJlbmNlXCIpLFxuICAgICAgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd247XG4gICAgdmFyIGRpZFdhcm5BYm91dEVsZW1lbnRSZWYgPSB7fTtcbiAgICB2YXIgZGlkV2FybkFib3V0S2V5U3ByZWFkID0ge30sXG4gICAgICBvd25lckhhc0tleVVzZVdhcm5pbmcgPSB7fTtcbiAgICBleHBvcnRzLkZyYWdtZW50ID0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbiAgICBleHBvcnRzLmpzeERFViA9IGZ1bmN0aW9uIChcbiAgICAgIHR5cGUsXG4gICAgICBjb25maWcsXG4gICAgICBtYXliZUtleSxcbiAgICAgIGlzU3RhdGljQ2hpbGRyZW4sXG4gICAgICBzb3VyY2UsXG4gICAgICBzZWxmXG4gICAgKSB7XG4gICAgICByZXR1cm4ganN4REVWSW1wbCh0eXBlLCBjb25maWcsIG1heWJlS2V5LCBpc1N0YXRpY0NoaWxkcmVuLCBzb3VyY2UsIHNlbGYpO1xuICAgIH07XG4gIH0pKCk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/jsx-dev-runtime.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvanN4LWRldi1ydW50aW1lLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsRUFBRSw4TEFBc0U7QUFDeEUiLCJzb3VyY2VzIjpbIi9Vc2Vycy9qb25hdGhhbnZpbmNlbnRpdXMvRG9jdW1lbnRzL1VvZlQvUHJvamVjdHMvY293cml0aW5nLWxsbS1hZ2VudC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0L2pzeC1kZXYtcnVudGltZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLnByb2R1Y3Rpb24uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzJyk7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\n"));

/***/ })

},
/******/ __webpack_require__ => { // webpackRuntimeModules
/******/ var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
/******/ __webpack_require__.O(0, ["main-app"], () => (__webpack_exec__("(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Fjonathanvincentius%2FDocuments%2FUofT%2FProjects%2Fcowriting-llm-agent%2Fsrc%2Fapp%2Fmulti%2Fpage.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false!")));
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);